<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[饥荒Don't starve together Mac独立服务器搭建]]></title>
      <url>%2F2017%2F03%2F03%2F%E9%A5%A5%E8%8D%92Don-t-starve-together-Mac%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[1. 购买正版饥荒2. 创建世界 先创建好世界（进去一次地图后再退出来）。 再次进入，看看你建立的世界是第几个世界。（此时为第一个） 在刚登入游戏的界面，点击右下角的“个人资料”（应该是左起第二个），会弹出来一个页面。随机生成一个专用服务器令牌（下图马赛克中的部分），记录下来。 准备工作做完了，剩下的是配置过程。 3.配置3.1 建立验证文件（估计是为了防盗版）先找到你刚刚创建的那个世界的文件夹，Mac下在~/Documents/Klei/DoNotStarveTogether/中，跳转至这个文件夹。1cd ~/Documents/Klei/DoNotStarveTogether/ 这个文件夹下应该有多个文件Cluster_1, Cluster_2等等。我刚刚创建的是第一个世界，这就应该是Cluster_1，跳转进这个文件夹。1cd Cluster_1 建立文件cluster_token.txt并把刚刚的专用服务器令牌(your_token替换为你的token)写进文件中。1echo your_token &gt; cluster_token.txt 3.2 创建启动脚本跳转DST提供的独立服务器的脚本目录。1cd ~/Library/Application Support/Steam/steamapps/common/Don't Starve Together/dontstarve_steam.app/Contents/MacOS 该目录下dontstarve_dedicated_server_nullrenderer这个文件，是DST提供的独立服务器的执行文件。写两个脚本文件分别用来生成地上和洞穴的服务器。123echo "./dontstarve_dedicated_server_nullrenderer -console -cluster Cluster_\$1 -shard Master" &gt; start.sh &amp;&amp; chmod +x start.shecho "./dontstarve_dedicated_server_nullrenderer -console -cluster Cluster_\$1 -shard Caves" &gt; start_cave.sh &amp;&amp; chmod +x start_cave.sh 然后执行脚本文件./start.sh id, id就是你地图的编号，再进入游戏就能找到地图了（不是在创建世界中，在寻找房间里。如果你是本机上搭建的服务器，那就在本地找。其他人照常在服务器上找。） 注意，先打开游戏以后再建立服务器。 我先建立服务器再进游戏就进不去了，不知道是不是我的个例。 3.3 快速启动脚本之前的步骤已经足够搭建服务器了。但是如果不想每次都生成一下验证文件还专门跳转到启动脚本的文件夹，可以按我下面写的脚本快速启动（放在哪里都行，记着替换里面的token）。 12345678910111213141516171819if [ $# -lt 1 ]; then echo "Need cluster id"else path=~/Documents/Klei/DoNotStarveTogether/Cluster_$1 cd $path echo "your_token" &gt; cluster_token.txt //替换你的token cd ~/Library/Application\ Support/Steam/steamapps/common/Don\'t\ Starve\ Together/dontstarve_steam.app/Contents/MacOS sh start.sh $1 1 &gt; /dev/null &amp; echo "Start to run cluster" if [ $# -eq 2 -a $2 = 'Y' ] then sh start_cave.sh $1 &gt; /dev/null &amp; echo "Start to run cave" else echo "Didn't run cave" fifi 启动时候只需执行: sh DST_start.sh id (只生成地上)sh DST_start.sh id Y (同时生成地上和洞穴地图)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TopCoder SRM 691 Div1]]></title>
      <url>%2F2016%2F05%2F31%2FTopCoder-SRM-691-DIV-1%2F</url>
      <content type="text"><![CDATA[Easy: Sunnygraphs题意： 最初有n个点，每个点i与a[i]相连，另外又一个点P。在原先的n个点中，选一个点的集合S，对于任意点 $~i \in S$，进行以下两种操作： 删除i与a[i]的那条边 添加i与P的边 问有多少种点的集合S，使得0与1最后相连。 当图为有向图时，我们设： 0能到达的点集为A； 1能到达的点集为B； 分一下两种情况： 当0 1不连通（无向图）的时候， 自然从A至少选一个点，从B中至少选一个点。 当0 1连通（无向图）的时候。以下两种情况不符合要求： 存在一个点$x \in S$，满足$x \in (A - B) 且 S \bigcap B = \emptyset $。也就是说有个0能到而1却不能到达的点x在集合S中 ，且B能到达的点不在S中。 存在一个点$x \in S$，满足$x \in (B - A) 且 S \bigcap A = \emptyset $。 123456789101112131415161718192021222324252627282930const int N = 55;bool g[N][N], f[N][N];class Sunnygraphs&#123; public: long long count(vector &lt;int&gt; a) &#123; memset(g, 0, sizeof(g)); //有向图的连通性 memset(f, 0, sizeof(f)); //无向图的连通性 int n = a.size(); REP(i, n) g[i][i] = 1; REP(i, n) g[i][a[i]] = 1, f[i][a[i]] = f[a[i]][i] = 1; REP(k, n) REP(i, n) REP(j, n) g[i][j] |= (g[i][k] &amp; g[k][j]), f[i][j] |= (f[i][k] &amp; f[k][j]); int num0 = 0, num1 = 0, num2 = 0; REP(i, n) &#123; if(g[0][i] &amp;&amp; g[1][i]) ++num2; else if(g[0][i]) ++num0; else if(g[1][i]) ++num1; &#125; if(!f[0][1]) &#123; int tmp = n - num0 - num1; return ((1ll&lt;&lt;num0) - 1) * ((1ll&lt;&lt;num1) - 1) * (1ll &lt;&lt; tmp); &#125; int tmp = n - num0 - num1 - num2; LL ret = 1ll &lt;&lt; n; ret -= (((1ll &lt;&lt; num0) - 1 )* (1ll &lt;&lt; tmp)); ret -= (((1ll &lt;&lt; num1) - 1) * (1ll &lt;&lt; tmp)); return ret; &#125;&#125; Medium: Money Manager题意： 有n个项目，每做一个项目有经验值$a_i$以及基础奖金$b_i$。每做完一个项目，设历史积攒的经验值总和为exp，则做完这个项目能得到的奖金为$b_i$ * exp。另外，在第n/2个项目做完时，需要做一个项目，增加的经验值为X，但没有奖金。问怎么安排项目顺序使得最后能获得的奖金总和最大。 我们先考虑在没有X的情况下的方案。有一个性质： 当 $ a_i * b_j &gt; a_j * b_i $时， 则i必定在j之前。且这个式子是有传递性的。 也就是说，当不考虑X的时候，用排序算法就能解决。如果我们选好了前n个需要做的项目有哪些，则相对顺序是确定了的。当考虑X时，我们发现，影响因素仅仅是后n个项目的b之和。因此，枚举后n个项目的b之和（假设为f）。DP[l][r][sr], 表示前n个项目中以及选好了l个，后n个项目中已经选好了r个，且后n个项目的b之和为sr。 1234567891011121314151617181920212223242526272829303132333435363738394041bool cmp(const pii &amp;a, const pii &amp;b) &#123; return a.first * b.second &lt; a.second * b.first;&#125;class Moneymanager &#123; int dp[30][30][300]; int sum[55]; void setmax(int &amp;x, int y) &#123;x = max(x, y);&#125; public: int getbest(vector &lt;int&gt; a, vector &lt;int&gt; b, int X) &#123; int n = a.size(), m = n / 2; vector&lt;pii&gt; vec; REP(i, n) vec.pb(pii(a[i], b[i])); sort(vec.begin(), vec.end(), cmp); REP(i, n) &#123; sum[i] = vec[i].second; if(i) sum[i] += sum[i-1]; &#125; int ret = 0; FOR(f, 0, m * 10) &#123; memset(dp, -1, sizeof(dp)); dp[0][0][0] = f * X; FOR(l, 0, m) FOR(r, 0, m) &#123; if(l == m &amp;&amp; r == m) continue; int a = vec[l+r].first, b = vec[l+r].second; FOR(sr, 0, r * 10) &#123; int sl = sum[l + r] - sr - b; if(sl &lt; 0) continue; setmax(dp[l+1][r][sr], dp[l][r][sr] + a * (sl + b) + a * f); setmax(dp[l][r+1][sr+b], dp[l][r][sr] + a * (sr + b)); &#125; &#125; setmax(ret, dp[m][m][f]); &#125; return ret; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Codeforces #352 Div.1 C. Ultimate Weirdness of an Array]]></title>
      <url>%2F2016%2F05%2F18%2FCodeforces-352-Div-1-C-Ultimate-Weirdness-of-an-Array%2F</url>
      <content type="text"><![CDATA[对数论不是很在行…每次碰到gcd相关的题都是一脸懵逼…以后遇到这种题还是多总结一下吧。 最初以为是要分解质因子，然后用容斥乱搞一番，结果发现完全搞不出来.. 题意: $1 &lt;= n &lt;= 2 * 10^5$， 求 $$ \sum_{1 &lt;= l &lt;= r &lt;= n} max(gcd(a_i, a_j)) ~~~ {( i, j\notin [l, r])}$$ 参考思路： http://async.icpc-camp.org/d/418-codeforces-round-352e-ultimate-weirdness-of-an-array/4 我们维护一个集合S，集合中记录的是一些区间[l, r]。对于集合中任一一个区间[l, r]，使得$max(gcd(a_i, a_j)) &lt; d~ (i, j, \notin [l, r])$时，我们记录此时的区间个数A[d] = S.size()。 可得：$$ans = \sum d * num[d] ~~~(num[d] = A[d+1] - A[d])$$ 然后需要注意的地方便是如何维护集合S:最初S中有n * (n + 1) 个元素。从大到小枚举d，此时我们想从集合S删掉的元素为：当删掉[l, r]后, max_gcd为d的倍数。 我们将所有d的倍数列出来，进行排序。此时需要删掉的区间有： 删掉中间一部分，使得左右各至少有一个d的倍数。 删掉左边的一部分，最少保留最右边的两个d的倍数。 删掉右边的一部分，最少保留最左边的两个d的倍数。 需要删的部分确定了，接下来就是确定怎么删的问题。暴力会TLE，直接减也会导致重复。 对于最初所有的二元数组[l, r] (l &lt;= r)， 我们可以看作为一个以 x=y 为底边，x轴为腰的一个等腰直角三角形。每当删除一个区间[l, r]，对于任意区间[i, j] ($ l &lt;= i &lt;= j &lt;= r$) ，我们也应该删除。在图形上表示出来的意义就是，对于任意的i (l &lt;= i &lt;= r)，删掉 j &lt;= r 的部分。（自己动手画一下）。于是便可以用数据结构进行维护了。 我用的线段树： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;#define REP(i,n) for(int i=0;i&lt;(n);++i)#define FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)#define DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)#define MEM(arr, v) memset(arr, v, sizeof(arr))const int N = 2e5 + 10;#define L LL, l, MID#define R RR, MID + 1, r#define LL mask &lt;&lt; 1#define RR mask &lt;&lt; 1 | 1#define MID ((l + r) &gt;&gt; 1)int mn[N &lt;&lt; 2], lazy[N &lt;&lt; 2], mx[N &lt;&lt; 2];long long area[N &lt;&lt; 2];void push_down(int mask, int l, int r) &#123; if(lazy[mask] == -1) return; mn[LL] = mn[RR] = mx[LL] = mx[RR] = lazy[mask]; area[LL] = (long long)(MID - l + 1) * mn[LL]; area[RR] = (long long)(r - MID) * mn[RR]; lazy[LL] = lazy[RR] = lazy[mask]; lazy[mask] = -1;&#125;void push_up(int mask) &#123; mn[mask] = min(mn[LL], mn[RR]); mx[mask] = max(mx[LL], mx[RR]); area[mask] = area[LL] + area[RR];&#125;void update(int mask, int l, int r, int ll, int rr, int h) &#123; if(ll &gt; r || rr &lt; l || h &lt;= mn[mask]) return; if(l == r) &#123; mn[mask] = mx[mask] = area[mask] = max(mx[mask], h); return; &#125; if(ll &lt;= l &amp;&amp; rr &gt;= r &amp;&amp; h &gt;= mx[mask]) &#123; mn[mask] = lazy[mask] = mx[mask] = h; area[mask] = (long long)(r - l + 1) * h; &#125; else &#123; push_down(mask, l, r); update(L, ll, rr, h); update(R, ll, rr, h); push_up(mask); &#125;&#125;long long ans[N];int l[N], r[N], l2[N], r2[N];int main() &#123; int n, x; while(cin &gt;&gt; n) &#123; MEM(mn, 0), MEM(mx, 0), MEM(area, 0), MEM(lazy, -1), MEM(l, -1), MEM(r, -1), MEM(l2, -1), MEM(r2, -1); int m = 0; FOR(i, 1, n) &#123; scanf("%d", &amp;x); m = max(x, m); for(int j = 1; j * j &lt;= x; ++j) &#123; //其实对于每个d，只用维护最左和最右两个数就够了 if(x % j) continue; if(l[j] == -1) l[j] = i; else if(l2[j] == -1) l2[j] = i; r2[j] = r[j], r[j] = i; if(j * j == x) continue; if(l[x / j] == -1) l[x / j] = i; else if(l2[x / j] == -1) l2[x / j] = i; r2[x / j] = r[x / j], r[x / j] = i; &#125; &#125; FOR(i, 1, n) update(1, 1, n, i, i, i-1); // 最开始都是矩形，剪掉一部分成三角形的形状 DWN(i, m + 1, 1) &#123; if(l[i] != r[i]) &#123; update(1, 1, n, l[i]+1 , r[i]-1 , r[i] - 1); //删掉中间 update(1, 1, n, 1 , r2[i]- 1, r2[i] - 1);//删左边 update(1, 1, n, l2[i]+1, n , n);//删右边 &#125; ans[i] = (long long)n * n - area[1];//前面加不加n*n不影响，但是加上以后实际意义为剩余三角形的面积 &#125; long long ret = 0; FOR(i, 1, m) ret += (ans[i+1] - ans[i]) * i; cout &lt;&lt; ret &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Topcoder SRM 677 Div1]]></title>
      <url>%2F2016%2F04%2F06%2FSRM-677-DIV1%2F</url>
      <content type="text"><![CDATA[Easy: DoubleOrOneEasy给出a, b, A, B,有两种操作： a, b同时乘2 a, b同时加1 问最少经过多少次操作使得 a == A &amp;&amp; b == b首先明确一点，在什么情况下有解。 假如进行过x次乘法之后，a变为aa, b变为bb。令$ aa = a * 2^x + y, bb = b * 2^x + z $，则y == z。 也就是说，如果有解，则存在一个x，使得 $A - a * 2^x == B - b * 2 ^ x$ 一般来说这样的x是只有一个的(A == B &amp;&amp; a == b时特殊)。贪心找到最大的x，就是最后进行过乘法的次数。然后在此基础上找加法的个数。 还是令 $y = A - a * 2^x$首先贪心，最开始先进行$y / (1&lt;&lt;x)$次加法操作, 还剩下$z = y \% (1&lt;&lt;x) $需要补，再加上bitcount(z)就好了（自己想为什么）。 1234567891011121314151617181920int solve(int a, int b, int aa, int bb) &#123; int ret = -1, num = 0; while(a &lt;= aa &amp;&amp; b &lt;= bb) &#123; if(aa - a == bb - b) ret = max(ret, num); a &lt;&lt;= 1, b &lt;&lt;= 1; ++num; &#125; return ret;&#125;class DoubleOrOneEasy&#123; public: int minimalSteps(int a, int b, int aa, int bb) &#123; int num = solve(a, b, aa, bb); if(num == -1) return -1; int tmp = aa - (a &lt;&lt; num); return num + tmp / (1&lt;&lt;num) + __builtin_popcount(tmp % (1&lt;&lt;num)); &#125;&#125;; Medium: DiameterOfRandomTree给出一个棵树,每条边等概率长度为1或2，求树的直径。 用dp[root][d1][l1]表示根为root的子树，直径为d1，从根往下最长的链长度为l1的方案数。dp[son][d2][l2]表示子树的状态。状态转移公式: $$ dp[root][max(max(d1, d2), l1 + l2 + 1)][max(l1, l2 + 1)] += dp[root][d1][l1] * dp[son][d2][l2] $$ $$ dp[root][max(max(d1, d2), l1 + l2 + 2)][max(l1, l2 + 2)] += dp[root][d1][l1] * dp[son][d2][l2] $$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445VI head[55];LL dp[55][2][101][101], max_l[55], dia[55];//dp中加了一维作滚动数组void init() &#123; mem(dp), mem(max_l), mem(dia); REP(i, 50) head[i].clear();&#125;int dfs(int cur, int pre) &#123; int sta = 0; dp[cur][sta][0][0] = 1; for(int to: head[cur]) &#123; if(to == pre) continue; int to_sta = dfs(to, cur); sta ^= 1; mem(dp[cur][sta]); FOR(d1, 0, dia[cur]) FOR(l1, 0, max_l[cur]) FOR(d2, 0, dia[to]) FOR(l2, 0, max_l[to]) &#123; int d = max(max(d1, d2), l1 + l2 + 1), l = max(l1, l2 + 1); dp[cur][sta][d][l] += dp[cur][sta^1][d1][l1] * dp[to][to_sta][d2][l2]; d = max(max(d1, d2), l1 + l2 + 2), l = max(l1, l2 + 2); dp[cur][sta][d][l] += dp[cur][sta^1][d1][l1] * dp[to][to_sta][d2][l2]; &#125; dia[cur] = max(max(dia[cur], dia[to]), max_l[cur] + max_l[to] + 2); max_l[cur] = max(max_l[cur], max_l[to] + 2); &#125; return sta;&#125;class DiameterOfRandomTree&#123; public: double getExpectation(vector &lt;int&gt; a, vector &lt;int&gt; b)&#123; init(); REP(i, a.size()) &#123; head[a[i]].pb(b[i]); head[b[i]].pb(a[i]); &#125; int sta = dfs(0, -1); double ret = 0, div = (double)(1ll &lt;&lt; a.size()); FOR(i, 0, dia[0]) FOR(j, 0, max_l[0]) ret += (double) dp[0][sta][i][j] / div * i; return ret; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5657 CA Loves Math]]></title>
      <url>%2F2016%2F04%2F03%2FHDU-5657-CA-Loves-Math%2F</url>
      <content type="text"><![CDATA[传送门: http://acm.hdu.edu.cn/showproblem.php?pid=5657题意：求[1, $A^n_{(10)}$]中，长度小于等于n，且为k的倍数的数有多少。 此题…巨坑… 比赛时思路是对的，对k进行分类讨论..然并卵… 等A了才发现几个大坑: k的阀值在30000～60000之间才能A，高了低了都不行（想起了那些年计算几何中调精度的日子..） queue真心慢… n = 0 or n = 1时坑比较多，建议单独处理 前导0是不算的!!!。但是题目给的数据比较坑，刚好两位，如果算了前导0，刚好也对。（包括第一题中MOD值为1e8+7…我充满了对这个世界的怨念…） 所以说一直WA的可以按我上面的几点检查一下…我感觉我应该是把坑都踩完了…—————————————正文——————————————— 对k进行分类，假设阀值为N（参考上面第一点）。当k &gt;= N时，枚举k的倍数，再判断数字是否重复。当k &lt; N时：记dp[pos][j]：当用的数字集合为pos(状态压缩), 且mod k = j时的数目 转移方程：$$ dp[ pos| (1&lt;&lt;i) ] [ (j + A^x ) \% k] += dp[pos][j] $$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define REP(i,n) for(int i=0;i&lt;(n);++i)#define FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)#define DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)typedef long long LL;const int N = 50000;bool check(int A, LL x) &#123;//判断数字是否重复 int pos = 0; while(x) &#123; int tmp = x % A; if(pos &amp; (1&lt;&lt;tmp)) return 0; pos |= (1&lt;&lt;tmp); x /= A; &#125; return 1;&#125;int dp[1&lt;&lt;11][N], f[12];LL solve(int A, int n, int k) &#123; if(n == 0) return k == 1; if(n == 1) return A / k; n = min(n, A); LL NN = 1; REP(i, n) NN *= A; LL ret = 0; if(k &gt;= N) &#123; //k&gt;=N时枚举k的倍数 LL tmp = k; while(tmp &lt;= NN) &#123; if(check(A, tmp)) ++ret; tmp += k; &#125; return ret; &#125; f[0] = 1; FOR(i, 1, n) f[i] = (f[i-1] * A) % k; memset(dp, 0, sizeof(dp)); dp[0][0] = 1; REP(pos, 1&lt;&lt;A) &#123; int num = __builtin_popcount(pos); if(num &gt;= n) continue; REP(i, A) if((pos &amp; (1&lt;&lt;i)) == 0) REP(j, k) if(dp[pos][j]) &#123; int x = pos | (1&lt;&lt;i), y = (j + i * f[num]) % k; dp[x][y] += dp[pos][j]; if(i != 0 &amp;&amp; y == 0) ret += dp[pos][j]; &#125; &#125; if(check(A, NN) &amp;&amp; (NN % k == 0)) ++ret; //特判A^n return ret;&#125;int main()&#123; int casnum, A, n, k; cin &gt;&gt; casnum; while(casnum--) &#123; cin &gt;&gt; A &gt;&gt; n &gt;&gt; k; cout &lt;&lt; solve(A, n, k) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Topcoder SRM 678 Div1]]></title>
      <url>%2F2016%2F04%2F01%2FSRM-678-DIV1%2F</url>
      <content type="text"><![CDATA[Easy: A New Hope题意：假设一个星期有n天，一个人有n件不同的衣服（标号1~n），每件衣服每周穿一件。由此有N！种穿的方式。但是洗一件衣服需要D天（第x天洗了，x+D天才能穿）。现已知第一周和最后一周穿衣服的顺序，问中间最少隔了几个星期。 用数学方法表示，每周穿衣服的顺序可标示为长度为n的排序。如{1, 2, 3, 4}。假设D＝3，则4号衣服下周最早可以在周三穿，提前了一天(4 - 3 ＝ 1)。 由此便清楚了，本质上就是第一周的排序$P_1$，移动某些数字后，使其状态等于最后一周的状态$P_m$。而每个数字一周最多可以向前移动n-D位。 枚举每个数字，求移动周数的最大值。 1234567891011121314151617class ANewHope&#123; public: int count(vector &lt;int&gt; firstWeek, vector &lt;int&gt; lastWeek, int D) &#123; int n = firstWeek.size(); D = n - D; map&lt;int, int&gt;first_p, last_p; REP(i, n) first_p[ firstWeek[i] ] = i, last_p[ lastWeek[i] ] = i; int ret = 0; FOR(i, 1, n) &#123; if(last_p[i] &lt; first_p[i]) ret = max(ret, (first_p[i] - last_p[i] + D - 1) / D);//上取整 &#125; return ret + 1; //加上第一周 &#125;&#125;; Medium: The Empire Strikes Back题意：有n颗行星，坐标$(x_i, y_i)$。有m发子弹，当子弹威力为w时，对准一颗行星，可以消灭(0, 0)~$(x_i, y_i)$矩形内的行星。问子弹威力最小应为多少。 这种题上来不用多说先二分枚举子弹威力mid… 行星坐标$(x_i, y_i)$以及矩形右上角的坐标$(x_i+mid, y_i+mid)$分开存。都对y从大到小进行排序。贪心。保存此时能毁灭的x的最大值max_x，随着行星坐标$y_i$的减小，求矩形坐标中$y_j+mid &gt; y_i$中最大的$x_j+mid$，并更新为max_x 123456789101112131415161718192021222324252627282930313233343536373839404142const int MOD = 1e9 + 7;bool solve(vector&lt;pii&gt;&amp;vec, int n, int m, int mid) &#123; vector&lt;pii&gt;f(vec); for(pii &amp;tmp: f) tmp.first += mid, tmp.second += mid; int max_x = -1, id = n - 1; int ret = 0; DWN(i, n-1, 0) &#123; if(max_x &lt; vec[i].second) &#123; ++ret; while(id &gt;= 0 &amp;&amp; f[id].first &gt;= vec[i].first) &#123; max_x = max(max_x, f[id].second); id --; &#125; &#125; &#125; return ret &lt;= m;&#125;class TheEmpireStrikesBack&#123; public: int find(int AX, int BX, int CX, int AY, int BY, int CY, int n, int m) &#123; vector&lt;pii&gt;vec; LL x = AX, y = AY; vec.pb(pii(y, x)); FOR(i, 1, n-1) &#123; x = (x * BX + CX) % MOD; y = (y * BY + CY) % MOD; vec.pb(pii(y, x)); &#125; sort(vec.begin(), vec.end()); int l = 0, r = MOD, ans; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(solve(vec, n, m, mid)) r = mid - 1, ans = mid; else l = mid + 1; &#125; return ans; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS Sublime Text 3 C/C++ 配置]]></title>
      <url>%2F2016%2F03%2F30%2FMac-OS-Sublime-Text-3-C-C-%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[安装sublime text 3 插件1.安装 Package Control组件： 按 control+` (键盘上1左边的按钮)调出console控制台; 粘贴以下代码到底部命令行并回车: 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 2.用Package Control安装插件的方法 Preference -&gt; Package Control打开控制栏，输入install Package回车。 3.常用插件 SublimeCodeIntel: 代码提示及自动补全 SideBar Enhancements: 改进侧边栏 SideBar Folders: 增加了侧边栏对于文件夹的支持 暂时没用到这么多..以后慢慢补吧… 内置输入数据本以为上面的弄完就万事大吉，但在编译运行的时候发现一个问题：运行时无法在控制台输入数据。愁。 解决办法：Tools -&gt; Build System -&gt; New Build System 新建编译系统。在新打开的窗口中替换为以下代码 1234567891011121314&#123; "cmd": ["bash", "-c", "g++ '$&#123;file&#125;' -o '$&#123;file_path&#125;/$&#123;file_base_name&#125;' &amp;&amp; osascript -e 'tell application \"Terminal\" to activate do script \"clear&amp;&amp;$&#123;file_path&#125;/$&#123;file_base_name&#125; &amp;&amp; read -p \\\"Press Enter to exit.\\\"&amp;&amp;exit\"'"], "file_regex": "^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$", "working_dir": "$&#123;file_path&#125;", "selector": "source.c, source.c++", "variants": [ &#123; "name": "Run", "cmd": ["bash", "-c", "g++ '$&#123;file&#125;' -o '$&#123;file_path&#125;/$&#123;file_base_name&#125;' &amp;&amp; '$&#123;file_path&#125;/$&#123;file_base_name&#125;'"] &#125; ]&#125; Command + s 保存，命名为MyC++。在Tools -&gt; Build System选中MyC++。Command + Shift + B编译，选MyC++（不加Run的那个）。 搞定~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5649 DZY Loves Sorting]]></title>
      <url>%2F2016%2F03%2F26%2FHDU-5649-DZY-Loves-Sorting%2F</url>
      <content type="text"><![CDATA[祭奠我因为一个坑被白白浪费的一天… 基础数据结构。线段树。区间更新，区间查询。 传送门：http://acm.hdu.edu.cn/showproblem.php?pid=5649 此题的难点在于，每次排序的时候，每个数在排序之后的位置不能一个一个来处理，这样复杂度肯定是不够的。 So, 我们枚举一个答案mid，这样对于所有的数，只用区分它是比mid大，还是比mid小，由此进行批量处理。 枚举mid。 每次操作开始，把初始位置上小于等于mid的位置标为1，剩下的标为0. 对于每次排序。（假如是升序）先进行区间查询[l, r]区间内1的个数num。 把[l, l+num-1]全更新为1，剩下的更新为0 查看第k位上是否为1。 可以肯定的一点是，经过m次排序之后，最后排序的结果不以我们枚举的mid而发生变化。 当我们第一次枚举mid = n的时候，在所有排序结束后，必然是所有位置上的数都为1.当mid在逐渐变小的过程中，在排序结束后，某些位置上的数会由1变为0。当第k位上恰好最后为1的时候，此时的mid值即为需要的答案。 当然，直接枚举也是会超时的，加个二分就好了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define pb push_back#define mp make_pair#define REP(i,n) for(int i=0;i&lt;(n);++i)#define FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)#define DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)typedef pair&lt;int,int&gt; pii;#define L pos&lt;&lt;1#define R pos&lt;&lt;1|1#define MID ((l+r)&gt;&gt;1)#define LL L, l, MID#define RR R, MID+1, rconst int N = 1e5 + 100;int node[N&lt;&lt;2], lazy[N&lt;&lt;2], v[N];vector&lt;pair&lt;pii, int&gt; &gt; vec;void build(int pos, int l, int r, int value) &#123; lazy[pos] = -1; if(l==r) node[pos] = (v[l] &lt;= value); else &#123; build(LL, value); build(RR, value); node[pos] = node[L] + node[R]; &#125;&#125;void push_down(int pos, int l, int r) &#123; if(l == r || lazy[pos] == -1) return; lazy[L] = lazy[R] = lazy[pos]; node[L] = lazy[pos] * (MID - l + 1); node[R] = lazy[pos] * (r - MID); lazy[pos] = -1;&#125;void push_up(int pos, int l, int r) &#123;node[pos] = node[L] + node[R];&#125;int query(int pos, int l, int r, int ll, int rr) &#123; if(ll &lt;= l &amp;&amp; r &lt;= rr) return node[pos]; push_down(pos, l, r); int ret = 0; if(ll &lt;= MID) ret += query(LL, ll, rr); if(rr &gt; MID) ret += query(RR, ll, rr); push_up(pos, l, r); return ret;&#125;void update(int pos, int l, int r, int ll, int rr, int value) &#123; if(ll &lt;= l &amp;&amp; r &lt;= rr) node[pos] = (r - l + 1) * value, lazy[pos] = value; else &#123; push_down(pos, l, r); if(ll &lt;= MID) update(LL, ll, rr, value); if(rr &gt; MID) update(RR, ll, rr, value); push_up(pos, l, r); &#125;&#125;int solve(int mid, int n, int m, int k) &#123; build(1, 1, n, mid); REP(i, vec.size()) &#123; int l = vec[i].first.first, r = vec[i].first.second, flag = vec[i].second; int num = query(1, 1, n, l, r); if(num == 0 || num == r - l + 1) continue; if(!flag) &#123; update(1, 1, n, l, l+num-1, 1); update(1, 1, n, l+num, r, 0); &#125; else &#123; update(1, 1, n, r-num+1, r, 1); update(1, 1, n, l, r-num, 0); &#125; &#125; return query(1, 1, n, k, k) == 1;&#125;int main()&#123; int casnum, n, m, k, x, y, z; cin &gt;&gt; casnum; while(casnum--) &#123; vec.clear(); cin &gt;&gt; n &gt;&gt; m; FOR(i, 1, n) scanf("%d", &amp;v[i]); REP(i, m) &#123; scanf("%d%d%d", &amp;z, &amp;x, &amp;y); vec.pb(make_pair(pii(x, y), z)); &#125; cin &gt;&gt; k; int l = 1, r = n, ans; while(l &lt;= r) &#123; if(solve(MID, n, m, k)) ans = MID, r = MID - 1; else l = MID + 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5648 DZY Loves Math]]></title>
      <url>%2F2016%2F03%2F25%2FHDU-5648-DZY-Loves-Math%2F</url>
      <content type="text"><![CDATA[DZY Loves 系列…DZY大神你怎么什么都喜欢… 传送门: http://acm.hdu.edu.cn/showproblem.php?pid=5648 题意: 求$\sum_{i=1} ^ n \sum_{j=1} ^m gcd(i ~ AND ~j, i~ OR~ j) $, 1 &lt;= n, m &lt;= 15000 用三进制表示状态值, 每一位上的值: 0: 表示均为0 1: 表示一个为0, 一个为1 2: 表示两个都为1 记 $ l = \log_2 {max(n, m)} $，则枚举量为$3^l$ 每枚举一个状态值, 接下来便是求此状态的方案数目num, ans += num * gcd 。 记AND值为x,OR 值为 y,令z = x ^ y . 假设在每种方案下，i = a | x, j = b | x，很容易看出 a | b = a + b = z。代入以下不等式： $ a + x &lt;= n $$ b + x &lt;= m $ 化简以后得到 $ z-m+x &lt;= a &lt;= n-x $ 就是求 取z中二进制位为1的某些位组成a，且使a满足上面的不等式 的a的取值范围。 熟悉数位DP的朋友很容易就看出来接下的步骤了。运用数位DP求num值就好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define REP(i,n) for(int i=0;i&lt;(n);++i)#define FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)#define DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)int dfs(int pos, int l, int cur_value) &#123; if(pos &lt;= cur_value) return 1 &lt;&lt; __builtin_popcount(pos); int ret = 0; if((1&lt;&lt;l) &amp; pos) &#123; if((1&lt;&lt;l) &lt;= cur_value) ret += dfs(pos^(1&lt;&lt;l), l-1, cur_value - (1&lt;&lt;l)); ret += dfs(pos^(1&lt;&lt;l), l-1, cur_value); &#125; else &#123; ret += dfs(pos, l-1, cur_value); &#125; return ret;&#125;int get(int pos, int max_value) &#123; //数位DP,求在pos中选部分二进制为1的位组成a,且a&lt;=max_value的方案数 if(max_value &lt; 0) return 0; int len = 0; while((1&lt;&lt;len) &lt;= max_value) len++; pos = pos &amp; ((1&lt;&lt;len) - 1);//把高位舍掉,反正也没用 int ret = dfs(pos, len-1, max_value); return ret;&#125;int main()&#123; int casnum, n, m; cin &gt;&gt; casnum; while(casnum--) &#123; cin &gt;&gt; n &gt;&gt; m; int len = 0; while((1&lt;&lt;len) &lt;= n || (1&lt;&lt;len) &lt;= m) len++; int s = 1; REP(i, len) s *= 3; long long ans = 0; REP(i, s) &#123; // 三进制枚举状态值 int tmp = i, x = 0, y = 0; // x为and值, y为or值 REP(j, len) &#123; if(tmp % 3 == 1) y |= (1&lt;&lt;j); else if(tmp % 3 == 2) x |= (1&lt;&lt;j), y |= (1&lt;&lt;j); tmp /= 3; &#125; if(y == 0) continue; if(x &gt; n || x &gt; m) continue; int z = x ^ y; int value = get(z, n-x) - get(z, z-m+x-1); if(x == 0) &#123; //这里要注意.当x==0时, a 和 b 都不能为0 if(z &lt;= n) --value; if(z &lt;= m) --value; &#125; ans += __gcd(x, y) * max(value, 0); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5296 Annoying problem]]></title>
      <url>%2F2015%2F12%2F16%2FHDU-5296-Annoying-problem%2F</url>
      <content type="text"><![CDATA[最初以为是DP，结果发现并不是。= = 题意：在一棵树上，边有权重。有两种操作： 如果v不在集合中，那么将点v放入到集合 如果v在集合中，那么将v移出集合求每次操作后，选择一些边将集合中的点连在一起，问边权和为多少。 先初始化dfs序，以及跟节点到点x的距离dis。每当我们要插入一个点x，找到在集合中且dfs序比x第一个大的点u，以及第一个小的点v。则新增的边的边权为$$dis[x]−dis[lca(x,u)]−dis[lca(x,v)]+dis[lca(u,v)]$$ 如果没有dfs序比v大或者比v小的点，则u v分别取集合中dfs序最大和最小的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;#define pb push_back#define REP(i,n) for(int i=0;i&lt;(n);++i)#define FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)#define DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)typedef pair&lt;int,int&gt; pii;const int N = 1e5 + 10;vector&lt;pii&gt; head[N];bool visit[N];int dfn[N], deep[N], dis[N], fa[N][20];void dfs(int cur, int pre, int &amp;t) &#123; //初始化dfs序，以及fa(在线求lca) dfn[cur] = ++t; deep[cur] = deep[pre] + 1; fa[cur][0] = pre; FOR(i, 1, 19) fa[cur][i] = fa[ fa[cur][i-1] ][i-1]; REP(i, head[cur].size()) &#123; int to = head[cur][i].first, c = head[cur][i].second; if(to != pre) &#123; dis[to] = dis[cur] + c; dfs(to, cur, t); &#125; &#125;&#125;int lca(int u, int v) &#123; if(deep[u] &lt; deep[v]) swap(u, v); int tmp = deep[u] - deep[v]; REP(i, 20) if(tmp &amp; (1 &lt;&lt; i)) u = fa[u][i]; if(u == v) return u; DWN(i, 19, 0) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i]; return fa[u][0];&#125;map&lt;int, int&gt;M;void add(int x, int &amp;ans) &#123; visit[x] = 1; if(M.size() == 0) &#123; M[dfn[x]] = x; return; &#125; map&lt;int, int&gt;::iterator it1, it2; it1 = M.lower_bound(dfn[x]), it2 = it1; if(it1 == M.begin() || it1 == M.end()) it1 = M.begin(), it2 = M.end(); it2--; int u = it1-&gt;second, v = it2-&gt;second; ans += dis[x] - dis[lca(u, x)] - dis[lca(v, x)] + dis[lca(u, v)]; M[dfn[x]] = x;&#125;void del(int x, int &amp;ans) &#123; visit[x] = 0; M.erase(dfn[x]); if(M.size() == 0) return; map&lt;int, int&gt;::iterator it1, it2; it1 = M.lower_bound(dfn[x]), it2 = it1; if(it1 == M.begin() || it1 == M.end()) it1 = M.begin(), it2 = M.end(); it2--; int u = it1-&gt;second, v = it2-&gt;second; ans -= dis[x] - dis[lca(u, x)] - dis[lca(v, x)] + dis[lca(u, v)];&#125;int main()&#123; int n, m, casnum, u, v, c, t, casid = 0; cin &gt;&gt; casnum; while(casnum--) &#123; memset(visit, 0, sizeof(visit)); cin &gt;&gt; n &gt;&gt; m; FOR(i, 1, n) head[i].clear(); REP(i, n-1) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;c); head[u].pb(pii(v, c)); head[v].pb(pii(u, c)); &#125; t = 0; dfs(1, 0, t); int ans = 0; printf("Case #%d:\n", ++casid); M.clear(); while(m--) &#123; scanf("%d%d", &amp;u, &amp;v); if(u == 1 &amp;&amp; !visit[v]) add(v, ans); if(u == 2 &amp;&amp; visit[v]) del(v, ans); printf("%d\n", ans); &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5293 Tree chain problem]]></title>
      <url>%2F2015%2F11%2F23%2FHDU-5293-Tree-chain-problem%2F</url>
      <content type="text"><![CDATA[题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=5293 题目大意：有个N的点的树。其中树上有M条已知的链，每条链有一个权值。从中选出任意个不相交的链使得链的权值和最大。 树形DP。我们用dp[i]表示以i点为根的子树的最优解。用sum[i]表示以i点为根的子树中不选i点的最优解，即$sum[i]=\sum dp[k] $ (k为i的儿子节点) 其中dp[i]不一定是一定要选取i点,因此，dp[i]也有可能等于sum[i]。 我们假设出一种情况，一颗以root为根的树，有一条链link: root -&gt; a -&gt; b ， 权值为x。在知道除了root之外其他所有点的dp值及sum值已知的情况下，求出选取这条链情况下的root的dp值。 首先，sum[root]是可以求的。那么 $$ dp[root] = sum[root] - dp[a] + sum[a] - dp[b]+ sum[b] + x $$ (联系sum的定义理解这个式子) 理解以后这道题就迎刃而解了，无非就是求一次lca，然后对于如何快速在树上求一条链的sum和以及dp和做一次优化而已，用时间戳或者树链剖分的方法都好。 我这里用的时间戳加树状数组来进行优化的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define pb push_back#define REP(i,n) for(int i=0;i&lt;(n);++i)#define FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)#define CLR(arr) memset(arr, 0, sizeof(arr))typedef vector&lt;int&gt; VI;typedef pair&lt;int,int&gt; pii;const int N = 2e5 + 100;int node[2][N];inline int lowbit(int x) &#123;return x&amp;-x;&#125;void update(int x, int value, int n, int flag) &#123; while(x &lt;= n) &#123; node[flag][x] += value; x += lowbit(x); &#125;&#125;int query(int x, int flag) &#123; int ret = 0; while(x) &#123; ret += node[flag][x]; x -= lowbit(x); &#125; return ret;&#125;VI head[N], vec[N];vector&lt;pii&gt; lca[N], qhead[N];int fa[N];int find(int x) &#123; if(x == fa[x]) return x; else return fa[x] = find(fa[x]);&#125;bool visit[N];void LCA(int cur, int pre) &#123; visit[cur] = 1; REP(i, head[cur].size()) &#123; int to = head[cur][i]; if(visit[to]) continue; LCA(to, cur); &#125; REP(i, qhead[cur].size()) &#123; int to = qhead[cur][i].first, x = qhead[cur][i].second; if(visit[to]) &#123; int tmp = find(to); lca[tmp].pb(pii(cur, to)); vec[tmp].pb(x); &#125; &#125; fa[cur] = pre;&#125;int l[N], r[N];int dp[N], sum[N];int t;void dfs(int cur, int n) &#123; visit[cur] = 1; l[cur] = ++t; REP(i, head[cur].size()) &#123; int to = head[cur][i]; if(visit[to]) continue; dfs(to, n); sum[cur] += dp[to]; &#125; REP(i, lca[cur].size()) &#123; int u = lca[cur][i].first, v = lca[cur][i].second, x = vec[cur][i]; int tmp = sum[cur] + query(l[u], 0) + query(l[v], 0) - query(l[u], 1) - query(l[v], 1) + x; dp[cur] = max(tmp, dp[cur]); &#125; r[cur] = ++t; dp[cur] = max(dp[cur], sum[cur]); update(l[cur], sum[cur], n*2, 0); update(r[cur], -sum[cur], n*2, 0); update(l[cur], dp[cur], n*2, 1); update(r[cur], -dp[cur], n*2, 1);&#125;int main()&#123; int casnum, n, m, u, v, x; cin &gt;&gt; casnum; while(casnum--) &#123; cin &gt;&gt; n &gt;&gt; m; CLR(node); FOR(i, 1, n) head[i].clear(), qhead[i].clear(), lca[i].clear(), vec[i].clear(); FOR(i, 1, n) fa[i] = i; REP(i, n-1) &#123; scanf("%d%d", &amp;u, &amp;v); head[u].pb(v); head[v].pb(u); &#125; REP(i, m) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;x); qhead[u].pb(pii(v, x)); qhead[v].pb(pii(u, x)); &#125; memset(sum, 0, sizeof(sum)); memset(dp, 0, sizeof(dp)); t = 0; CLR(visit); LCA(1, 1); CLR(visit); dfs(1, n); cout &lt;&lt; dp[1] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5291 Candy Distribution]]></title>
      <url>%2F2015%2F11%2F22%2FHDU-5291-Candy-Distribution%2F</url>
      <content type="text"><![CDATA[题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5291 题目大概意思就是有K种物品，第i种物品有ai个，要把全部的物品分成两堆，每个物品可以用也可以不用， 问最后两边物品数量一样多的方案数。 最直接的思路，定义dp[i][j]表示第i堆分完后第一个人比第二个人多j个糖果的方案数。枚举分第i堆糖果时第一个人比第二个人多分x个，则 $$dp[i][j+x] += dp[i-1][j] * ( (a[i] - x) / 2 + 1 ) $$ 直接这么做的复杂度为$O(n^4)$，会超时。我们进行一次优化。 随着x的变化，$(a[i] - x) / 2 + 1$这个值根据奇偶性划分可分成两个等差数列。根据这个来进行处理，最后复杂度为O(n^3)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define pb push_back#define mp make_pair#define REP(i,n) for(int i=0;i&lt;(n);++i)#define FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)#define DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)typedef vector&lt;int&gt; VI;typedef vector&lt;string&gt; VS;typedef vector&lt;double&gt; VD;typedef long long LL;typedef pair&lt;int,int&gt; pii;const int N = 40010;LL dp[2][N];LL sum[N][2];const LL MOD = 1e9 + 7;inline LL get(int id, int flag, int mid) &#123; if(id &lt; 0) return 0; return sum[min(id, mid&lt;&lt;1)][flag];&#125;int main()&#123; int casnum, n; cin &gt;&gt; casnum; while(casnum--) &#123; memset(dp, 0, sizeof(dp)); memset(sum, 0, sizeof(sum)); cin &gt;&gt; n; int mid = n * 100; int cur = 0, pre = 1; dp[cur][mid] = 1; while(n--) &#123; LL x; cin &gt;&gt; x; cur ^= 1, pre ^= 1; memset(dp[cur], 0, sizeof(dp[cur])); sum[0][0] = dp[pre][0]; sum[0][1] = 0; FOR(i, 1, mid &lt;&lt; 1) &#123; bool flag = i &amp; 1; sum[i][flag] = (sum[i-1][flag] + dp[pre][i]) % MOD; sum[i][flag^1] = sum[i-1][flag^1]; &#125; LL res = 0; FOR(i, 0, x) res = (res + (x - i + 2) / 2 * dp[pre][i]) % MOD; if(x &amp; 1) &#123; FOR(i, 0, mid &lt;&lt; 1) &#123; bool flag = i &amp; 1; dp[cur][i] = res; res = (res + get(i + x + 1, flag, mid) - get(i, flag, mid)) % MOD; res = (res - (get(i, flag^1, mid) - get(i - x - 1, flag^1, mid))) % MOD; res = (res + MOD) % MOD; &#125; &#125; else &#123; FOR(i, 0 , mid &lt;&lt; 1) &#123; bool flag = i &amp; 1; dp[cur][i] = res; res = (res + get(i + x + 1, flag^1, mid) - get(i, flag^1, mid)) % MOD; res = (res - (get(i, flag, mid) - get(i - x - 1, flag, mid))) % MOD; res = (res + MOD) % MOD; &#125; &#125; &#125; cout &lt;&lt; dp[cur][mid] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5290 Bombing plan]]></title>
      <url>%2F2015%2F11%2F19%2FHDU-5290-Bombing-plan%2F</url>
      <content type="text"><![CDATA[题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=5290 官方题解已经说的很详细了。我也引用一下官方题解吧（有修改，加重部分）。 DP,定义两个数组$F[I][J]$,$G[I][J]$。 $F[I][J]$表示以第i个点为根的子树上的点被全部破坏掉，并且还能向上破坏掉不少于j个距离，满足这样条件需要选取的最小点数； $G[I][J]$表示以第i个点为根的子树上的点被未被全部破坏，且未被破坏的点中距离i最远的点距离为不超过j，满足这样条件需要选取的最小点数。 那么可以写出dp方程:$$G[I][J]=min(G[L][0],G[L][1],…,G[L][J-1]) $$L 代表所有儿子。 $$F[I][J] = F[K][J+1]+G[L][J]$$$$F[I][J] = min(F[I][j], F[I][J+1])$$式子中加号左边的意思是i节点必须存在一个儿子K，选取F[K][J+1]这个值。加号右边的式子表示除K以外其他儿子L的取值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define pb push_back#define mp make_pair#define REP(i,n) for(int i=0;i&lt;(n);++i)#define FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)#define DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)typedef vector&lt;int&gt; VI;typedef long long LL;const int N = 1e5 + 100;int dp[N][111], f[N][111];int w[N];VI head[N];void dfs(int cur, int pre) &#123; FOR(i, 0, 101) dp[cur][i] = 0, f[cur][i] = (i&lt;=w[cur]?1:1e6); //分别初始化取和不取时候的初始值。后面就没必要分步讨论了。 for(int to: head[cur]) &#123; if(to == pre) continue; dfs(to, cur); DWN(i, 100, 1) &#123; f[cur][i] = min(f[cur][i] + dp[to][i-1], dp[cur][i] + f[to][i+1]); f[cur][i] = min(f[cur][i], f[cur][i+1]); &#125; f[cur][0] = min(f[cur][0] + f[to][0], dp[cur][0] + f[to][1]); f[cur][0] = min(f[cur][0], f[cur][1]); dp[cur][0] = min(f[cur][0], dp[cur][0] + f[to][0]); FOR(i, 1, 100) &#123; dp[cur][i] = min(dp[cur][i-1], dp[cur][i] + dp[to][i-1]); &#125; &#125;&#125;int main() &#123; //freopen("in", "r", stdin); int n; while(cin &gt;&gt; n) &#123; FOR(i, 1, n) head[i].clear(); FOR(i, 1, n) scanf("%d", &amp;w[i]); REP(i, n-1) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); head[x].pb(y); head[y].pb(x); &#125; if(n == 1) &#123; puts("1"); continue; &#125; else &#123; dfs(1, 0); cout &lt;&lt; f[1][0] &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习笔记---线性回归(Linear Regression)]]></title>
      <url>%2F2015%2F07%2F28%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-Linear-Regression%2F</url>
      <content type="text"><![CDATA[作为机器学习的第一课，深刻理解线性回归将非常有助于我们学习后面的课程。 在上篇文章中我们将机器学习分为监督学习和非监督学习，线性回归就属于监督学习算法的一种。 依然拿上一章讲的房价预测作为我们学习线性回归的例子。我们说过，影响房价的因素可能有很多种，如：房屋大小、周围均价、使用年限等等。我们将这么一种因素称之为特征（Feature）。对于每一组数据的每个特征值我们分别记为$x_1,x_2,x_3$…$x_n$，n为特征数。 则我们建立一个数学模型，也就是假说（Hypothesis）为： $$h(x) = \sum_{i=0}^n \theta_ix_i = \theta^Tx$$ 这里的$\theta$即为假说的参数，我们赋予它一个初始值，然后再在机器学习的过程中不断调整。（所以说机器学习的过程其实也就是个调参的过程） 至于有n个特征，i为什么从0开始，我们后面再讲。 1.1 单变量线性回归(Linear Regression with One Variable)最开始，我们假设影响房价的因素就一个：房屋面积。 Size in feet$^2$(x) Price in 1000’s(y) 852 178 1534 315 1416 232 2104 460 则对于一组参数$\theta$,我们Hypothesis定义为： $$h_\theta(x) = \theta_0 + \theta_1x_1$$ $\theta_0$是我们加的一个辅助变量，没有实际意义。为了规范，我们令$x_0 = 1$，则： $$ h_\theta(x) = \theta_0x_0 + \theta_1x_1 = \sum_{i=0}^n\theta_ix_i = \theta^Tx $$ 1.2 成本函数(CostFunction)如何衡量这一组参数的好坏呢？计算它预测结果的误差大小就好了。在课程中，我们用$J(\theta)$来表示一组$\theta$的Cost。 $$ J(\theta) = \frac{1}{2m} \sum_{i=0}^{m} Cost(x^{(i)}, y^{(i)}) = \frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)}) - y^{(i)})^2 $$ 有了成本函数，也就知道如何衡量$(\theta_0,\theta_1)$的好坏。剩下的只用调整$\theta$使得$J(\theta)$最小就好了。 1.3 梯度下降(Gradient descent)如何最小化 $J(\theta)$？ 我们首先来直观地感受一下对于不同的$(\theta_0,\theta_1)$，$J(\theta)$的大小是怎么变化的。 如果我们最初设定的$\theta$使得$J(\theta)$恰好在山谷的位置，则皆大欢喜，此时的$J(\theta)$就是最小值，是最优解。 如果不幸选在山峰的位置，那么我们就要对$\theta$一点一点进行修改，使得$J(\theta)$一步一步走向山谷。这种一步一步修改$\theta$使得$J(\theta)$逐步走下山的过程我们称之为梯度下降，下降$J(\theta)$的值。 就像下图： 怎么下降？ 想要下降，首先得确定下降的方向。然后确定下降的幅度。 从数学上讲，假如我们确定了下降的幅度$\lambda$，则对于每个$\theta$，最佳的下降值为： $$ \theta_j := \theta_j - \lambda \frac{\delta J(\theta)}{\delta \theta_j} $$ $$ \frac{\delta J(\theta)} {\delta \theta_j} = \frac{1}{m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} $$ 所以展开就是： $$ \theta_j := \theta_j - \lambda \frac{1}{m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} $$ 就这样，一步一步更新$\theta$，使得$J(\theta)$一步一步变小。到什么时候停止? 我们比较更新前后的$J(\theta)$, 当更新后的$J(\theta)$比较小时，肯定是可以更新的。但是当更新后的$J(\theta)$比较大的时候，也不代表不能更新。我们知道，在我们更新$\theta$的时候，有两个因素，一个是幅度（$\lambda$），一个是方向。如果更新后的$J(\theta)$比较大，也有可能是更新的幅度比较大，一步迈过了谷底。这时候，我们需要减小$\lambda$来试试。 NOTICE1.更新$\theta$的时候是所有$\theta$一起更新的。虽然对于每个$\theta$的导数值是一个一个计算的，但是更新的时候是最后一起更新。如果是计算一个导数值更新一个$\theta$，我们会发现，由于我们先更新了$\theta_1$，再计算$\frac{\delta J(\theta)} {\theta_2}$的值就和预期的不符了。 2.对于不同的初始$\theta$，我们最终走到的谷底的位置也可能不同。也就是说，我们最终计算的最小值可能只是局部最小值，而不是全局最小值。 1.4学习算法当我们有了任意一个初始的$\theta$，有了梯度下降算法。接下来就是用梯度下降算法不断递归更新$\theta$就好了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习笔记—机器学习简介]]></title>
      <url>%2F2015%2F07%2F01%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[一直以来都想学习机器学习，但是苦于找不到好的入门书籍或者教学视频（Andrew NG的斯坦福公开课没有练习），直到发现了这个: https://www.coursera.org/learn/machine-learning/home/welcome 虽然也是Andrew NG老师的，不过是在Coursera上的，相对于课堂上的录制视频，这个用PPT来讲更直观，视频中间会有问答检测关键知识点是否理解正确，强制性要求的课后作业虽然不难，但确实能加深理解。比起只看书或者只看公开课，优点不用多说。 由于本人也是初学者，所以各位客官在看得时候务必以教学视频和自己的理解为主，若发现有问题的地方欢迎指正共同学习。 =========================分隔符============================= Machine Learning Week1 首先，从什么是机器学习开始说起。这里我们要引用一下台大林轩田老师《机器学习基石》的一幅图： $X$：训练数据的输入部分 $y$：训练数据的输出部分 $D$：训练数据集，表现为$（X_i, Y_i）$的形式 $H$：假说Hypothesis，表示对问题分析后得到的数学模型 $A$：学习方法 在机器学习中，对于一类问题，我们先加以分析，得到对于一组输入应该怎样处理的数学模型$H$，数学模型中有各种各样的参数$\theta$。此时，我们知道应该有哪些参数，但是不知道参数具体值为多少，于是借助学习方法$A$以及训练数据$D$，我们不断修改参数，使得对于以后的预测数据，能得到一个相对符合实际的结果。因此，机器学习就是一个提出假说$H$，并用学习方法$A$不断优化$\theta$的过程。 在课程中，Andrew NG将机器学习分为两种： 监督性学习(Supervised Learning) 非监督性学习(Unsupervised Learning)，也称聚类算法 而这两种分类的主要依据是，当我们在训练学习机器的时候，每组数据是否有标准答案。这样说可能不严谨，我还是拿例子来说。 在常规的训练一个机器学习的算法过程中，我们大多有一些训练数据，在不断喂(feed)学习机器的过程中，学习机器不断调整自己内部的各项参数，使得当机器学习训练完毕，我们拿实际需要预测的数据喂给机器学习算法，能得到一个比较符合实际情况的值。 然而，这种预期的值确是有区别的。 监督性学习：我们想预测房价，我们需要把房屋的大小、地理位置、规格等数据喂给学习机器，我们能得到一个预测的价格的值。在训练这种学习机器的过程中，我们在喂这组数据之前就已经知道了这组数据的标准答案，假如得到的答案和标准答案不符，我们希望修改参数来使得得到的答案尽可能像标准答案靠拢，这叫做监督。 非监督性学习：也称它聚类算法。如给邮件分类，在我们训练学习机器给喂数据的过程中，我们根本不知道这组数据应该准确地分为哪一类，甚至不知道应该有哪些类别有多少类别，我们仅能依靠训练数据之间的相关性将他们分为几类。 既然没有标准答案，监督自然也无从说起。 简介就到这，线性回归我们拿到下一章统一讲。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]部署MAC上的Sublime Text+LaTeX中文环境]]></title>
      <url>%2F2015%2F05%2F11%2F%E8%BD%AC-%E9%83%A8%E7%BD%B2MAC%E4%B8%8A%E7%9A%84Sublime-Text-LaTex%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83%2F</url>
      <content type="text"><![CDATA[原文链接：http://www.readern.com/sublime-text-latex-chinese-under-mac.html作者：Read ERN LaTex就不多做介绍了，其实一般人用到的机会也不多（包括我）。只是这段时间在Coursera上新课程的时候，偶尔需要，所以从零开始摸索了一下，也顺便进一步发现了Sublime Text的强大。 MAC上的LaTex部署，一般是两条思路，一个是直接安装MacTex，自带编写环境什么的；另一个是Sublime Text（或者Textmate等其他编辑器）+LaTexTools插件。方式二其实也是需要依赖MacTex的，但相对来说体量小、不需要经常切换编辑器，所以果断的介绍方式二。 亲测：MacOS 10.10, Sublime Text 3可用。（2015年5月） 安装步骤 首先需要安装Sublime Text 3和Package Control，这个有大把的帖子。 MacTex现在是一个2G+的大包子，其实里面很多东西我们不需要，所以本着节约精神，我们安装MacTex_Basic包就行了，现在的版本大概是100M以内。这个安装也是傻瓜的。 在Sublime Text里Command+Shift+P调出命令窗口，输入Install，之后选择LaTexTools，网络OK的话，很快就完成了插件安装。 LaTexTools插件会在编译你的Tex文件后，调用Skim这个PDF阅读器打开编译出的PDF文件，因此你还需要安装Skim. 运行一下Skim，进入偏好设置——同步，在PDF-Tex同步支持那里选择Sublime Text。这样，当你在Sublime Text里修改tex文件时，Skim预览也会相应变更。 完成上面所有步骤，其实就已经搭建完成基本环境。创建一个test.tex文档，贴上我后面附的测试代码，保存一下。(原Po说这里可以开始编译了，亲测是不行的，等完成第七步再编译。) 让我们最后来修改编译和中文环境:打开编辑~/Library/Application\ Support/Sublime\ Text/Packages/Users/LaTeXTools.sublime-settings，将其中”builder”条目改为：&quot;builder&quot;: &quot;simple&quot;接着打开编辑~/Library/Application\ Support/Sublime\ Text\ 3/Packages/LaTeXTools/builders/simpleBuilder.py找到其中大概第41行pdflatex = [&quot;dflatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-synctex=1&quot;]修改为pdflatex = [&quot;xelatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-synctex=1&quot;]保存后关闭，Command + B编译一下，一切OK！ 补充:配置好后，如果编译的时候提示: LaTeXTools: you need to migrate your preferences. See the README file for instructions. 调出命令窗口(Command+Shift+P), 输入如下命令: LaTeXTools: Reconfigure and migrate setting. 最后再给一个个性化设置。上面写了，LaTeXTools默认调用Skim，这一方面是因为LaTeXTools是跨平台的插件，Skim也同样跨平台开源，另一方面Skim确实对LaTeX的PDF支持很好。但是用OS X的网友们其实还有个选择，就是调用系统默认的PDF程序来打开编译后的成果，特别是“预览”还是很好用的。目前LaTeXTools的开发者还没有给出设置方法，所以，仍然要靠改代码：修改~/Library/Application\ Support/Sublime\ Text\ 3/Packages/LaTeXTools/jumpToPDF.py, 将其中if plat == &#39;darwin&#39;: 之后开始的两段直接注释掉，替换为：subprocess.Popen([‘open’] + [pdffile])同样保存后就生效啦。目前用起来，系统自带的预览还是能满足我的需求滴。 测试代码：1\documentclass&#123;article&#125;&#10;\usepackage&#123;fontspec, xunicode, xltxtra&#125; &#10;\setmainfont&#123;Hiragino Sans GB&#125; &#10;&#10;\title&#123;Title&#125;&#10;\author&#123;&#125;&#10;&#10;\begin&#123;document&#125;&#10;&#10;\maketitle&#123;&#125;&#10;&#10;\section&#123;Introduction&#125;&#10;&#10;This is where you will write your content. &#22312;&#36825;&#37324;&#20889;&#19978;&#20869;&#23481;&#12290;&#10;&#10;\end&#123;document&#125; LaTex的其他选择如果只是偶尔需要输入公式，这里介绍一个在线的LaTex公式编辑器http://www.codecogs.com/latex/eqneditor.php 有iPad的，你们有福了，还有个手写公式后自动识别、生成LaTex公式的App：Script MathPad。简单的使用已经足够了，如果需要经常使用，导出功能需要内购（4.99刀）。顺便说一句，这家公司的手写App都很强大，手写计算器、手写Notes都挺好用，而且不贵。 参考链接：MacTex页面：http://tug.org/mactex/morepackages.html Skim官网：http://skim-app.sourceforge.net LaTexTools官网：https://github.com/SublimeText/LaTeXTools 前六步骤的具体介绍：http://economistry.com/2013/01/installing-and-using-latex-for-mac/ 不过需要注意，这里是用了完整的MacTex 发现xelatex是受了这里的启发：http://www.teeboneding.com/blog/2013/06/01/write-ntu-master-thesis-with-xelatex-template-on-mac/ 但需要注意，这里的编译代码测试无效。 第七步受了这里的启发：https://github.com/SublimeText/LaTeXTools/issues/303]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编程之美2015初赛第一场]]></title>
      <url>%2F2015%2F05%2F07%2F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E2015%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA%2F</url>
      <content type="text"><![CDATA[Hihocoder 1156 彩色的树题目链接: http://hihocoder.com/problemset/problem/1156 在每个更新操作的过程中，假设点P最初的颜色为color1，更新后的颜色为color2。我们记与点P相邻，颜色为color1的点为num1, 颜色为color2的点为num2。则 ans += num1 - 1, ans -= num2 - 1。 难点主要在于统计nun1, num2。直接暴力肯定是要TLE的，这里有个技巧。 既然是在树中，我们用map存点P的子节点各种颜色的点有多少个，将父节点单独考虑。查询的过程中: num1 = map[P][color1] + (color[ fa[P] ] == color1) num2 = map[P][color2] + (color[ fa[p] ] == color2) 更新的时候只用将父节点的子节点的color1—, color2++。在O(log)级的复杂度内就能完成更新查询操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define FOR(i,l,r) for(int i=(l); i&lt;=(r); ++i)#define REP(i,r) for(int i=0; i&lt;(r); ++i)#define DWN(i,r,l) for(int i=(r);i&gt;=(l);--i)#define pb push_backconst int N = 1e5 + 10;vector&lt;int&gt;head[N];int color[N], fa[N];map&lt;int, int&gt;m[N];void dfs(int cur) &#123; //构建树形结构 for(int to: head[cur]) &#123; if(to == fa[cur]) continue; fa[to] = cur; m[cur][0] ++; dfs(to); &#125;&#125;void update(int cur, int tmp_color, int &amp;ans) &#123; //更新点的同时同时更新ans int tmp = 0; tmp += m[cur][ color[cur] ]; if(color[ fa[cur] ] == color[cur]) ++tmp; ans += tmp - 1; tmp = 0; tmp += m[cur][tmp_color]; if(color[ fa[cur] ] == tmp_color) ++tmp; ans -= tmp - 1; --m[ fa[cur] ][ color[cur] ]; ++m[ fa[cur] ][ tmp_color ]; color[cur] = tmp_color;&#125;int main() &#123; int casnum, casid = 0, n, q, x, y, z; cin &gt;&gt; casnum; while(casnum--) &#123; memset(color, 0, sizeof(color)); FOR(i, 1, n) head[i].clear(), m[i].clear(); cin &gt;&gt; n; REP(i, n-1) &#123; scanf("%d%d", &amp;x, &amp;y); head[x].pb(y); head[y].pb(x); &#125; fa[1] = 0; dfs(1); printf("Case #%d:\n", ++ casid); int ans = 1; color[0] = -1; cin &gt;&gt; q; while(q--) &#123; scanf("%d", &amp;x); if(x == 1) printf("%d\n", ans); else &#123; scanf("%d%d", &amp;y, &amp;z); update(y, z, ans); &#125; &#125; &#125; return 0;&#125; Hihocoder 1157 建造金字塔题目链接： http://hihocoder.com/problemset/problem/1157 DP。输入的时候时候一个三角形用顶点坐标(x, y)来表示，我们转化成左右端顶点的横坐标来表示一个三角形(l,r) = (x-y,x+y)。然后按l进行排序。我们用dp[i][j]表示第i个点，且前从前i个三角形选择的三角形中最右端为j的最大获益。假设第i个点的左右端点为(l,r)，利润为v1，成本为v2，分三种情况讨论： j &lt;= l：dp[i][r] = max(dp[i][r], dp[i-1][j] + v1 - v2) j &gt;= r：dp[i][j] = max(dp[i][j], dp[i-1][j] + v1) j &gt; l &amp;&amp; j &lt; r：dp[i][r] = max(dp[i][r], dp[i-1][j] + v1 - v2 + v3)。v3为与之前的重叠面积 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#define FOR(i,l,r) for(int i=(l); i&lt;=(r); ++i)#define REP(i,r) for(int i=0; i&lt;(r); ++i)#define DWN(i,r,l) for(int i=(r);i&gt;=(l);--i)#define pb push_backdouble dp[2][3010]; //滚动数组，第一维只要2就够了struct Trangle &#123; int l, r; double v1, v2; bool operator &lt;(const Trangle &amp;other) const &#123; if(l != other.l) return l &lt; other.l; return r &lt; other.r; &#125;&#125;;int main() &#123; int casnum, casid = 0, n, x, y, z; cin &gt;&gt; casnum; while(casnum--) &#123; double ans = 0; cin &gt;&gt; n; vector&lt;Trangle&gt;vec(n); REP(i, n) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); vec[i].l = x - y + 1000;//因为x-y有可能小于0,注意不要超出边界 vec[i].r = x + y + 1000; vec[i].v1 = z; vec[i].v2 = y * y; &#125; sort(vec.begin(), vec.end()); //按l排序 int cur = 1, pre = 0; REP(i, 2) REP(j, 3001) dp[i][j] = -1e18; dp[cur][0] = 0; for(auto t: vec) &#123; cur ^= 1, pre ^= 1; REP(i, 3001) dp[cur][i] = -1e18; int l = t.l, r = t.r; REP(i, 3001) &#123;//分三种情况讨论 if(i &gt;= r) dp[cur][i] = max(dp[cur][i], dp[pre][i] + t.v1); else if(i &lt;= l) dp[cur][r] = max(dp[cur][r], dp[pre][i] + t.v1 - t.v2); else dp[cur][r] = max(dp[cur][r], dp[pre][i] + t.v1 - pow((t.r - t.l) / 2.0, 2.0) + pow((i - t.l) / 2.0, 2.0)); dp[cur][i] = max(dp[cur][i], dp[pre][i]); ans = max(ans, dp[cur][i]); &#125; &#125; printf("Case #%d: %.2lf\n", ++casid, ans); &#125; return 0;&#125; Hihocoder 1158 质数相关题目链接：http://hihocoder.com/problemset/problem/1158 二分匹配求最大独立集。可证：如果(a,b)质数相关，(b,c)质数相关，则（a,c）质数无关 因此没有奇数环，可划分为二分图。求出二分匹配，最大独立集 = n - 最大匹配。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define FOR(i,l,r) for(int i=(l); i&lt;=(r); ++i)#define REP(i,r) for(int i=0; i&lt;(r); ++i)#define DWN(i,r,l) for(int i=(r);i&gt;=(l);--i)#define pb push_backconst int N = 500010;bool is_prime[510000], flag[510000];void init() &#123; memset(is_prime, 1, sizeof(is_prime)); memset(flag, 0, sizeof(flag)); vector&lt;int&gt;prime; FOR(i, 2, N) &#123; //素数筛 if(!is_prime[i]) continue; prime.pb(i); for(int j = i + i; j &lt;= N; j += i) is_prime[j] = 0; &#125; FOR(i, 1, N) //给每个点染色，因为没有奇数环，所以必然染成或黑或白的一种 for(int x: prime) &#123; if(i &gt; N / x) break; flag[i * x] = flag[i] ^ 1; &#125;&#125;struct Max_Match &#123; //匈牙利匹配 vector&lt;int&gt;head[1100]; int match_x[1100], match_y[1100]; bool visit[1100]; void add(int x, int y) &#123; head[x].pb(y); &#125; bool find_path(int cur) &#123; for(int to: head[cur]) if(!visit[to]) &#123; visit[to] = 1; if(match_y[to] == -1 || find_path( match_y[to] )) &#123; match_x[cur] = to; match_y[to] = cur; return 1; &#125; &#125; return 0; &#125; int solve(int n, vector&lt;int&gt;&amp;vec) &#123; memset(match_x, -1, sizeof(match_x)); memset(match_y, -1, sizeof(match_y)); int ret = 0; REP(i, n) &#123; if(flag[ vec[i] ] != 0) continue; memset(visit, 0, sizeof(visit)); ret += find_path(i); &#125; return ret; &#125;&#125;;int main() &#123; init(); int casnum, casid = 0, n; cin &gt;&gt; casnum; while(casnum --) &#123; cin &gt;&gt; n; vector&lt;int&gt;vec(n); REP(i, n) scanf("%d", &amp;vec[i]); sort(vec.begin(), vec.end()); Max_Match match; REP(i, n) //建立二分图 REP(j, i) if(vec[i] % vec[j] == 0 &amp;&amp; is_prime[ vec[i] / vec[j] ]) &#123; if(flag[ vec[i] ] &lt; flag[ vec[j] ]) match.add(i, j); else match.add(j, i); &#125; printf("Case #%d: %d\n", ++casid, n - match.solve(n, vec)); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CDQ分治 && HDU 5126]]></title>
      <url>%2F2015%2F05%2F02%2FCDQ%E5%88%86%E6%B2%BB%2F</url>
      <content type="text"><![CDATA[参考文献：从《Cash》谈一类分治算法的应用 — 陈丹琦 也因此简称CDQ分治。 个人理解CDQ分治和普通分治最大的区别为：普通分治可以将问题拆成几个相互独立的子问题CDQ分治将问题分成了两个部分： 相互独立的两个子问题 两个子问题之间的联系 因此，CDQ分治的算法流程也分为以下几步： 算法开始 取一个中间点mid, 将问题分为[L, mid] 和 [mid + 1, R]两个部分。分别处理两个子问题 处理[L, mid] 和 [mid + 1, R]之间的联系 举个例子：在二维坐标系中，有n个点，m个询问。对于每个询问(x, y)，求点(x1, x2) ，x1&lt;= x &amp;&amp; y1 &lt;= y 有多少个。 当然，这题用树状数组就直接能写了。但是我们在这里用CDQ分治来解决一下这个问题。 我们将n个点看做是n个更新，并和m个询问放在一起。定义一个结构体用vector存起来。 12345678910111213141516171819202122232425262728293031void sovle1(int l, int r, vector&lt;Struct&gt;vec1) &#123; //在这里将vec1[l, r]按x从小到大排序 int mid = (l + r) / 2; solve1(l, mid); solve1(mid + 1, r);//划分成相互独立的子问题 //将vec1[l, mid]中的更新操作 和 vec1[mid + 1, r]中的询问操作,存到一个vec2中 solve2(l, r, vec2);//左半边的更新操作和右半边的询问操作之间有联系&#125;void solve2(int l, int r, vector&lt;Struct&gt;vec2) &#123;//此时在solve2中已经不需要管x了。在vec2中所有的更新操作的x必然小于等于询问操作的x。 //在这里将vec2[l, r]按y从小到大排序 int mid = (l + r) / 2; sovle2(l, mid); solve2(mid + 1, r);//独立子问题 //将vec2[l, mid]中的更新操作和vec2[mid + 1, r]中得询问操作存到一个vec3中 solve3(l, r, vec3);//&#125;void solve3（int l, int r, vector&lt;Struct&gt;vec3） &#123;//此时在solve3中，x和y都是已经排好序的。从前到后遍历该更新更新该询问询问就好。 int cal = 0; for(Struct tmp: vec3) &#123; if(tmp.type == Update) ++cal; else tmp.query_anser += cal; &#125;&#125;//这段代码其中有许多可以优化的地方，但是不要在意细节，主要是为了更加方便地理解算法 虽然解法不如树状数组，但是我们得看到题目扩展后的好处。我们看到，当到solve2时，函数中的参数vec2已经不用再管他的x了（请务必深刻理解为什么不用再管了）。这样的好处在哪里？没错，降维！假如我们要处理的不是二维，而是三维四维依旧可以这么处理，每一个维度只不过加了O(log)的复杂度而已。如果是随时可以更新查询的操作，只不过也只是把时间当成一个维度而已。（光是这一点就已经牛逼哄哄够解决大部分题目了。） 然后就是下面这道题，三维且可随时更新查询：HDU 5126 starts: 传送门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;using namespace std;#define FOR(i,l,r) for(int i=(l); i&lt;=(r); ++i)#define REP(i,r) for(int i=0; i&lt;(r); ++i)#define DWN(i,r,l) for(int i=(r);i&gt;=(l);--i)#define pb push_backtypedef long long ll;typedef pair&lt;int, int&gt;pii;const int N = 5e4 + 100;int que[N &lt;&lt; 1];int ans[N];int z_num;int node[N &lt;&lt; 1];struct Query &#123; int x, y, z, kind, id; Query() &#123;&#125; Query(int _x, int _y, int _z, int _kind, int _id) : x(_x), y(_y), z(_z), kind(_kind), id(_id) &#123;&#125;&#125;queries[N &lt;&lt; 3], queries_x[N&lt;&lt;3], queries_y[N &lt;&lt; 3];bool cmpx(Query a, Query b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.kind &lt; b.kind);&#125;bool cmpy(Query a, Query b) &#123; return a.y &lt; b.y || (a.y == b.y &amp;&amp; a.kind &lt; b.kind);&#125;inline int lowbit(int x) &#123;return x&amp;-x;&#125;void update(int pos, int value) &#123; while(pos &lt;= z_num) &#123; node[pos] += value; pos += lowbit(pos); &#125;&#125;int query(int pos) &#123; int ret = 0; while(pos) &#123; ret += node[pos]; pos -= lowbit(pos); &#125; return ret;&#125;void solve3(int l, int r) &#123;//只剩下二维y和z，直接就是二维的更新查询题目，树状数组解决就好了 if(l &gt;= r) return; FOR(i, l, r) if(queries_y[i].kind == 0) update(queries_y[i].z, 1); else if(queries_y[i].kind == 1) ans[ queries_y[i].id ] -= query(queries_y[i].z); else if(queries_y[i].kind == 2) ans[ queries_y[i].id ] += query(queries_y[i].z); FOR(i, l, r) if(queries_y[i].kind == 0) update(queries_y[i].z, -1);&#125;void solve2(int l, int r) &#123;//把x这一维度消除 if(l &gt;= r) return; int mid = (l+r)&gt;&gt;1; solve2(l, mid); solve2(mid + 1, r); int num = 0; FOR(i, l, mid) if(queries_x[i].kind == 0) queries_y[num++] = queries_x[i]; FOR(i, mid+1, r) if(queries_x[i].kind) queries_y[num++] = queries_x[i]; sort(queries_y, queries_y + num, cmpy); solve3(0, num - 1);&#125;void solve1(int l, int r) &#123;//已经默认时间从小到大排序了，把时间这一维度消除 if(l &gt;= r) return; int mid = (l+r)&gt;&gt;1; solve1(l, mid); solve1(mid + 1, r); int num = 0; FOR(i, l, mid) if(queries[i].kind == 0) queries_x[num++] = queries[i]; FOR(i, mid + 1, r) if(queries[i].kind) queries_x[num++] = queries[i]; sort(queries_x, queries_x + num, cmpx);//对x从小到大排序 solve2(0, num - 1);&#125;int main() &#123; int casnum, n; int x1, x2, y1, y2, z1, z2, kind; cin &gt;&gt; casnum; while(casnum--) &#123; memset(ans, -1, sizeof(ans)); cin &gt;&gt; n; int id = 0; z_num = 0; REP(i, n) &#123; scanf("%d", &amp;kind); if(kind == 1) &#123; scanf("%d%d%d", &amp;x1, &amp;y1, &amp;z1); queries[id++] = Query(x1, y1, z1, 0, i); que[z_num++] = z1; &#125; else &#123; ans[i] = 0; scanf("%d%d%d%d%d%d", &amp;x1, &amp;y1, &amp;z1, &amp;x2, &amp;y2, &amp;z2); queries[id++] = Query(x2 , y2 , z2 , 2, i); queries[id++] = Query(x2 , y2 , z1 - 1, 1, i); queries[id++] = Query(x2 , y1 - 1, z2 , 1, i); queries[id++] = Query(x1 - 1, y2 , z2 , 1, i); queries[id++] = Query(x2 , y1 - 1, z1 - 1, 2, i); queries[id++] = Query(x1 - 1, y2 , z1 - 1, 2, i); queries[id++] = Query(x1 - 1, y1 - 1, z2 , 2, i); queries[id++] = Query(x1 - 1, y1 - 1, z1 - 1, 1, i); que[z_num++] = z2; que[z_num++] = z1 - 1; &#125; &#125; sort(que, que + z_num); z_num = unique(que, que + z_num) - que; REP(i, id) queries[i].z = lower_bound(que, que + z_num, queries[i].z) - que + 1; solve1(0, id - 1); REP(i, n) if(ans[i] != -1) printf("%d\n", ans[i]); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5208 Where is Bob && Bestcoder Round38 C题]]></title>
      <url>%2F2015%2F04%2F21%2FHDU-5208-Where-is-Bob-Bestcoder-Round38-C%E9%A2%98%2F</url>
      <content type="text"><![CDATA[题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5208 近似于数位DP的思路。用数位DP求区间中符号条件的数有多少的时候，有时会用一个符号位来记录当前的取值是否达到区间的上界。这里同样用这个办法。（官方题解我有点没看懂，我的解法有可能和官方题解不一样） 看到题第一眼，觉得应该优先从高位到低位处理，在以下两种情况中，决策应该是确定的： 第一个人只能取0或1中的一个。这时候第二个人一定是尽量取和第一个人一样的值。 第二个人只能取0或1中得一个，而第一个人两个都可以选。第一个人自然取第二个人取不到的值。 但是，当在这两种情况之外，决策就不唯一了。这时，先把低位的决策解决了就很有必要。我们用dp[i][l1][r1][l2][r2]来表示。 l1 为1时，表示 假设第一个人从最高位到第i+1位的取值都是取区间范围允许的最小值。 此时，第一个人在第i位的取值要小心不要小于区间允许的最小值。反之l1为0时，表示假设第一个人从最高位到第i+1位的取值有一个不是区间范围的最小值，这时候，从第i位到第0位取任何值都不会小于区间允许的最小值了。 请仔细理解上面这段话。 同理，r1代表之前取的是不是区间范围允许的最大值。然后能类推倒l2, r2。 对于每一位, 我们枚举l1, r1, l2, r2。（再次阐明一下，l1, r1, l2, r2不是表示第i位两个人的取值范围，是表示高位的取值是不是都是边界值。） 当l1, r1, l2, r2确定以后，第i位两个人的取值范围也就确定了，枚举两个人的取值，用第i-1位递推到第i位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define FOR(i,l,r) for(int i=(l); i&lt;=(r); ++i)#define REP(i,r) for(int i=0; i&lt;(r); ++i)#define DWN(i,r,l) for(int i=(r);i&gt;=(l);--i)#define pb push_backtypedef long long ll;typedef pair&lt;int, int&gt;pii;ll dp[40][2][2][2][2];int main() &#123; int casnum, casid = 0; cin &gt;&gt; casnum; while(casnum--) &#123; REP(i, 31) REP(a, 2) REP(b, 2) REP(c, 2) REP(d, 2) dp[i][a][b][c][d] = 1e15; int l[2][2]; REP(i, 2) REP(j, 2) cin &gt;&gt; l[i][j]; FOR(i, 0, 31) &#123; REP(a, 2) REP(b, 2) REP(c, 2) REP(d, 2) &#123; //枚举高位的取值是不是都是边界值 bool tmp_l[2][2] = &#123; &#123;0, 1&#125;, &#123;0, 1&#125; &#125;; // 确定此时两个人的取值范围 if(a) tmp_l[0][0] = l[0][0] &amp; (1&lt;&lt;i); //当第一个人高位的取值都是下界值，而且第i位的下界值为1时 //第i位的取值范围的下界为1。否则第i位的取值范围的下界为0。 if(b) tmp_l[0][1] = l[0][1] &amp; (1&lt;&lt;i); //都类比第一个 if(c) tmp_l[1][0] = l[1][0] &amp; (1&lt;&lt;i); if(d) tmp_l[1][1] = l[1][1] &amp; (1&lt;&lt;i); ll tmp1 = 0; FOR(j, tmp_l[0][0], tmp_l[0][1]) &#123; //取值范围确定了，现在我们来枚举值。j是第一个人的取值 ll tmp2 = 1e15; FOR(k, tmp_l[1][0], tmp_l[1][1]) &#123; //第i位的异或值加上i-1位的dp值就是第i位的dp值。 //但是我们得先算出两个人分别取j和k的情况下 //高位的取值加上第i位的取值是否依然达到上下界 bool tmp[2][2] = &#123; &#123;0, 0&#125;, &#123;0, 0&#125; &#125;; if(a &amp;&amp; (j == tmp_l[0][0])) tmp[0][0] = 1; //当且仅当高位取值到达下界,第i位又取到下界值得时候, //对i-1位来说高位的取值达到下界 if(b &amp;&amp; (j == tmp_l[0][1])) tmp[0][1] = 1; if(c &amp;&amp; (k == tmp_l[1][0])) tmp[1][0] = 1; if(d &amp;&amp; (k == tmp_l[1][1])) tmp[1][1] = 1; if(i) tmp2 = min(tmp2, ((ll)(j^k) &lt;&lt; i) + dp[i-1][tmp[0][0]][tmp[0][1]][tmp[1][0]][tmp[1][1]]); else tmp2 = min(tmp2, ((ll)(j^k) &lt;&lt; i)); &#125; tmp1 = max(tmp1, tmp2); &#125; dp[i][a][b][c][d] = tmp1; &#125; &#125; ll ans = dp[31][1][1][1][1]; printf("Case #%d: %I64d\n", ++casid, ans); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BestCoder Round #25]]></title>
      <url>%2F2015%2F01%2F09%2FBestCoder-Round-25%2F</url>
      <content type="text"><![CDATA[1001 Harry and Magical Computer就是判断有没有环存在。点比较少，Floyd一遍O(n^3)就行。 1002 Harry And Magic Box官方题解是O(n^4)的，其实中间有一维可以省略。（小地方而已。。不管也罢。。）dp[i][j]表示第i行已经有j列被选过（这j个不一定全都是在第i行选的，有可能包括之前选的）。则dp公式为： (1 &lt;= k &lt;= j) 1234if(k == j) dp[i][j] += dp[i-1][k] * ((1&lt;&lt;k) - 1);else: dp[i][j] += dp[i-1][k] * (1&lt;&lt;k) * c[m-k][j-k]; 表示假如k==j，前k个中至少选一个，种类数为((1&lt;&lt;k) - 1)。否则， 前k个随便选， 其余从m-k中选j-k个。注意数据溢出。 1003 Harry and Christmas tree我是按照官方题解的思路。对每种颜色单独考虑。对第i-1个有这种颜色点a, 第i个有这种颜色的点b， 以及a和b的lca点c。 在递归过程中，c之前的点都可以被贡献1中颜色，直到c以及c往上，贡献度为a和b各一个，然后减去a和b的重复一个，总共为1。 中间要用到lca算法，因为这道题就是按照递归的顺序进行遍历，用离线的lca就行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define FOR(i,l,r) for(int i=(l); i&lt;=(r); ++i)#define REP(i,r) for(int i=0; i&lt;(r); ++i)#define DWN(i,r,l) for(int i=(r);i&gt;=(l);--i)#define pb push_backtypedef long long ll;typedef pair&lt;int, int&gt;pii;const int N = 5e4 + 1;const int M = 1e5 + 1;vector&lt;int&gt;head[N], gift[N];int fa[N], ans[N];int pre_color[M];inline int find(int x) &#123; if(x==fa[x]) return x; else return fa[x] = find(fa[x]);&#125;void dfs(int now, int pre) &#123; REP(i, head[now].size()) &#123; if(head[now][i] != pre) &#123; dfs(head[now][i], now); fa[ head[now][i] ] = now; //离线lca中得一部分 ans[now] += ans[ head[now][i] ]; //将子节点的贡献度加上来。（这时候子节点的贡献度已经是 总贡献度 - 重复次数 了） &#125; &#125; REP(i, gift[now].size()) &#123; int color = gift[now][i]; if(!pre_color[color]) &#123; //第一个出现这种颜色，跳过不处理 pre_color[color] = now; continue; &#125; int lca = find(pre_color[color]); // 找lca --ans[lca]; // 在lca上加上一个重复度, ans-- pre_color[color] = now; &#125; ans[now] += gift[now].size(); //加上本节点的贡献&#125;int main() &#123; //freopen("in", "r", stdin); int n, m; int x, y; while(cin&gt;&gt;n&gt;&gt;m) &#123; memset(ans, 0, sizeof(ans)); memset(pre_color, 0, sizeof(pre_color)); FOR(i, 1, n) fa[i] = i, head[i].clear(), gift[i].clear(); REP(i, n-1) &#123; scanf("%d%d",&amp;x, &amp;y); head[x].pb(y); head[y].pb(x); &#125; while(m--) &#123; scanf("%d%d", &amp;x, &amp;y); gift[x].pb(y); &#125; dfs(1, 0); FOR(i, 1, n) &#123; if(i!=1) putchar(' '); printf("%d", ans[i]); &#125; puts(""); &#125; return 0;&#125; Harry and magic stringDP + Manacher算法 DP思路很简单。sum[i] 表示以i结尾和i之前结尾的回文串总数。dp[i] 表示以i开头的回文串数。 ans = $$\sum_{i=1}^{len-1} {sum[i-1] * dp[i]}$$ 难点就是sum[i] 和 dp[i] 怎么求的问题了。新学习了个算法， Manacher算法，在我转载的上篇文章中有讲解。传送门 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;#define FOR(i,l,r) for(int i=(l); i&lt;=(r); ++i)#define REP(i,r) for(int i=0; i&lt;(r); ++i)#define DWN(i,r,l) for(int i=(r);i&gt;=(l);--i)#define pb push_backtypedef long long ll;typedef pair&lt;int, int&gt;pii;const int MAX_LEN = 1e5 + 10;char str[MAX_LEN];int Len[MAX_LEN&lt;&lt;1];struct Manacher &#123; // Manacher算法, 讲解看上篇文章 char tmp_str[MAX_LEN&lt;&lt;1]; int init(char *s) &#123; int len = strlen(s); int id = 0; tmp_str[id++] = '#'; for(int i=0; i&lt;len; ++i) &#123; tmp_str[id++] = s[i]; tmp_str[id++] = '#'; &#125; tmp_str[id] = '\0'; return id; &#125; void solve(char *s) &#123; int len = init(s); int max_r = -1, max_id = -1; for(int i=0; i&lt;len; ++i) &#123; if(max_r &gt; i) Len[i] = min(max_r - i, Len[2 * max_id - i]); else Len[i] = 1; while(i - Len[i] &gt;= 0 &amp;&amp; i + Len[i] &lt; len &amp;&amp; tmp_str[i - Len[i]] == tmp_str[i + Len[i]]) ++Len[i]; if(i + Len[i] &gt; max_r) &#123; max_r = i + Len[i]; max_id = i; &#125; &#125; &#125;&#125;;long long sum[MAX_LEN &lt;&lt; 1];int flag[MAX_LEN &lt;&lt; 1];int main() &#123; //freopen("in", "r", stdin); while(cin&gt;&gt;str) &#123; memset(sum, 0, sizeof(sum)); memset(flag, 0 ,sizeof(flag)); Manacher manacher; manacher.solve(str); int len = strlen(str); int tmp = 0; for(int i = 1; i &lt;= (len&lt;&lt;1); ++i) &#123; //求sum sum[i] += sum[i-1]; ++tmp; tmp -= flag[i]; ++flag[i + Len[i]]; if(i&amp;1) sum[i] += tmp; &#125; long long ans = 0; memset(flag, 0, sizeof(flag)); tmp = 0; for(int i = (len&lt;&lt;1); i &gt;= 1; --i) &#123; //求ans ++tmp; tmp -= flag[i]; ++flag[i - Len[i]]; if(i&amp;1) ans += sum[i-1] * tmp; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转]Manacher算法-回文串处理]]></title>
      <url>%2F2015%2F01%2F09%2F-%E8%BD%AC-Manacher%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E4%B8%B2%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[Manacher算法是查找一个字符串的最长回文子串的线性算法。在介绍算法之前，首先介绍一下什么是回文串，所谓回文串，简单来说就是正着读和反着读都是一样的字符串，比如abba，noon等等，一个字符串的最长回文子串即为这个字符串的子串中，是回文串的最长的那个。计算字符串的最长回文字串最简单的算法就是枚举该字符串的每一个子串，并且判断这个子串是否为回文串，这个算法的时间复杂度为O(n^3)的，显然无法令人满意，稍微优化的一个算法是枚举回文串的中点，这里要分为两种情况，一种是回文串长度是奇数的情况，另一种是回文串长度是偶数的情况，枚举中点再判断是否是回文串，这样能把算法的时间复杂度降为O(n^2)，但是当n比较大的时候仍然无法令人满意，Manacher算法可以在线性时间复杂度内求出一个字符串的最长回文字串，达到了理论上的下界。 Manacher算法原理与实现下面介绍Manacher算法的原理与步骤。首先，Manacher算法提供了一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑，具体做法是，在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现，一般情况下可以用#号。下面举一个例子： Len数组简介与性质Manacher算法用一个辅助数组Len[i]表示以字符T[i]为中心的最长回文字串的最右字符到T[i]的长度，比如以T[i]为中心的最长回文字串是T[l,r],那么Len[i]=r-i+1。对于上面的例子，可以得出Len[i]数组为: Len数组有一个性质，那就是Len[i]-1就是该回文子串在原字符串S中的长度，至于证明，首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1。有了这个性质，那么原问题就转化为求所有的Len[i]。下面介绍如何在线性时间复杂度内求出所有的Len。 Len数组的计算首先从左往右依次计算Len[i]，当计算Len[i]时，Lenj已经计算完毕。设P为之前计算中最长回文子串的右端点的最大值，并且设取得这个最大值的位置为po，分两种情况：第一种情况：i&lt;=P那么找到i相对于po的对称位置，设为j，那么如果Len[j]&lt;P-i，如下图： 那么说明以j为中心的回文串一定在以po为中心的回文串的内部，且j和i关于位置po对称，由回文串的定义可知，一个回文串反过来还是一个回文串，所以以i为中心的回文串的长度至少和以j为中心的回文串一样，即Len[i]&gt;=Len[j]。因为Len[j]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(转) Mac中安装Vim7.4]]></title>
      <url>%2F2015%2F01%2F07%2FMac%E4%B8%AD%E5%AE%89%E8%A3%85Vim7-4%2F</url>
      <content type="text"><![CDATA[Mac本身其实是预装了Vim的，但是目前的系统中都是Vim7.3版本的，而最新的Vim已经是7.4版了，因此为了能够使用最新版的vim，必须要对Mac中的vim要么升级，要么重装。在折腾过程中，遇到了一些问题，这里记录，以鉴后人。 可选方案升级原生的Vim7.3 这种方法貌似是最”干净”的，不会引入其他任何多余的东西，对于有洁癖的人这应该是一种比较好的方案。但是，这个方案也有缺点，那就是它会覆盖原生的Vim，会改变系统的默认设置，并且一旦升级过程中出现了问题，那你就再也没有可用的vim了。另外一个问题是，以后当你系统升级的时候，很有可能你自己的vim又会被新系统的vim给覆盖，这样会比较麻烦。 使用MacVim这是一种比较好的方案，Vim官网上也是推荐使用这种方案的，MacVim是针对Mac系统特别定制的Vim版本，安装过程也很简单，网上一搜一大把。它功能上和vim完全一致，不会有任何的问题。要说这种方案其实已经算是一个完美的解决方案了，但是它有一点不太方便的地方，那就是不能直接在终端中使用vim，每次使用MacVim的时候都会单独开启一个窗口，有点类似于windows中的gvim。而我个人是比较习惯在终端中写代码的，因此这个方案还是不能满足我的需求。 自己编译这是一种终极的方案，但是自己编译的时候注意要手动更改默认的安装目录，不然它就会覆盖原生的vim7.3，这样就会变成第一种方案了。将vim7.4安装在其他目录，然后在.bash_profile中添加一个vim命令的别名，将其指向新安装的vim7.4的目录，而不是原生的vim7.3目录。这个方案就能在终端中直接使用vim7.4了，并且不会对原生的vim7.3又任何影响。这个方案唯一的缺点大概就是会在系统中产生两个不同版本的vim了，这也许对一些有洁癖的人是难以接受的。 我自己最终选择了第三套方案，也就是自己编译新版本的vim. 重新编译好了，现在让我们开始折腾吧。 首先上vim的官网下载vim7.4的源文件。（下载链接） 新建目录/opt/local，这个目录就是用来存放我们新安装的vim7.4的，你也可以建立其他的目录，这里只是一个示例。 进入vim的源文件目录中，在终端中运行命令:1./configure --with-features=huge --enable-pythoninterp=yes --enable-cscope --enable-fontset --enable-perlinterp --enable-rubyinterp --with-python-config-dir=/usr/lib/python2.6/config --prefix=/opt/local 这个命令是完成对vim的一些配置选项，启用了python和ruby的支持特性，这还是比较重要的，因为vim中有些插件会使用python和ruby的，如果没有开启这些特性，有些插件是无法运行的。在这些配置命令中，最后一个--prefix=/opt/local是用来指明安装目录的，你也可以修改成你自己的目录。 在写配置命令的时候，需要注意的是，不能写上--enable-gui，这是开启gui特性的，但是我们是在终端环境下安装的，因此不能开启这个特性，否则会出现编译错误。 在终端中执行make命令。在make过程中，会出现一个错误，如下所示：123456789101112131415:info:build os_unix.c:830:46: warning: declaration of 'struct sigaltstack' will not be visible outside of this function [-Wvisibility]:info:build extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));:info:build ^:info:build ./os_unix.h:88:21: note: expanded from macro '__ARGS':info:build # define __ARGS(x) x:info:build ^:info:build os_unix.c:830:13: error: conflicting types for 'sigaltstack':info:build extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));:info:build ^:info:build /usr/include/signal.h:89:5: note: previous declaration is here:info:build int sigaltstack(const stack_t * __restrict, stack_t * __restrict) __DARWIN_ALIAS(sigaltstack);:info:build ^:info:build 1 warning and 1 error generated.:info:build make[1]: *** [objects/os_unix.o] Error 1:info:build make[1]: *** Waiting for unfinished jobs….) 解决方案也很简单，只需要在os_unix.h(src文件夹中)中加上#include &lt;AvailabilityMacros.h&gt;就可以了。 执行make install.执行完成之后，vim7.4就安装完成了。 添加vim命令的别名，在.bash_profile中添加一行alias vim=&#39;/opt/local/bin/vim&#39;，然后在终端中执行source ~/.bash_profile 好了，现在你的Mac系统已经安装好了vim7.4了，现在可以开始愉快的工作了。 参考资料http://stackoverflow.com/questions/7211820/update-built-in-vim-on-mac-os-xhttp://www.jokerlin.us/2014/04/13/Vim74.htmlhttp://trac.macports.org/ticket/41774 声明:本文采用BY-NC-SA协议进行授权.转载请注明: Mac中安装Vim7.4转自:Flyaway原文链接: http://zhouyichu.com/vim/Vim-in-Mac.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最短路 SPFA]]></title>
      <url>%2F2015%2F01%2F04%2F%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA%2F</url>
      <content type="text"><![CDATA[首先，为了简化分析，我们假定图中是没有负环的。如果有负环，则就没有最短路径。 负环：一条从a到a的路径，路径上每条边的边权和为负。 但是SPFA算法是可以判断是否有负环存在的，比较基本的做法是判断每个点进队出队的次数，这个复杂度比较高。其实有一种DFS版的SPFA，用这个来判断是否有负环的效率是非常高的，这个我们后续再讲。 最短路的算法中都用着一种通用的思路： 初始化 松弛操作 初始化自然不用说。最开始还没有进行任何操作，每个点（除了起始点）距离起始点的距离为无穷大（记为dis[i]=INF），起始点到起始点的距离为0（记作dis[start]=0）。 然后是松弛操作，也是本篇文章的主要部分。松弛操作的要达到的目的是： 对于任意点u, 将从起始点到u的最短距离记为dis[u]。 对于点u的任意相邻点v, 满足dis[v] &lt;= dis[u] + d[u,v] u与v相邻：存在一条边 u-&gt;v 为什么要满足这样一个条件呢？ 拿v点举例。我们知道，一条从起始点s到v点的最短路径不可能是凭空产生的，从起始点到v点的最短路径在两种情况下可能产生： s与v相邻，(s,v)这条边就可能（但不是一定）就直接是一条最短路径。 有一个点u与v相邻，通过s到u的的最短路径，延伸出一条从s到v得最短路径。 对于第一种情况，很明显一次就直接能找到最短路径。 对于第二种情况，假设到点v的最终最短路径是先从s到u, 再从u到v。在算法执行的过程中，我们不知道此时的dis[u]是否是最短距离。这个都没关系，我们先满足在当前dis[u]的情况下,dis[v]是否小于等于dis[u] + d[u,v]。如果此时的dis[u]是最优解，dis[v]自然也是最优解。如果dis[u]不是最优解，那就往前推，先保证从s到u的最短路径中，u的前一个点x是最优解。如果x不是，再往前推，早晚会推到dis[s]=0，这个妥妥地是最优解了，然后就能保证后面的都是最优解。 所以，我们的算法流程是这样: 初始化 将起始点加入一个队列中 从队列中取出来一个点u，并将这个点从队列中移除 对于u所有相邻的点v，看dis[v] 是否小于等于dis[u] + d[u,v]，如果不是（说明这个点还不是最优解，所以它之前更新过的点中仍然有些不是最优解），更新dis[v]=dis[u] + d[u,v]。再看v是否在队列中，如果不是，将v加入队列。 回到步骤3 直到队列为空，算法结束，此时的dis均为最优解。 算法复杂度为O(k * e)，e为边数。k为可变常数，可证明一般情况下k &lt; 2。（我不知道怎么证明的…有兴趣的可以自己查查） 在这个模板中，为了省内存，我的队列采用的时循环队列的形式。因为每个点最多只能同时在队列里一次，所以这个队列大小为n就足够了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class SPFA &#123; typedef int type; struct Edge &#123; int to, next; type d; &#125;edge[M]; type dis[N]; int que[N], head[N], ip; bool visit[N];//标记各点是否在队列中 public: SPFA() &#123; init(); &#125; void init() &#123; //初始化，采用链式前向星建边 memset(head, -1, sizeof(head)); ip = 0; &#125; void add(int u, int v, int d) &#123; edge[ip].to=v; edge[ip].d=d; edge[ip].next=head[u]; head[u]=ip++; &#125; void spfa(int start, int end, int num) &#123; memset(visit, 0, sizeof(visit));//清空队列 for(int i=0; i&lt;=num; ++i) dis[i] = INF;//步骤1 int front = -1, tail = -1; dis[start] = 0; visit[start] = 1; que[++tail] = start;//步骤2 while(front != tail) &#123; if(++front &gt; num) front -= num; int top = que[front];//步骤3 visit[top] = 0; for(int p=head[top]; p!=-1; p=edge[p].next) &#123; int to = edge[p].to, temp = dis[top] + edge[p].c; if(dis[to] &gt; temp) &#123;//步骤4 dis[to] = temp; if(!visit[to]) &#123; if(++tail &gt; num) tail -= num; que[tail] = to; viist[to] = 1; &#125; &#125; &#125; &#125; return dis[end]; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络流]]></title>
      <url>%2F2015%2F01%2F04%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
      <content type="text"><![CDATA[网络流，也被称为最大流。 模型也非常简单，就是一个管道系统，在有源点，汇点，和一堆有流速限制的管道连接的情况下，问能从源点到汇点传输流量的最大流速是多少。如下图所示。 假定s为源点，t为汇点，中间各箭头为管道，各管道的流速限制均为1。求最大流的话，很明显，最大流为2。有两条流量： s -&gt; 1 -&gt; 3 -&gt; t，流量为1 s -&gt; 2 -&gt; 4 -&gt; t，流量为1 现在是因为图比较简单，我们能一眼看出来。我们自然喜欢程序跑出来的结果是这样。 在程序过程中，自然就是找到一条流量处理一条流量。如果先找到 s -&gt; 1 -&gt; 3 -&gt; t，然后找到 s -&gt; 2 -&gt; 4 -&gt; t，自然皆大欢喜。但是如果程序的第一条直接找到 s -&gt; 1 -&gt; 4 -&gt; t 了呢？这样的最终结果就只有一条流量。 为了解决这个问题，有人提出了一种叫回退边（后悔边）的概念。 这个也是本算法的精髓所在。 后悔边：如果我们根据原图建了一条从u到v，流量为f的边 (u,v)=f。 同时，我们也需要建一条从v到u，流量为0的边 (v,u)=0，这条边我们就称为后悔边。(u,v) 和 (v,u)互为反向边。 同时，在程序进行过程中，如果我们如果从残余网络中找到一条从s到v的流量为f，在更新的过程中，我们首先要把最终答案加上c，然后我们不仅要把在该流量上的各边的剩余流量减去f，同时还要把流量上各条边的反向边的流量加上f。 这样做有什么好处呢? 还是以上图为例，如果我们先找到了 s -&gt; 1 -&gt; 3 -&gt; t，流量为1。我们首先在最终答案中加1，然后在更新的过程中不仅要把 (s,1)、(1,4)、(4,t) 这几条边的剩余流量减1， 还要把 (1,s)、(4,1)、(t,4) 的剩余流量加1。 此时的残余网络为： (s,1) = 0, (1,s) = 1 (s,2) = 1, (2,s) = 0 (1,3) = 1, (3,1) = 0 (1,4) = 0, (4,1) = 1 (2,4) = 1, (4,2) = 0 (3,t ) = 1, (t,3 ) = 0 (4,t ) = 0, (t,4 ) = 1 然后我们从残余网络中找流量，发现此时能找到一条 s -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 3 -&gt; t 的流量了！然后我们还按之前的方式更新。再找的时候找不到新的流量了，算法结束。此时的结果是和我们之前用肉眼观察的结果是一样的。 这就是后悔边的神奇之处。 后悔边，顾名思义，就是给了一条边后悔的权利。在算法过程中，原图的边和后悔边是没有区别的，所以找流量的时候也没有任何区别。 这条边存在的意义是，还拿刚刚那条 s -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 3这条流量来说。里面存在一条后悔边(4,1)，它的意义是： 之前已经更新过的流量中，有一条从4到t的流量4 -&gt; t，这条流量我可以用到。 目前的残余网络中，还存在一条从1到s得流量1 -&gt; 3 -&gt; t，这条流量可以替换你之前更新过的流量 1 -&gt; 4 -&gt; t。 为什么不能你用1 -&gt; 3 -&gt; t，我用4 -&gt; t呢。这样的得到的总流量多一些，我们来交换吧。 你把你的流量退回去，用我给你的。我用你之前的。 至于中间的(4,1)，退回去我也用不上，大不了都不用了吧。 这样下来，最佳方案就出现了。 可以发现，在有后悔边存在的情况下，先找哪条流量后找哪条流量就已经不重要了。反正都是可以做修改的。这样的话，只要考虑如何高效地找流量就好了。这个当然不能随便找，有环的话肯定要进入死循环。 在Dinic算法中，我们采用了分层图的形式。分层用BFS来实现。 首先，将源点的level设为0，并将源点加入队列。 从队列中取出一个点u，遍历以它为起点还有流量的边，找到点v。如果点v还没被加入队列过，将v的level设为level[u]+1，并将v加入队列。 回到步骤2，直到队列为空。 然后我们规定，level为a的点只能向level为a+1的点找流量,这样就能很有效地避免环的出现。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const int N = 1e5 + 100;const int M = 1e7 + 100;const int INF = 1e9;struct Edge&#123; int to,next; int c;&#125;edge[M];int head[N], level[N], que[N], ip;void init() &#123; memset(head, -1, sizeof(head)); ip = 0;&#125;bool makelevel(int s,int t) &#123; //将图分层 memset(level,0,sizeof(level)); int num=0; que[num++]=s; level[s]=1; for(int i=0;i&lt;num;i++) &#123; int top=que[i]; if(top==t) return 1; //找到t了，后面再找level肯定比t大 for(int k=head[top];k!=-1;k=edge[k].next) &#123; if(!level[edge[k].to]&amp;&amp;edge[k].c&gt;0) &#123; que[num++]=edge[k].to; level[edge[k].to]=level[top]+1; &#125; &#125; &#125; return 0;&#125;int dfs(int now,int maxf,int t) &#123; //从残余网络中找流量 if(now==t) return maxf; int ret=0; for(int k=head[now];k!=-1;k=edge[k].next) &#123; if(edge[k].c&gt;0&amp;&amp;level[edge[k].to]==(level[now]+1)) &#123; int c=dfs(edge[k].to,min(maxf-ret,edge[k].c),t); edge[k].c-=c; edge[k^1].c+=c; ret+=c; if(ret==maxf) return ret; &#125; &#125; --level[now]; //一个优化，说明往level[now]+1找流量已经找不到了。自己就降一个level。 return ret;&#125;int dinic(int s,int t) &#123; int ans=0; while(makelevel(s,t)) ans+=dfs(s,INF,t); return ans;&#125;void add(int u,int v,int c,int f) &#123;//有向边f为0 ,否则为 c edge[ip].to=v;edge[ip].c=c;edge[ip].next=head[u];head[u]=ip++; edge[ip].to=u;edge[ip].c=f;edge[ip].next=head[v];head[v]=ip++;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[New Year]]></title>
      <url>%2F2015%2F01%2F02%2FNew-Year%2F</url>
      <content type="text"><![CDATA[新的一年，要把CF刷红，TC刷红。托福要过，N2看着办吧。。。至于签了百度什么的。。。呵呵呵呵。。。妥妥地不想回去了。。。]]></content>
    </entry>

    
  
  
</search>
