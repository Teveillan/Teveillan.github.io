<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Teveillan]]></title>
  <subtitle><![CDATA[不把CF TC刷红的人生是不完整的。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://teveillan.com/"/>
  <updated>2016-04-03T12:45:49.000Z</updated>
  <id>http://teveillan.com/</id>
  
  <author>
    <name><![CDATA[Teveillan]]></name>
    <email><![CDATA[teveillan@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[HDU 5657 CA Loves Math]]></title>
    <link href="http://teveillan.com/2016/04/03/HDU-5657-CA-Loves-Math/"/>
    <id>http://teveillan.com/2016/04/03/HDU-5657-CA-Loves-Math/</id>
    <published>2016-04-03T12:44:47.000Z</published>
    <updated>2016-04-03T12:45:49.000Z</updated>
    <content type="html"><![CDATA[<p>传送门: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5657" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5657</a><br>题意：求[1, $A^n_{(10)}$]中，长度小于等于n，且为k的倍数的数有多少。</p>
<p>此题…巨坑…</p>
<p>比赛时思路是对的，对k进行分类讨论..然并卵…</p>
<p>等A了才发现几个大坑:</p>
<ol>
<li>k的阀值在30000～60000之间才能A，高了低了都不行（想起了那些年计算几何中调精度的日子..）</li>
<li>queue真心慢…</li>
<li>n = 0 or n = 1时坑比较多，建议单独处理</li>
<li><strong>前导0是不算的!!!</strong>。但是题目给的数据比较坑，刚好两位，如果算了前导0，刚好也对。（包括第一题中MOD值为1e8+7…我充满了对这个世界的怨念…）</li>
</ol>
<p>所以说一直WA的可以按我上面的几点检查一下…我感觉我应该是把坑都踩完了…<br><a id="more"></a><br>—————————————正文———————————————</p>
<p>对k进行分类，假设阀值为N（参考上面第一点）。<br>当k &gt;= N时，枚举k的倍数，再判断数字是否重复。<br>当k &lt; N时：<br>记dp[pos][j]：当用的数字集合为pos(状态压缩), 且mod k = j时的数目</p>
<p>转移方程：<br>$$ dp[ pos| (1&lt;&lt;i) ] [ (j + A^x ) \% k] += dp[pos][j] $$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> A, LL x)</span> </span>&#123;<span class="comment">//判断数字是否重复</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = x % A;</span><br><span class="line">        <span class="keyword">if</span>(pos &amp; (<span class="number">1</span>&lt;&lt;tmp)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        pos |= (<span class="number">1</span>&lt;&lt;tmp);</span><br><span class="line">        x /= A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">11</span>][N], f[<span class="number">12</span>];</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> k == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> A / k;</span><br><span class="line"></span><br><span class="line">    n = min(n, A);</span><br><span class="line">    LL NN = <span class="number">1</span>;</span><br><span class="line">    REP(i, n) NN *= A;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= N) &#123; <span class="comment">//k&gt;=N时枚举k的倍数</span></span><br><span class="line">        LL tmp = k;</span><br><span class="line">        <span class="keyword">while</span>(tmp &lt;= NN) &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(A, tmp)) ++ret;</span><br><span class="line">            tmp += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">1</span>, n) f[i] = (f[i-<span class="number">1</span>] * A) % k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    REP(pos, <span class="number">1</span>&lt;&lt;A) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = __builtin_popcount(pos);</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            REP(i, A) <span class="keyword">if</span>((pos &amp; (<span class="number">1</span>&lt;&lt;i)) == <span class="number">0</span>)</span><br><span class="line">                REP(j, k) <span class="keyword">if</span>(dp[pos][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = pos | (<span class="number">1</span>&lt;&lt;i), y = (j + i * f[num]) % k;</span><br><span class="line">                    dp[x][y] += dp[pos][j];</span><br><span class="line">                    <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) ret += dp[pos][j];</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(check(A, NN) &amp;&amp; (NN % k == <span class="number">0</span>)) ++ret; <span class="comment">//特判A^n</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, A, n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(A, n, k) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>传送门: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5657">http://acm.hdu.edu.cn/showproblem.php?pid=5657</a><br>题意：求[1, $A^n_{(10)}$]中，长度小于等于n，且为k的倍数的数有多少。</p>
<p>此题…巨坑…</p>
<p>比赛时思路是对的，对k进行分类讨论..然并卵…</p>
<p>等A了才发现几个大坑:</p>
<ol>
<li>k的阀值在30000～60000之间才能A，高了低了都不行（想起了那些年计算几何中调精度的日子..）</li>
<li>queue真心慢…</li>
<li>n = 0 or n = 1时坑比较多，建议单独处理</li>
<li><strong>前导0是不算的!!!</strong>。但是题目给的数据比较坑，刚好两位，如果算了前导0，刚好也对。（包括第一题中MOD值为1e8+7…我充满了对这个世界的怨念…）</li>
</ol>
<p>所以说一直WA的可以按我上面的几点检查一下…我感觉我应该是把坑都踩完了…<br>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SRM 678 DIV1]]></title>
    <link href="http://teveillan.com/2016/04/01/SRM-678-DIV1/"/>
    <id>http://teveillan.com/2016/04/01/SRM-678-DIV1/</id>
    <published>2016-04-01T13:53:40.000Z</published>
    <updated>2016-04-01T13:54:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Easy:_A_New_Hope">Easy: A New Hope</h2><p>题意：假设一个星期有n天，一个人有n件不同的衣服（标号1~n），每件衣服每周穿一件。由此有N！种穿的方式。<br>但是洗一件衣服需要D天（第x天洗了，x+D天才能穿）。<br>现已知第一周和最后一周穿衣服的顺序，问中间最少隔了几个星期。</p>
<a id="more"></a>
<p>用数学方法表示，每周穿衣服的顺序可标示为长度为n的排序。<br>如{1, 2, 3, 4}。假设D＝3，则4号衣服下周最早可以在周三穿，提前了一天(4 - 3 ＝ 1)。</p>
<p>由此便清楚了，本质上就是第一周的排序$P_1$，移动某些数字后，使其状态等于最后一周的状态$P_m$。而每个数字一周最多可以向前移动<code>n-D</code>位。</p>
<p>枚举每个数字，求移动周数的最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ANewHope</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; firstWeek, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; lastWeek, <span class="keyword">int</span> D)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = firstWeek.size();</span><br><span class="line">            D = n - D;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;first_p, last_p;</span><br><span class="line">            REP(i, n) first_p[ firstWeek[i] ] = i, last_p[ lastWeek[i] ] = i;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            FOR(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(last_p[i] &lt; first_p[i]) </span><br><span class="line">                    ret = max(ret, (first_p[i] - last_p[i] + D - <span class="number">1</span>) / D);<span class="comment">//上取整</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret + <span class="number">1</span>; <span class="comment">//加上第一周</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Middle:_The_Empire_Strikes_Back">Middle: The Empire Strikes Back</h2><p>题意：有n颗行星，坐标$(x_i, y_i)$。有m发子弹，当子弹威力为w时，对准一颗行星，可以消灭(0, 0)~$(x_i, y_i)$矩形内的行星。<br>问子弹威力最小应为多少。</p>
<p>这种题上来不用多说先二分枚举子弹威力mid…</p>
<p>行星坐标$(x_i, y_i)$以及矩形右上角的坐标$(x_i+mid, y_i+mid)$分开存。<br>都对y从大到小进行排序。<br>贪心。保存此时能毁灭的x的最大值max_x，随着行星坐标$y_i$的减小，求矩形坐标中$y_j+mid &gt; y_i$中最大的$x_j+mid$，并更新为max_x</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;pii&gt;&amp;vec, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt;f(vec);</span><br><span class="line">    <span class="keyword">for</span>(pii &amp;tmp: f) tmp.first += mid, tmp.second += mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_x = -<span class="number">1</span>, id = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    DWN(i, n-<span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(max_x &lt; vec[i].second) &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            <span class="keyword">while</span>(id &gt;= <span class="number">0</span> &amp;&amp; f[id].first &gt;= vec[i].first) &#123;</span><br><span class="line">                max_x = max(max_x, f[id].second);</span><br><span class="line">                id --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TheEmpireStrikesBack</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> AX, <span class="keyword">int</span> BX, <span class="keyword">int</span> CX, <span class="keyword">int</span> AY, <span class="keyword">int</span> BY, <span class="keyword">int</span> CY, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;pii&gt;vec;</span><br><span class="line">            LL x = AX, y = AY;</span><br><span class="line">            vec.pb(pii(y, x));</span><br><span class="line">            FOR(i, <span class="number">1</span>, n-<span class="number">1</span>) &#123;</span><br><span class="line">                x = (x * BX + CX) % MOD;</span><br><span class="line">                y = (y * BY + CY) % MOD;</span><br><span class="line">                vec.pb(pii(y, x));</span><br><span class="line">            &#125;</span><br><span class="line">            sort(vec.begin(), vec.end());</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = MOD, ans;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(solve(vec, n, m, mid)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Easy:_A_New_Hope">Easy: A New Hope</h2><p>题意：假设一个星期有n天，一个人有n件不同的衣服（标号1~n），每件衣服每周穿一件。由此有N！种穿的方式。<br>但是洗一件衣服需要D天（第x天洗了，x+D天才能穿）。<br>现已知第一周和最后一周穿衣服的顺序，问中间最少隔了几个星期。</p>]]>
    
    </summary>
    
      <category term="SRM" scheme="http://teveillan.com/tags/SRM/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS Sublime Text 3 C/C++ 配置]]></title>
    <link href="http://teveillan.com/2016/03/30/Mac-OS-Sublime-Text-3-C-C-%E9%85%8D%E7%BD%AE/"/>
    <id>http://teveillan.com/2016/03/30/Mac-OS-Sublime-Text-3-C-C-配置/</id>
    <published>2016-03-30T08:57:59.000Z</published>
    <updated>2016-03-30T09:22:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装sublime_text_3_插件"><strong>安装sublime text 3 插件</strong></h2><p><strong>1.安装 Package Control组件：</strong></p>
<ul>
<li>按 control+` (键盘上1左边的按钮)调出console控制台;</li>
<li>粘贴以下代码到底部命令行并回车:</li>
</ul>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), <span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</span><br></pre></td></tr></table></figure>
<p><strong>2.用Package Control安装插件的方法</strong></p>
<ul>
<li><code>Preference -&gt; Package Control</code>打开控制栏，输入<code>install Package</code>回车。</li>
</ul>
<p><strong>3.常用插件</strong></p>
<ol>
<li><code>SublimeCodeIntel</code>:  代码提示及自动补全</li>
<li><code>SideBar Enhancements</code>: 改进侧边栏</li>
<li><code>SideBar Folders</code>: 增加了侧边栏对于文件夹的支持</li>
</ol>
<p>暂时没用到这么多..以后慢慢补吧…</p>
<p><br> </p>
<h2 id="内置输入数据"><strong>内置输入数据</strong></h2><p>本以为上面的弄完就万事大吉，但在编译运行的时候发现一个问题：运行时无法在控制台输入数据。愁。</p>
<p>解决办法：<br><code>Tools -&gt; Build System -&gt; New Build System</code> 新建编译系统。在新打开的窗口中替换为以下代码</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">cmd</span>": <span class="value">[<span class="string">"bash"</span>, <span class="string">"-c"</span>, <span class="string">"g++ '$&#123;file&#125;' -o '$&#123;file_path&#125;/$&#123;file_base_name&#125;' &amp;&amp; osascript -e 'tell application \"Terminal\" to activate do script \"clear&amp;&amp;$&#123;file_path&#125;/$&#123;file_base_name&#125; &amp;&amp; read -p \\\"Press Enter to exit.\\\"&amp;&amp;exit\"'"</span>]</span>,</span><br><span class="line">    "<span class="attribute">file_regex</span>": <span class="value"><span class="string">"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$"</span></span>,</span><br><span class="line">    "<span class="attribute">working_dir</span>": <span class="value"><span class="string">"$&#123;file_path&#125;"</span></span>,</span><br><span class="line">    "<span class="attribute">selector</span>": <span class="value"><span class="string">"source.c, source.c++"</span></span>,</span><br><span class="line"></span><br><span class="line">    "<span class="attribute">variants</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        &#123;</span><br><span class="line">            "<span class="attribute">name</span>": <span class="value"><span class="string">"Run"</span></span>,</span><br><span class="line">            "<span class="attribute">cmd</span>": <span class="value">[<span class="string">"bash"</span>, <span class="string">"-c"</span>, <span class="string">"g++ '$&#123;file&#125;' -o '$&#123;file_path&#125;/$&#123;file_base_name&#125;' &amp;&amp; '$&#123;file_path&#125;/$&#123;file_base_name&#125;'"</span>]</span><br><span class="line">        </span>&#125;</span><br><span class="line">    ]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>Command + s 保存，命名为MyC++。<br>在<code>Tools -&gt; Build System</code>选中<code>MyC++</code>。<br><code>Command + Shift + B</code>编译，选<code>MyC++</code>（不加Run的那个）。</p>
<p>搞定~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="安装sublime_text_3_插件"><strong>安装sublime text 3 插件</strong></h2><p><strong>1.安装 Package Control组件：</strong></p>
<ul>
<li>按 control+` (键盘上1左边的按钮)调出console控制台;</li>
<li>粘贴以下代码到底部命令行并回车:</li>
</ul>]]>
    
    </summary>
    
      <category term="MacOS" scheme="http://teveillan.com/tags/MacOS/"/>
    
      <category term="SublimeText" scheme="http://teveillan.com/tags/SublimeText/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5649 DZY Loves Sorting]]></title>
    <link href="http://teveillan.com/2016/03/26/HDU-5649-DZY-Loves-Sorting/"/>
    <id>http://teveillan.com/2016/03/26/HDU-5649-DZY-Loves-Sorting/</id>
    <published>2016-03-26T14:40:46.000Z</published>
    <updated>2016-03-26T14:42:01.000Z</updated>
    <content type="html"><![CDATA[<p>祭奠我因为一个坑被白白浪费的一天…</p>
<p>基础数据结构。线段树。区间更新，区间查询。</p>
<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5649" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5649</a></p>
<p>此题的难点在于，每次排序的时候，每个数在排序之后的位置不能一个一个来处理，这样复杂度肯定是不够的。</p>
<p>So, 我们枚举一个答案mid，这样对于所有的数，只用区分它是比mid大，还是比mid小，由此进行批量处理。</p>
<a id="more"></a>
<blockquote>
<ol>
<li>枚举mid。</li>
<li>每次操作开始，把初始位置上小于等于mid的位置标为1，剩下的标为0.</li>
<li>对于每次排序。（假如是升序）先进行区间查询[l, r]区间内1的个数num。 把[l, l+num-1]全更新为1，剩下的更新为0</li>
<li>查看第k位上是否为1。</li>
</ol>
</blockquote>
<p>可以肯定的一点是，经过m次排序之后，最后排序的结果不以我们枚举的mid而发生变化。</p>
<p>当我们第一次枚举mid = n的时候，在所有排序结束后，必然是所有位置上的数都为1.<br>当mid在逐渐变小的过程中，在排序结束后，某些位置上的数会由1变为0。<br>当第k位上恰好最后为1的时候，此时的mid值即为需要的答案。</p>
<p>当然，直接枚举也是会超时的，加个二分就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> L pos&lt;&lt;1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> R pos&lt;&lt;1|1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MID ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LL L, l, MID</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> RR R, MID+1, r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> node[N&lt;&lt;<span class="number">2</span>], lazy[N&lt;&lt;<span class="number">2</span>], v[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;pii, <span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    lazy[pos] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) node[pos] = (v[l] &lt;= value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        build(LL, value);</span><br><span class="line">        build(RR, value);</span><br><span class="line">        node[pos] = node[L] + node[R];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r || lazy[pos] == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    lazy[L] = lazy[R] = lazy[pos];</span><br><span class="line">    node[L] = lazy[pos] * (MID - l + <span class="number">1</span>);</span><br><span class="line">    node[R] = lazy[pos] * (r - MID);</span><br><span class="line">    lazy[pos] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;node[pos] = node[L] + node[R];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> node[pos];</span><br><span class="line">    push_down(pos, l, r);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= MID) ret += query(LL, ll, rr);</span><br><span class="line">    <span class="keyword">if</span>(rr &gt;  MID) ret += query(RR, ll, rr);</span><br><span class="line">    push_up(pos, l, r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= l &amp;&amp; r &lt;= rr) node[pos] = (r - l + <span class="number">1</span>) * value, lazy[pos] = value;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        push_down(pos, l, r);</span><br><span class="line">        <span class="keyword">if</span>(ll &lt;= MID) update(LL, ll, rr, value);</span><br><span class="line">        <span class="keyword">if</span>(rr &gt;  MID) update(RR, ll, rr, value);</span><br><span class="line">        push_up(pos, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> mid, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n, mid);</span><br><span class="line"></span><br><span class="line">    REP(i, vec.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = vec[i].first.first, r = vec[i].first.second, flag = vec[i].second;</span><br><span class="line">        <span class="keyword">int</span> num = query(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span> || num == r - l + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, l+num-<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l+num, r, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, r-num+<span class="number">1</span>, r, <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, r-num, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">1</span>, <span class="number">1</span>, n, k, k) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n, m, k, x, y, z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        FOR(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">        REP(i, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;z, &amp;x, &amp;y);</span><br><span class="line">            vec.pb(make_pair(pii(x, y), z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n, ans;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(solve(MID, n, m, k)) ans = MID, r = MID - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = MID + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>祭奠我因为一个坑被白白浪费的一天…</p>
<p>基础数据结构。线段树。区间更新，区间查询。</p>
<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5649">http://acm.hdu.edu.cn/showproblem.php?pid=5649</a></p>
<p>此题的难点在于，每次排序的时候，每个数在排序之后的位置不能一个一个来处理，这样复杂度肯定是不够的。</p>
<p>So, 我们枚举一个答案mid，这样对于所有的数，只用区分它是比mid大，还是比mid小，由此进行批量处理。</p>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5648 DZY Loves Math]]></title>
    <link href="http://teveillan.com/2016/03/25/HDU-5648-DZY-Loves-Math/"/>
    <id>http://teveillan.com/2016/03/25/HDU-5648-DZY-Loves-Math/</id>
    <published>2016-03-25T04:37:42.000Z</published>
    <updated>2016-03-25T04:43:20.000Z</updated>
    <content type="html"><![CDATA[<p>DZY Loves 系列…DZY大神你怎么什么都喜欢…</p>
<p>传送门: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5648" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5648</a></p>
<p>题意: 求$\sum_{i=1} ^ n \sum_{j=1} ^m gcd(i ~ AND ~j, i~ OR~ j) $, 1 &lt;= n, m &lt;= 15000</p>
<p>用三进制表示状态值, 每一位上的值:</p>
<ul>
<li>0: 表示均为0</li>
<li>1: 表示一个为0, 一个为1</li>
<li>2: 表示两个都为1 </li>
</ul>
<a id="more"></a>
<p>记 $ l = \log_2 {max(n, m)} $，则枚举量为$3^l$</p>
<p>每枚举一个状态值, 接下来便是求此状态的方案数目num, ans += num * gcd 。</p>
<p>记AND值为x,OR 值为 y,令z = x ^ y .</p>
<p>假设在每种方案下，i = a | x, j = b | x，很容易看出 a | b = a + b = z。<br>代入以下不等式：</p>
<blockquote>
<p>$ a + x &lt;= n $<br>$ b + x &lt;= m $</p>
</blockquote>
<p>化简以后得到</p>
<blockquote>
<p>$ z-m+x &lt;=  a &lt;= n-x $</p>
</blockquote>
<p>就是求 <strong>取z中二进制位为1的某些位组成a，且使a满足上面的不等式</strong> 的a的取值范围。</p>
<p>熟悉数位DP的朋友很容易就看出来接下的步骤了。运用数位DP求num值就好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> cur_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= cur_value) <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; __builtin_popcount(pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;l) &amp; pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;l) &lt;= cur_value) ret += dfs(pos^(<span class="number">1</span>&lt;&lt;l), l-<span class="number">1</span>, cur_value - (<span class="number">1</span>&lt;&lt;l));</span><br><span class="line">        ret += dfs(pos^(<span class="number">1</span>&lt;&lt;l), l-<span class="number">1</span>, cur_value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret += dfs(pos, l-<span class="number">1</span>, cur_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> max_value)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//数位DP,求在pos中选部分二进制为1的位组成a,且a&lt;=max_value的方案数</span></span><br><span class="line">    <span class="keyword">if</span>(max_value &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;len) &lt;= max_value) len++;</span><br><span class="line"></span><br><span class="line">    pos = pos &amp; ((<span class="number">1</span>&lt;&lt;len) - <span class="number">1</span>);<span class="comment">//把高位舍掉,反正也没用</span></span><br><span class="line">    <span class="keyword">int</span> ret = dfs(pos, len-<span class="number">1</span>, max_value);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;len) &lt;= n || (<span class="number">1</span>&lt;&lt;len) &lt;= m) len++;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        REP(i, len) s *= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        REP(i, s) &#123; <span class="comment">// 三进制枚举状态值</span></span><br><span class="line">            <span class="keyword">int</span> tmp = i, x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="comment">// x为and值, y为or值</span></span><br><span class="line">            REP(j, len) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp % <span class="number">3</span> == <span class="number">1</span>) y |= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tmp % <span class="number">3</span> == <span class="number">2</span>) x |= (<span class="number">1</span>&lt;&lt;j), y |= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                tmp /= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; n || x &gt; m) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> z = x ^ y;</span><br><span class="line">            <span class="keyword">int</span> value = get(z, n-x) - get(z, z-m+x-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span>) &#123; <span class="comment">//这里要注意.当x==0时, a 和 b 都不能为0</span></span><br><span class="line">                <span class="keyword">if</span>(z &lt;= n) --value;</span><br><span class="line">                <span class="keyword">if</span>(z &lt;= m) --value;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += __gcd(x, y) * max(value, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>DZY Loves 系列…DZY大神你怎么什么都喜欢…</p>
<p>传送门: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5648">http://acm.hdu.edu.cn/showproblem.php?pid=5648</a></p>
<p>题意: 求$\sum_{i=1} ^ n \sum_{j=1} ^m gcd(i ~ AND ~j, i~ OR~ j) $, 1 &lt;= n, m &lt;= 15000</p>
<p>用三进制表示状态值, 每一位上的值:</p>
<ul>
<li>0: 表示均为0</li>
<li>1: 表示一个为0, 一个为1</li>
<li>2: 表示两个都为1 </li>
</ul>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5296 Annoying problem]]></title>
    <link href="http://teveillan.com/2015/12/16/HDU-5296-Annoying-problem/"/>
    <id>http://teveillan.com/2015/12/16/HDU-5296-Annoying-problem/</id>
    <published>2015-12-16T14:39:30.000Z</published>
    <updated>2015-12-16T14:40:15.000Z</updated>
    <content type="html"><![CDATA[<p>最初以为是DP，结果发现并不是。= =</p>
<p>题意：在一棵树上，边有权重。有两种操作：</p>
<ol>
<li>如果v不在集合中，那么将点v放入到集合</li>
<li>如果v在集合中，那么将v移出集合<br>求每次操作后，选择一些边将集合中的点连在一起，问边权和为多少。</li>
</ol>
<p>先初始化dfs序，以及跟节点到点x的距离dis。每当我们要插入一个点x，找到在集合中且dfs序比x第一个大的点u，以及第一个小的点v。则新增的边的边权为<br>$$dis[x]−dis[lca(x,u)]−dis[lca(x,v)]+dis[lca(u,v)]$$</p>
<a id="more"></a>
<p>如果没有dfs序比v大或者比v小的点，则u v分别取集合中dfs序最大和最小的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; head[N];</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N], deep[N], dis[N], fa[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pre, <span class="keyword">int</span> &amp;t)</span> </span>&#123; <span class="comment">//初始化dfs序，以及fa(在线求lca)</span></span><br><span class="line">    dfn[cur] = ++t;</span><br><span class="line">    deep[cur] = deep[pre] + <span class="number">1</span>;</span><br><span class="line">    fa[cur][<span class="number">0</span>] = pre;</span><br><span class="line">    FOR(i, <span class="number">1</span>, <span class="number">19</span>) fa[cur][i] = fa[ fa[cur][i-<span class="number">1</span>] ][i-<span class="number">1</span>];</span><br><span class="line">    REP(i, head[cur].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = head[cur][i].first, c = head[cur][i].second;</span><br><span class="line">        <span class="keyword">if</span>(to != pre) &#123;</span><br><span class="line">            dis[to] = dis[cur] + c;</span><br><span class="line">            dfs(to, cur, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">int</span> tmp = deep[u] - deep[v];</span><br><span class="line">    REP(i, <span class="number">20</span>) <span class="keyword">if</span>(tmp &amp; (<span class="number">1</span> &lt;&lt; i)) u = fa[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    DWN(i, <span class="number">19</span>, <span class="number">0</span>) <span class="keyword">if</span>(fa[u][i] != fa[v][i])</span><br><span class="line">        u = fa[u][i], v = fa[v][i];</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">    visit[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(M.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        M[dfn[x]] = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it1, it2;</span><br><span class="line">    it1 = M.lower_bound(dfn[x]), it2 = it1;</span><br><span class="line">    <span class="keyword">if</span>(it1 == M.begin() || it1 == M.end()) it1 = M.begin(), it2 = M.end();</span><br><span class="line">    it2--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u = it1-&gt;second, v = it2-&gt;second;</span><br><span class="line">    ans += dis[x] - dis[lca(u, x)] - dis[lca(v, x)] + dis[lca(u, v)];</span><br><span class="line">    M[dfn[x]] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">    visit[x] = <span class="number">0</span>;</span><br><span class="line">    M.erase(dfn[x]);</span><br><span class="line">    <span class="keyword">if</span>(M.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it1, it2;</span><br><span class="line">    it1 = M.lower_bound(dfn[x]), it2 = it1;</span><br><span class="line">    <span class="keyword">if</span>(it1 == M.begin() || it1 == M.end()) it1 = M.begin(), it2 = M.end();</span><br><span class="line">    it2--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u = it1-&gt;second, v = it2-&gt;second;</span><br><span class="line">    ans -= dis[x] - dis[lca(u, x)] - dis[lca(v, x)] + dis[lca(u, v)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, casnum, u, v, c, t, casid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        FOR(i, <span class="number">1</span>, n) head[i].clear();</span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">            head[u].pb(pii(v, c));</span><br><span class="line">            head[v].pb(pii(u, c));</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>, t);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++casid);</span><br><span class="line">        M.clear();</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(u == <span class="number">1</span> &amp;&amp; !visit[v]) add(v, ans);</span><br><span class="line">            <span class="keyword">if</span>(u == <span class="number">2</span> &amp;&amp; visit[v]) del(v, ans);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>最初以为是DP，结果发现并不是。= =</p>
<p>题意：在一棵树上，边有权重。有两种操作：</p>
<ol>
<li>如果v不在集合中，那么将点v放入到集合</li>
<li>如果v在集合中，那么将v移出集合<br>求每次操作后，选择一些边将集合中的点连在一起，问边权和为多少。</li>
</ol>
<p>先初始化dfs序，以及跟节点到点x的距离dis。每当我们要插入一个点x，找到在集合中且dfs序比x第一个大的点u，以及第一个小的点v。则新增的边的边权为<br>$$dis[x]−dis[lca(x,u)]−dis[lca(x,v)]+dis[lca(u,v)]$$</p>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5293 Tree chain problem]]></title>
    <link href="http://teveillan.com/2015/11/23/HDU-5293-Tree-chain-problem/"/>
    <id>http://teveillan.com/2015/11/23/HDU-5293-Tree-chain-problem/</id>
    <published>2015-11-23T15:39:29.000Z</published>
    <updated>2015-11-23T15:40:15.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5293" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5293</a></p>
<p>题目大意：有个N的点的树。其中树上有M条已知的链，每条链有一个权值。从中选出任意个不相交的链使得链的权值和最大。</p>
<p>树形DP。<br>我们用dp[i]表示以i点为根的子树的最优解。<br>用sum[i]表示以i点为根的子树中不选i点的最优解，即$sum[i]=\sum dp[k] $  (k为i的儿子节点)</p>
<a id="more"></a>
<p>其中dp[i]不一定是一定要选取i点,因此，dp[i]也有可能等于sum[i]。</p>
<p>我们假设出一种情况，一颗以root为根的树，有一条链link: root -&gt; a -&gt; b ， 权值为x。<br>在知道除了root之外其他所有点的dp值及sum值已知的情况下，求出选取这条链情况下的root的dp值。</p>
<p>首先，sum[root]是可以求的。那么</p>
<blockquote>
<p>$$ dp[root] = sum[root] - dp[a] + sum[a] - dp[b]+ sum[b] + x $$</p>
</blockquote>
<p>(联系sum的定义理解这个式子)</p>
<p>理解以后这道题就迎刃而解了，无非就是求一次lca，然后对于如何快速在树上求一条链的sum和以及dp和做一次优化而已，用时间戳或者树链剖分的方法都好。</p>
<p>我这里用的时间戳加树状数组来进行优化的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CLR(arr) memset(arr, 0, sizeof(arr))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> node[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> value, <span class="keyword">int</span> n, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        node[flag][x] += value;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        ret += node[flag][x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VI head[N], vec[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; lca[N], qhead[N];</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    visit[cur] = <span class="number">1</span>;</span><br><span class="line">    REP(i, head[cur].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = head[cur][i];</span><br><span class="line">        <span class="keyword">if</span>(visit[to]) <span class="keyword">continue</span>;</span><br><span class="line">        LCA(to, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    REP(i, qhead[cur].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = qhead[cur][i].first, x = qhead[cur][i].second;</span><br><span class="line">        <span class="keyword">if</span>(visit[to]) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = find(to);</span><br><span class="line">            lca[tmp].pb(pii(cur, to));</span><br><span class="line">            vec[tmp].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[cur] = pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l[N], r[N];</span><br><span class="line"><span class="keyword">int</span> dp[N], sum[N];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    visit[cur] = <span class="number">1</span>;</span><br><span class="line">    l[cur] = ++t;</span><br><span class="line">    REP(i, head[cur].size()) &#123;</span><br><span class="line">         <span class="keyword">int</span> to = head[cur][i];</span><br><span class="line">         <span class="keyword">if</span>(visit[to]) <span class="keyword">continue</span>;</span><br><span class="line">         dfs(to, n);</span><br><span class="line">         sum[cur] += dp[to];</span><br><span class="line">    &#125;</span><br><span class="line">    REP(i, lca[cur].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = lca[cur][i].first, v = lca[cur][i].second, x = vec[cur][i];</span><br><span class="line">        <span class="keyword">int</span> tmp = sum[cur] + query(l[u], <span class="number">0</span>) + query(l[v], <span class="number">0</span>) - query(l[u], <span class="number">1</span>) - query(l[v], <span class="number">1</span>) + x;</span><br><span class="line">        dp[cur] = max(tmp, dp[cur]);</span><br><span class="line">    &#125;</span><br><span class="line">    r[cur] = ++t;</span><br><span class="line">    dp[cur] = max(dp[cur], sum[cur]);</span><br><span class="line">    update(l[cur], sum[cur], n*<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    update(r[cur], -sum[cur], n*<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    update(l[cur], dp[cur], n*<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    update(r[cur], -dp[cur], n*<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n, m, u, v, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">         CLR(node);</span><br><span class="line">         FOR(i, <span class="number">1</span>, n) head[i].clear(), qhead[i].clear(), lca[i].clear(), vec[i].clear();</span><br><span class="line">         FOR(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">         REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            head[u].pb(v);</span><br><span class="line">            head[v].pb(u);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         REP(i, m) &#123;</span><br><span class="line">             <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;x);</span><br><span class="line">             qhead[u].pb(pii(v, x));</span><br><span class="line">             qhead[v].pb(pii(u, x));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">         <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">         t = <span class="number">0</span>;</span><br><span class="line">         CLR(visit);</span><br><span class="line">         LCA(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">         CLR(visit);</span><br><span class="line">         dfs(<span class="number">1</span>, n);</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5293">http://acm.hdu.edu.cn/showproblem.php?pid=5293</a></p>
<p>题目大意：有个N的点的树。其中树上有M条已知的链，每条链有一个权值。从中选出任意个不相交的链使得链的权值和最大。</p>
<p>树形DP。<br>我们用dp[i]表示以i点为根的子树的最优解。<br>用sum[i]表示以i点为根的子树中不选i点的最优解，即$sum[i]=\sum dp[k] $  (k为i的儿子节点)</p>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5291 Candy Distribution]]></title>
    <link href="http://teveillan.com/2015/11/22/HDU-5291-Candy-Distribution/"/>
    <id>http://teveillan.com/2015/11/22/HDU-5291-Candy-Distribution/</id>
    <published>2015-11-22T11:11:35.000Z</published>
    <updated>2015-11-22T11:15:22.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5291" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5291</a></p>
<p>题目大概意思就是有K种物品，第i种物品有ai个，要把全部的物品分成两堆，每个物品可以用也可以不用， 问最后两边物品数量一样多的方案数。</p>
<p>最直接的思路，定义dp[i][j]表示第i堆分完后第一个人比第二个人多j个糖果的方案数。枚举分第i堆糖果时第一个人比第二个人多分x个，则</p>
<blockquote>
<p>$$dp[i][j+x] += dp[i-1][j] * ( (a[i] - x) / 2 + 1 ) $$</p>
</blockquote>
<a id="more"></a>
<p>直接这么做的复杂度为$O(n^4)$，会超时。我们进行一次优化。</p>
<p>随着x的变化，$(a[i] - x) / 2 + 1$这个值根据奇偶性划分可分成两个等差数列。根据这个来进行处理，最后复杂度为O(n^3)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; VS;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; VD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40010</span>;</span><br><span class="line">LL dp[<span class="number">2</span>][N];</span><br><span class="line">LL sum[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> flag, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sum[min(id, mid&lt;&lt;<span class="number">1</span>)][flag];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> mid = n * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">        dp[cur][mid] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            LL x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            cur ^= <span class="number">1</span>, pre ^= <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memset</span>(dp[cur], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[cur]));</span><br><span class="line"></span><br><span class="line">            sum[<span class="number">0</span>][<span class="number">0</span>] = dp[pre][<span class="number">0</span>];</span><br><span class="line">            sum[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            FOR(i, <span class="number">1</span>, mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = i &amp; <span class="number">1</span>;</span><br><span class="line">                sum[i][flag] = (sum[i-<span class="number">1</span>][flag] + dp[pre][i]) % MOD;</span><br><span class="line">                sum[i][flag^<span class="number">1</span>] = sum[i-<span class="number">1</span>][flag^<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LL res = <span class="number">0</span>;</span><br><span class="line">            FOR(i, <span class="number">0</span>, x) res = (res + (x - i + <span class="number">2</span>) / <span class="number">2</span> * dp[pre][i]) % MOD;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                FOR(i, <span class="number">0</span>, mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> flag = i &amp; <span class="number">1</span>;</span><br><span class="line">                    dp[cur][i] = res;</span><br><span class="line">                    res = (res + get(i + x + <span class="number">1</span>, flag, mid) - get(i, flag, mid)) % MOD;</span><br><span class="line">                    res = (res - (get(i, flag^<span class="number">1</span>, mid) - get(i - x - <span class="number">1</span>, flag^<span class="number">1</span>, mid))) % MOD;</span><br><span class="line">                    res = (res + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                FOR(i, <span class="number">0</span> , mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> flag = i &amp; <span class="number">1</span>;</span><br><span class="line">                    dp[cur][i] = res;</span><br><span class="line">                    res = (res + get(i + x + <span class="number">1</span>, flag^<span class="number">1</span>, mid) - get(i, flag^<span class="number">1</span>, mid)) % MOD;</span><br><span class="line">                    res = (res - (get(i, flag, mid) - get(i - x - <span class="number">1</span>, flag, mid))) % MOD;</span><br><span class="line">                    res = (res + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[cur][mid] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5291">http://acm.hdu.edu.cn/showproblem.php?pid=5291</a></p>
<p>题目大概意思就是有K种物品，第i种物品有ai个，要把全部的物品分成两堆，每个物品可以用也可以不用， 问最后两边物品数量一样多的方案数。</p>
<p>最直接的思路，定义dp[i][j]表示第i堆分完后第一个人比第二个人多j个糖果的方案数。枚举分第i堆糖果时第一个人比第二个人多分x个，则</p>
<blockquote>
<p>$$dp[i][j+x] += dp[i-1][j] * ( (a[i] - x) / 2 + 1 ) $$</p>
</blockquote>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5290 Bombing plan]]></title>
    <link href="http://teveillan.com/2015/11/19/HDU-5290-Bombing-plan/"/>
    <id>http://teveillan.com/2015/11/19/HDU-5290-Bombing-plan/</id>
    <published>2015-11-19T08:07:43.000Z</published>
    <updated>2015-11-22T11:13:51.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5290" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5290</a></p>
<p>官方题解已经说的很详细了。我也引用一下官方题解吧（有修改，加重部分）。</p>
<blockquote>
<p> DP,定义两个数组$F[I][J]$,$G[I][J]$。<br> $F[I][J]$表示以第i个点为根的子树上的点被全部破坏掉，并且还能向上破坏掉<strong>不少于</strong>j个距离，满足这样条件需要选取的最小点数；<br> $G[I][J]$表示以第i个点为根的子树上的点被未被全部破坏，且未被破坏的点中距离i最远的点距离为<strong>不超过</strong>j，满足这样条件需要选取的最小点数。<br><a id="more"></a></p>
</blockquote>
<p>那么可以写出dp方程:<br>$$G[I][J]=min(G[L][0],G[L][1],…,G[L][J-1]) $$<br>L 代表所有儿子。</p>
<p>$$F[I][J] = F[K][J+1]+G[L][J]$$<br>$$F[I][J] = min(F[I][j], F[I][J+1])$$<br>式子中加号左边的意思是i节点必须存在一个儿子K，选取F[K][J+1]这个值。加号右边的式子表示除K以外其他儿子L的取值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">111</span>], f[N][<span class="number">111</span>];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line">VI head[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    FOR(i, <span class="number">0</span>, <span class="number">101</span>) dp[cur][i] = <span class="number">0</span>, f[cur][i] = (i&lt;=w[cur]?<span class="number">1</span>:<span class="number">1e6</span>); </span><br><span class="line">    <span class="comment">//分别初始化取和不取时候的初始值。后面就没必要分步讨论了。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to: head[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(to == pre) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to, cur);</span><br><span class="line"></span><br><span class="line">        DWN(i, <span class="number">100</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            f[cur][i] = min(f[cur][i] + dp[to][i-<span class="number">1</span>], dp[cur][i] + f[to][i+<span class="number">1</span>]);</span><br><span class="line">            f[cur][i] = min(f[cur][i], f[cur][i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[cur][<span class="number">0</span>] = min(f[cur][<span class="number">0</span>] + f[to][<span class="number">0</span>], dp[cur][<span class="number">0</span>] + f[to][<span class="number">1</span>]);</span><br><span class="line">        f[cur][<span class="number">0</span>] = min(f[cur][<span class="number">0</span>], f[cur][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        dp[cur][<span class="number">0</span>] = min(f[cur][<span class="number">0</span>], dp[cur][<span class="number">0</span>] + f[to][<span class="number">0</span>]);</span><br><span class="line">        FOR(i, <span class="number">1</span>, <span class="number">100</span>) &#123;</span><br><span class="line">            dp[cur][i] = min(dp[cur][i-<span class="number">1</span>], dp[cur][i] + dp[to][i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        FOR(i, <span class="number">1</span>, n) head[i].clear();</span><br><span class="line">        FOR(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> x, y;</span><br><span class="line">             <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">             head[x].pb(y);</span><br><span class="line">             head[y].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5290">http://acm.hdu.edu.cn/showproblem.php?pid=5290</a></p>
<p>官方题解已经说的很详细了。我也引用一下官方题解吧（有修改，加重部分）。</p>
<blockquote>
<p> DP,定义两个数组$F[I][J]$,$G[I][J]$。<br> $F[I][J]$表示以第i个点为根的子树上的点被全部破坏掉，并且还能向上破坏掉<strong>不少于</strong>j个距离，满足这样条件需要选取的最小点数；<br> $G[I][J]$表示以第i个点为根的子树上的点被未被全部破坏，且未被破坏的点中距离i最远的点距离为<strong>不超过</strong>j，满足这样条件需要选取的最小点数。<br>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习笔记---线性回归(Linear Regression)]]></title>
    <link href="http://teveillan.com/2015/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-Linear-Regression/"/>
    <id>http://teveillan.com/2015/07/28/机器学习笔记-线性回归-Linear-Regression/</id>
    <published>2015-07-28T12:36:26.000Z</published>
    <updated>2015-11-18T14:19:04.000Z</updated>
    <content type="html"><![CDATA[<p>作为机器学习的第一课，深刻理解线性回归将<strong>非常</strong>有助于我们学习后面的课程。</p>
<p>在上篇文章中我们将机器学习分为监督学习和非监督学习，线性回归就属于监督学习算法的一种。</p>
<p>依然拿上一章讲的房价预测作为我们学习线性回归的例子。<br>我们说过，影响房价的因素可能有很多种，如：房屋大小、周围均价、使用年限等等。<br>我们将这么一种因素称之为<strong>特征（Feature）</strong>。<br>对于每一组数据的每个特征值我们分别记为$x_1,x_2,x_3$…$x_n$，n为特征数。</p>
<a id="more"></a>
<p>则我们建立一个数学模型，也就是假说（Hypothesis）为：</p>
<blockquote>
<p>$$h(x) = \sum_{i=0}^n \theta_ix_i = \theta^Tx$$</p>
</blockquote>
<p>这里的$\theta$即为假说的参数，我们赋予它一个初始值，然后再在机器学习的过程中不断调整。（所以说机器学习的过程其实也就是个调参的过程）</p>
<p>至于有n个特征，i为什么从0开始，我们后面再讲。</p>
<h2 id="1-1_单变量线性回归(Linear_Regression_with_One_Variable)">1.1 单变量线性回归(Linear Regression with One Variable)</h2><p>最开始，我们假设影响房价的因素就一个：房屋面积。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Size in feet$^2$(x)</th>
<th style="text-align:center">Price in 1000’s(y)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">852</td>
<td style="text-align:center">178</td>
</tr>
<tr>
<td style="text-align:center">1534</td>
<td style="text-align:center">315</td>
</tr>
<tr>
<td style="text-align:center">1416</td>
<td style="text-align:center">232</td>
</tr>
<tr>
<td style="text-align:center">2104</td>
<td style="text-align:center">460</td>
</tr>
</tbody>
</table>
<p>则对于一组参数$\theta$,我们Hypothesis定义为：</p>
<blockquote>
<p>$$h_\theta(x) = \theta_0 + \theta_1x_1$$</p>
</blockquote>
<p>$\theta_0$是我们加的一个辅助变量，没有实际意义。为了规范，我们令$x_0 = 1$，则：</p>
<blockquote>
<p>$$ h_\theta(x) = \theta_0x_0 + \theta_1x_1  = \sum_{i=0}^n\theta_ix_i = \theta^Tx $$</p>
</blockquote>
<h2 id="1-2_成本函数(CostFunction)">1.2 成本函数(CostFunction)</h2><p>如何衡量这一组参数的好坏呢？计算它预测结果的误差大小就好了。<br>在课程中，我们用$J(\theta)$来表示一组$\theta$的Cost。</p>
<blockquote>
<p>$$ J(\theta) = \frac{1}{2m} \sum_{i=0}^{m} Cost(x^{(i)}, y^{(i)}) = \frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)})    - y^{(i)})^2   $$ </p>
</blockquote>
<p>有了成本函数，也就知道如何衡量$(\theta_0,\theta_1)$的好坏。剩下的只用调整$\theta$使得$J(\theta)$最小就好了。</p>
<h2 id="1-3_梯度下降(Gradient_descent)">1.3 梯度下降(Gradient descent)</h2><p>如何最小化 $J(\theta)$？</p>
<p>我们首先来直观地感受一下对于不同的$(\theta_0,\theta_1)$，$J(\theta)$的大小是怎么变化的。</p>
<img title="machine-learning" alt="machine-learning" src="http://7tszmu.com1.z0.glb.clouddn.com/images/teveillan/images/machine-learning2-1.png?imageView2/2/w/600">
<p>如果我们最初设定的$\theta$使得$J(\theta)$恰好在山谷的位置，则皆大欢喜，此时的$J(\theta)$就是最小值，是最优解。</p>
<p>如果不幸选在山峰的位置，那么我们就要对$\theta$一点一点进行修改，使得$J(\theta)$一步一步走向山谷。这种一步一步修改$\theta$使得$J(\theta)$逐步走下山的过程我们称之为<strong>梯度下降</strong>，下降$J(\theta)$的值。</p>
<p>就像下图：</p>
<img title="machine-learning" alt="machine-learning" src="http://7tszmu.com1.z0.glb.clouddn.com/images/teveillan/images/machine-learning2-1.png?imageView2/2/w/600">
<p>怎么下降？</p>
<p>想要下降，首先得确定下降的方向。然后确定下降的幅度。</p>
<p>从数学上讲，假如我们确定了下降的幅度$\lambda$，则对于每个$\theta$，最佳的下降值为：</p>
<blockquote>
<p>$$ \theta_j :=  \theta_j - \lambda \frac{\delta J(\theta)}{\delta \theta_j} $$</p>
<p>$$ \frac{\delta J(\theta)} {\delta \theta_j} =  \frac{1}{m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} $$</p>
</blockquote>
<p>所以展开就是：</p>
<blockquote>
<p>$$ \theta_j :=  \theta_j - \lambda  \frac{1}{m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)}    $$</p>
</blockquote>
<p>就这样，一步一步更新$\theta$，使得$J(\theta)$一步一步变小。<br>到什么时候停止?</p>
<p>我们比较更新前后的$J(\theta)$, 当更新后的$J(\theta)$比较小时，肯定是可以更新的。<br>但是当更新后的$J(\theta)$比较大的时候，也不代表不能更新。<br>我们知道，在我们更新$\theta$的时候，有两个因素，一个是幅度（$\lambda$），一个是方向。<br>如果更新后的$J(\theta)$比较大，也有可能是更新的幅度比较大，一步迈过了谷底。这时候，我们需要减小$\lambda$来试试。</p>
<h3 id="NOTICE">NOTICE</h3><p>1.更新$\theta$的时候是所有$\theta$一起更新的。<br>虽然对于每个$\theta$的导数值是一个一个计算的，但是更新的时候是最后一起更新。<br>如果是计算一个导数值更新一个$\theta$，我们会发现，由于我们先更新了$\theta_1$，再计算$\frac{\delta J(\theta)} {\theta_2}$的值就和预期的不符了。</p>
<p>2.对于不同的初始$\theta$，我们最终走到的谷底的位置也可能不同。<br>也就是说，我们最终计算的最小值可能只是局部最小值，而不是全局最小值。</p>
<h2 id="1-4学习算法">1.4学习算法</h2><p>当我们有了任意一个初始的$\theta$，有了梯度下降算法。<br>接下来就是用梯度下降算法不断递归更新$\theta$就好了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为机器学习的第一课，深刻理解线性回归将<strong>非常</strong>有助于我们学习后面的课程。</p>
<p>在上篇文章中我们将机器学习分为监督学习和非监督学习，线性回归就属于监督学习算法的一种。</p>
<p>依然拿上一章讲的房价预测作为我们学习线性回归的例子。<br>我们说过，影响房价的因素可能有很多种，如：房屋大小、周围均价、使用年限等等。<br>我们将这么一种因素称之为<strong>特征（Feature）</strong>。<br>对于每一组数据的每个特征值我们分别记为$x_1,x_2,x_3$…$x_n$，n为特征数。</p>]]>
    
    </summary>
    
      <category term="Tech" scheme="http://teveillan.com/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习笔记—机器学习简介]]></title>
    <link href="http://teveillan.com/2015/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/"/>
    <id>http://teveillan.com/2015/07/01/机器学习笔记—机器学习简介/</id>
    <published>2015-07-01T12:14:03.000Z</published>
    <updated>2015-11-18T14:18:41.000Z</updated>
    <content type="html"><![CDATA[<p>一直以来都想学习机器学习，但是苦于找不到好的入门书籍或者教学视频（Andrew NG的斯坦福公开课没有练习），直到发现了这个:</p>
<blockquote>
<p><a href="https://www.coursera.org/learn/machine-learning/home/welcome" target="_blank" rel="external">https://www.coursera.org/learn/machine-learning/home/welcome</a></p>
</blockquote>
<p>虽然也是Andrew NG老师的，不过是在Coursera上的，相对于课堂上的录制视频，这个用PPT来讲更直观，视频中间会有问答检测关键知识点是否理解正确，强制性要求的课后作业虽然不难，但确实能加深理解。比起只看书或者只看公开课，优点不用多说。</p>
<p>由于本人也是初学者，所以各位客官在看得时候务必以教学视频和自己的理解为主，若发现有问题的地方欢迎指正共同学习。<br><a id="more"></a></p>
<p>=========================分隔符=============================</p>
<p>Machine Learning Week1</p>
<p>首先，从什么是机器学习开始说起。<br>这里我们要引用一下台大林轩田老师《机器学习基石》的一幅图：</p>
<img title="machine-learning1-1" alt="图片说明" ‘class="class1" src="http://7tszmu.com1.z0.glb.clouddn.com/images/teveillan/images/machine-learning1-1.png?imageView2/2/w/600">
<ul>
<li>$X$：训练数据的输入部分</li>
<li>$y$：训练数据的输出部分</li>
<li>$D$：训练数据集，表现为$（X_i, Y_i）$的形式</li>
<li>$H$：假说Hypothesis，表示对问题分析后得到的数学模型</li>
<li>$A$：学习方法</li>
</ul>
<blockquote>
<p>在机器学习中，对于一类问题，我们先加以分析，得到对于一组输入应该怎样处理的数学模型$H$，数学模型中有各种各样的参数$\theta$。<br>此时，我们知道应该有哪些参数，但是不知道参数具体值为多少，于是借助学习方法$A$以及训练数据$D$，我们不断修改参数，使得对于以后的预测数据，能得到一个相对符合实际的结果。<br>因此，机器学习就是一个提出假说$H$，并用学习方法$A$不断优化$\theta$的过程。</p>
</blockquote>
<p>在课程中，Andrew NG将机器学习分为两种：</p>
<ol>
<li>监督性学习(Supervised Learning)</li>
<li>非监督性学习(Unsupervised Learning)，也称聚类算法</li>
</ol>
<p>而这两种分类的主要依据是，当我们在训练学习机器的时候，每组数据是否有标准答案。<br>这样说可能不严谨，我还是拿例子来说。</p>
<p>在常规的训练一个机器学习的算法过程中，我们大多有一些训练数据，在不断喂(feed)学习机器的过程中，学习机器不断调整自己内部的各项参数，使得当机器学习训练完毕，我们拿实际需要预测的数据喂给机器学习算法，能得到一个比较符合实际情况的值。</p>
<p>然而，这种预期的值确是有区别的。</p>
<ol>
<li><p>监督性学习：我们想预测房价，我们需要把房屋的大小、地理位置、规格等数据喂给学习机器，我们能得到一个预测的价格的值。在训练这种学习机器的过程中，我们在喂这组数据之前就已经知道了这组数据的标准答案，假如得到的答案和标准答案不符，我们希望修改参数来使得得到的答案尽可能像标准答案靠拢，这叫做监督。</p>
</li>
<li><p>非监督性学习：也称它聚类算法。如给邮件分类，在我们训练学习机器给喂数据的过程中，我们根本不知道这组数据应该准确地分为哪一类，甚至不知道应该有哪些类别有多少类别，我们仅能依靠训练数据之间的相关性将他们分为几类。 既然没有标准答案，监督自然也无从说起。</p>
</li>
</ol>
<p>简介就到这，线性回归我们拿到下一章统一讲。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直以来都想学习机器学习，但是苦于找不到好的入门书籍或者教学视频（Andrew NG的斯坦福公开课没有练习），直到发现了这个:</p>
<blockquote>
<p><a href="https://www.coursera.org/learn/machine-learning/home/welcome">https://www.coursera.org/learn/machine-learning/home/welcome</a></p>
</blockquote>
<p>虽然也是Andrew NG老师的，不过是在Coursera上的，相对于课堂上的录制视频，这个用PPT来讲更直观，视频中间会有问答检测关键知识点是否理解正确，强制性要求的课后作业虽然不难，但确实能加深理解。比起只看书或者只看公开课，优点不用多说。</p>
<p>由于本人也是初学者，所以各位客官在看得时候务必以教学视频和自己的理解为主，若发现有问题的地方欢迎指正共同学习。<br>]]>
    
    </summary>
    
      <category term="Tech" scheme="http://teveillan.com/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]部署MAC上的Sublime Text+LaTeX中文环境]]></title>
    <link href="http://teveillan.com/2015/05/11/%E8%BD%AC-%E9%83%A8%E7%BD%B2MAC%E4%B8%8A%E7%9A%84Sublime-Text-LaTex%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/"/>
    <id>http://teveillan.com/2015/05/11/转-部署MAC上的Sublime-Text-LaTex中文环境/</id>
    <published>2015-05-11T06:35:22.000Z</published>
    <updated>2015-05-11T06:39:19.000Z</updated>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.readern.com/sublime-text-latex-chinese-under-mac.html" target="_blank" rel="external">http://www.readern.com/sublime-text-latex-chinese-under-mac.html</a><br>作者：Read ERN</p>
<p>LaTex就不多做介绍了，其实一般人用到的机会也不多（包括我）。只是这段时间在Coursera上新课程的时候，偶尔需要，所以从零开始摸索了一下，也顺便进一步发现了Sublime Text的强大。</p>
<p>MAC上的LaTex部署，一般是两条思路，一个是直接安装MacTex，自带编写环境什么的；另一个是Sublime Text（或者Textmate等其他编辑器）+LaTexTools插件。方式二其实也是需要依赖MacTex的，但相对来说体量小、不需要经常切换编辑器，所以果断的介绍方式二。</p>
<p>亲测：MacOS 10.10, Sublime Text 3可用。（2015年5月）</p>
<a id="more"></a>
<h3 id="安装步骤">安装步骤</h3><ol>
<li>首先需要安装Sublime Text 3和<a href="https://packagecontrol.io/installation" target="_blank" rel="external">Package Control</a>，这个有大把的帖子。</li>
<li>MacTex现在是一个2G+的大包子，其实里面很多东西我们不需要，所以本着节约精神，我们安装<a href="http://mirror.ctan.org/systems/mac/mactex/mactex-basic.pkg" target="_blank" rel="external">MacTex_Basic</a>包就行了，现在的版本大概是100M以内。这个安装也是傻瓜的。</li>
<li>在Sublime Text里<code>Command+Shift+P</code>调出命令窗口，输入<code>Install</code>，之后选择LaTexTools，网络OK的话，很快就完成了插件安装。</li>
<li>LaTexTools插件会在编译你的Tex文件后，调用Skim这个PDF阅读器打开编译出的PDF文件，因此你还需要安装<a href="http://skim-app.sourceforge.net/" target="_blank" rel="external">Skim</a>.</li>
<li>运行一下Skim，进入<code>偏好设置——同步</code>，在<code>PDF-Tex同步支持</code>那里选择<code>Sublime Text</code>。这样，当你在Sublime Text里修改tex文件时，Skim预览也会相应变更。</li>
<li>完成上面所有步骤，其实就已经搭建完成基本环境。创建一个test.tex文档，贴上我后面附的测试代码，保存一下。(原Po说这里可以开始编译了，亲测是不行的，等完成第七步再编译。)</li>
<li>让我们最后来修改编译和中文环境:<br>打开编辑<code>~/Library/Application\ Support/Sublime\ Text/Packages/Users/LaTeXTools.sublime-settings</code>，将其中”builder”条目改为：<br><code>&quot;builder&quot;: &quot;simple&quot;</code><br>接着打开编辑<code>~/Library/Application\ Support/Sublime\ Text\ 3/Packages/LaTeXTools/builders/simpleBuilder.py</code><br>找到其中大概第41行<br><code>pdflatex = [&quot;dflatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-synctex=1&quot;]</code><br>修改为<br><code>pdflatex = [&quot;xelatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-synctex=1&quot;]</code><br>保存后关闭，<code>Command + B</code>编译一下，一切OK！</li>
</ol>
<p><strong>补充</strong>:<br>配置好后，如果编译的时候提示:</p>
<blockquote>
<p>LaTeXTools: you need to migrate your preferences. See the README file for instructions.</p>
</blockquote>
<p>调出命令窗口(<code>Command+Shift+P</code>), 输入如下命令: <code>LaTeXTools: Reconfigure and migrate setting</code>.</p>
<p>最后再给一个个性化设置。上面写了，LaTeXTools默认调用Skim，这一方面是因为LaTeXTools是跨平台的插件，Skim也同样跨平台开源，另一方面Skim确实对LaTeX的PDF支持很好。但是用OS X的网友们其实还有个选择，就是调用系统默认的PDF程序来打开编译后的成果，特别是“预览”还是很好用的。目前LaTeXTools的开发者还没有给出设置方法，所以，仍然要靠改代码：<br>修改<code>~/Library/Application\ Support/Sublime\ Text\ 3/Packages/LaTeXTools/jumpToPDF.py</code>, 将其中<code>if plat == &#39;darwin&#39;:</code> 之后开始的两段直接注释掉，替换为：<br><code>subprocess.Popen([‘open’] + [pdffile])</code><br>同样保存后就生效啦。目前用起来，系统自带的预览还是能满足我的需求滴。</p>
<p>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;&#10;\usepackage&#123;fontspec, xunicode, xltxtra&#125;  &#10;\setmainfont&#123;Hiragino Sans GB&#125;  &#10;&#10;\title&#123;Title&#125;&#10;\author&#123;&#125;&#10;&#10;\begin&#123;document&#125;&#10;&#10;\maketitle&#123;&#125;&#10;&#10;\section&#123;Introduction&#125;&#10;&#10;This is where you will write your content. &#22312;&#36825;&#37324;&#20889;&#19978;&#20869;&#23481;&#12290;&#10;&#10;\end&#123;document&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LaTex的其他选择">LaTex的其他选择</h3><p>如果只是偶尔需要输入公式，这里介绍一个在线的LaTex公式编辑器<a href="http://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="external">http://www.codecogs.com/latex/eqneditor.php</a></p>
<p>有iPad的，你们有福了，还有个手写公式后自动识别、生成LaTex公式的App：<a href="https://itunes.apple.com/us/app/myscript-mathpad-handwriting/id674996719?mt=8" target="_blank" rel="external">Script MathPad</a>。简单的使用已经足够了，如果需要经常使用，导出功能需要内购（4.99刀）。顺便说一句，这家公司的手写App都很强大，手写计算器、手写Notes都挺好用，而且不贵。</p>
<h4 id="参考链接：">参考链接：</h4><p>MacTex页面：<a href="http://tug.org/mactex/morepackages.html" target="_blank" rel="external">http://tug.org/mactex/morepackages.html</a></p>
<p>Skim官网：<a href="http://skim-app.sourceforge.net" target="_blank" rel="external">http://skim-app.sourceforge.net</a></p>
<p>LaTexTools官网：<a href="https://github.com/SublimeText/LaTeXTools" target="_blank" rel="external">https://github.com/SublimeText/LaTeXTools</a></p>
<p>前六步骤的具体介绍：<a href="http://economistry.com/2013/01/installing-and-using-latex-for-mac/" target="_blank" rel="external">http://economistry.com/2013/01/installing-and-using-latex-for-mac/</a> 不过需要注意，这里是用了完整的MacTex</p>
<p>发现xelatex是受了这里的启发：<a href="http://www.teeboneding.com/blog/2013/06/01/write-ntu-master-thesis-with-xelatex-template-on-mac/" target="_blank" rel="external">http://www.teeboneding.com/blog/2013/06/01/write-ntu-master-thesis-with-xelatex-template-on-mac/</a> 但需要注意，这里的编译代码测试无效。</p>
<p>第七步受了这里的启发：<a href="https://github.com/SublimeText/LaTeXTools/issues/303" target="_blank" rel="external">https://github.com/SublimeText/LaTeXTools/issues/303</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接：<a href="http://www.readern.com/sublime-text-latex-chinese-under-mac.html">http://www.readern.com/sublime-text-latex-chinese-under-mac.html</a><br>作者：Read ERN</p>
<p>LaTex就不多做介绍了，其实一般人用到的机会也不多（包括我）。只是这段时间在Coursera上新课程的时候，偶尔需要，所以从零开始摸索了一下，也顺便进一步发现了Sublime Text的强大。</p>
<p>MAC上的LaTex部署，一般是两条思路，一个是直接安装MacTex，自带编写环境什么的；另一个是Sublime Text（或者Textmate等其他编辑器）+LaTexTools插件。方式二其实也是需要依赖MacTex的，但相对来说体量小、不需要经常切换编辑器，所以果断的介绍方式二。</p>
<p>亲测：MacOS 10.10, Sublime Text 3可用。（2015年5月）</p>]]>
    
    </summary>
    
      <category term="LaTeX" scheme="http://teveillan.com/tags/LaTeX/"/>
    
      <category term="MacOS" scheme="http://teveillan.com/tags/MacOS/"/>
    
      <category term="Tech" scheme="http://teveillan.com/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程之美2015初赛第一场]]></title>
    <link href="http://teveillan.com/2015/05/07/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E2015%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA/"/>
    <id>http://teveillan.com/2015/05/07/编程之美2015初赛第一场/</id>
    <published>2015-05-07T11:51:01.000Z</published>
    <updated>2015-05-07T14:39:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Hihocoder_1156_彩色的树">Hihocoder 1156 彩色的树</h2><p>题目链接: <a href="http://hihocoder.com/problemset/problem/1156" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1156</a></p>
<p>在每个更新操作的过程中，假设点P最初的颜色为color1，更新后的颜色为color2。<br>我们记与点P相邻，颜色为color1的点为num1, 颜色为color2的点为num2。<br>则 ans += num1 - 1, ans -= num2 - 1。</p>
<p>难点主要在于统计nun1, num2。直接暴力肯定是要TLE的，这里有个技巧。</p>
<p>既然是在树中，我们用map存点P的子节点各种颜色的点有多少个，将父节点单独考虑。<br>查询的过程中:</p>
<ul>
<li><code>num1 = map[P][color1] + (color[ fa[P] ] == color1)</code></li>
<li><code>num2 = map[P][color2] + (color[ fa[p] ] == color2)</code></li>
</ul>
<p>更新的时候只用将父节点的子节点的color1—, color2++。<br>在O(log)级的复杂度内就能完成更新查询操作。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;head[N];</span><br><span class="line"><span class="keyword">int</span> color[N], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123; <span class="comment">//构建树形结构</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to: head[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(to == fa[cur])   <span class="keyword">continue</span>;</span><br><span class="line">        fa[to] = cur;</span><br><span class="line">        m[cur][<span class="number">0</span>] ++;</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> tmp_color, <span class="keyword">int</span> &amp;ans)</span> </span>&#123; <span class="comment">//更新点的同时同时更新ans</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp += m[cur][ color[cur] ];</span><br><span class="line">    <span class="keyword">if</span>(color[ fa[cur] ] == color[cur]) ++tmp;</span><br><span class="line">    ans += tmp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">0</span>;</span><br><span class="line">    tmp += m[cur][tmp_color];</span><br><span class="line">    <span class="keyword">if</span>(color[ fa[cur] ] == tmp_color) ++tmp;</span><br><span class="line">    ans -= tmp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    --m[ fa[cur] ][ color[cur] ];</span><br><span class="line">    ++m[ fa[cur] ][ tmp_color ];</span><br><span class="line">    color[cur] = tmp_color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>, n, q, x, y, z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="keyword">sizeof</span>(color));</span><br><span class="line">        FOR(i, <span class="number">1</span>, n)    head[i].clear(), m[i].clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            head[x].pb(y);</span><br><span class="line">            head[y].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">        fa[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++ casid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        color[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;y, &amp;z);</span><br><span class="line">                update(y, z, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hihocoder_1157_建造金字塔">Hihocoder 1157 建造金字塔</h2><p>题目链接： <a href="http://hihocoder.com/problemset/problem/1157" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1157</a></p>
<p>DP。<br>输入的时候时候一个三角形用顶点坐标<code>(x, y)</code>来表示，我们转化成左右端顶点的横坐标来表示一个三角形<code>(l,r) = (x-y,x+y)</code>。然后按<code>l</code>进行排序。<br>我们用<code>dp[i][j]</code>表示第i个点，且前从前i个三角形选择的三角形中最右端为j的最大获益。<br>假设第i个点的左右端点为<code>(l,r)</code>，利润为v1，成本为v2，分三种情况讨论：</p>
<ol>
<li><code>j &lt;= l：dp[i][r] = max(dp[i][r], dp[i-1][j] + v1 - v2)</code></li>
<li><code>j &gt;= r：dp[i][j] = max(dp[i][j], dp[i-1][j] + v1)</code></li>
<li><code>j &gt; l &amp;&amp; j &lt; r：dp[i][r] = max(dp[i][r], dp[i-1][j] + v1 - v2 + v3)</code>。v3为与之前的重叠面积</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">2</span>][<span class="number">3010</span>]; <span class="comment">//滚动数组，第一维只要2就够了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Trangle &#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">double</span> v1, v2;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Trangle &amp;other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l != other.l)    <span class="keyword">return</span> l &lt; other.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; other.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>, n, x, y, z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Trangle&gt;vec(n);</span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            vec[i].l = x - y + <span class="number">1000</span>;<span class="comment">//因为x-y有可能小于0,注意不要超出边界 </span></span><br><span class="line">            vec[i].r = x + y + <span class="number">1000</span>;</span><br><span class="line">            vec[i].v1 = z;</span><br><span class="line">            vec[i].v2 = y * y;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vec.begin(), vec.end()); <span class="comment">//按l排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">        REP(i, <span class="number">2</span>)</span><br><span class="line">            REP(j, <span class="number">3001</span>)</span><br><span class="line">                dp[i][j] = -<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">        dp[cur][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t: vec) &#123;</span><br><span class="line">            cur ^= <span class="number">1</span>, pre ^= <span class="number">1</span>;</span><br><span class="line">            REP(i, <span class="number">3001</span>)</span><br><span class="line">                dp[cur][i] = -<span class="number">1e18</span>;</span><br><span class="line">            <span class="keyword">int</span> l = t.l, r = t.r;</span><br><span class="line">            REP(i, <span class="number">3001</span>) &#123;<span class="comment">//分三种情况讨论</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= r)  dp[cur][i] = max(dp[cur][i], dp[pre][i] + t.v1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &lt;= l) dp[cur][r] = max(dp[cur][r], dp[pre][i] + t.v1 - t.v2);</span><br><span class="line">                <span class="keyword">else</span> dp[cur][r] = max(dp[cur][r], dp[pre][i] + t.v1 - <span class="built_in">pow</span>((t.r - t.l) / <span class="number">2.0</span>, <span class="number">2.0</span>) + <span class="built_in">pow</span>((i - t.l) / <span class="number">2.0</span>, <span class="number">2.0</span>));</span><br><span class="line"></span><br><span class="line">                dp[cur][i] = max(dp[cur][i], dp[pre][i]);</span><br><span class="line">                ans = max(ans, dp[cur][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %.2lf\n"</span>, ++casid, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hihocoder_1158_质数相关">Hihocoder 1158 质数相关</h2><p>题目链接：<a href="http://hihocoder.com/problemset/problem/1158" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1158</a></p>
<p>二分匹配求最大独立集。<br>可证：<code>如果(a,b)质数相关，(b,c)质数相关，则（a,c）质数无关</code></p>
<p>因此没有奇数环，可划分为二分图。<br>求出二分匹配，最大独立集 = n - 最大匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">bool</span> is_prime[<span class="number">510000</span>], flag[<span class="number">510000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="keyword">sizeof</span>(is_prime));</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line">    FOR(i, <span class="number">2</span>, N) &#123; <span class="comment">//素数筛</span></span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i])    <span class="keyword">continue</span>;</span><br><span class="line">        prime.pb(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= N; j += i)  is_prime[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(i, <span class="number">1</span>, N) <span class="comment">//给每个点染色，因为没有奇数环，所以必然染成或黑或白的一种</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: prime) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; N / x)  <span class="keyword">break</span>;</span><br><span class="line">            flag[i * x] = flag[i] ^ <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Max_Match &#123; <span class="comment">//匈牙利匹配</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;head[<span class="number">1100</span>];</span><br><span class="line">    <span class="keyword">int</span> match_x[<span class="number">1100</span>], match_y[<span class="number">1100</span>];</span><br><span class="line">    <span class="keyword">bool</span> visit[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span>&#123; head[x].pb(y); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find_path</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> to: head[cur])</span><br><span class="line">            <span class="keyword">if</span>(!visit[to]) &#123;</span><br><span class="line">                visit[to] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(match_y[to] == -<span class="number">1</span> || find_path( match_y[to] )) &#123;</span><br><span class="line">                    match_x[cur] = to;</span><br><span class="line">                    match_y[to] = cur;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(match_x, -<span class="number">1</span>, <span class="keyword">sizeof</span>(match_x));</span><br><span class="line">        <span class="built_in">memset</span>(match_y, -<span class="number">1</span>, <span class="keyword">sizeof</span>(match_y));</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[ vec[i] ] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">            ret += find_path(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum --) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(n);</span><br><span class="line">        REP(i, n)   <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vec[i]);</span><br><span class="line"></span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        Max_Match match;</span><br><span class="line">        REP(i, n) <span class="comment">//建立二分图</span></span><br><span class="line">            REP(j, i)</span><br><span class="line">                <span class="keyword">if</span>(vec[i] % vec[j] == <span class="number">0</span> &amp;&amp; is_prime[ vec[i] / vec[j] ]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag[ vec[i] ] &lt; flag[ vec[j] ])   match.add(i, j);</span><br><span class="line">                    <span class="keyword">else</span> match.add(j, i);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, ++casid, n - match.solve(n, vec));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Hihocoder_1156_彩色的树">Hihocoder 1156 彩色的树</h2><p>题目链接: <a href="http://hihocoder.com/problemset/problem/1156">http://hihocoder.com/problemset/problem/1156</a></p>
<p>在每个更新操作的过程中，假设点P最初的颜色为color1，更新后的颜色为color2。<br>我们记与点P相邻，颜色为color1的点为num1, 颜色为color2的点为num2。<br>则 ans += num1 - 1, ans -= num2 - 1。</p>
<p>难点主要在于统计nun1, num2。直接暴力肯定是要TLE的，这里有个技巧。</p>
<p>既然是在树中，我们用map存点P的子节点各种颜色的点有多少个，将父节点单独考虑。<br>查询的过程中:</p>
<ul>
<li><code>num1 = map[P][color1] + (color[ fa[P] ] == color1)</code></li>
<li><code>num2 = map[P][color2] + (color[ fa[p] ] == color2)</code></li>
</ul>
<p>更新的时候只用将父节点的子节点的color1—, color2++。<br>在O(log)级的复杂度内就能完成更新查询操作。<br>]]>
    
    </summary>
    
      <category term="编程之美" scheme="http://teveillan.com/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CDQ分治 && HDU 5126]]></title>
    <link href="http://teveillan.com/2015/05/02/CDQ%E5%88%86%E6%B2%BB/"/>
    <id>http://teveillan.com/2015/05/02/CDQ分治/</id>
    <published>2015-05-02T08:48:26.000Z</published>
    <updated>2015-05-06T13:24:03.000Z</updated>
    <content type="html"><![CDATA[<p>参考文献：<a href="http://wenku.baidu.com/view/52f9c11cff00bed5b9f31d2d.html" target="_blank" rel="external">从《Cash》谈一类分治算法的应用</a> — 陈丹琦</p>
<p>也因此简称CDQ分治。</p>
<p>个人理解CDQ分治和普通分治最大的区别为：<br>普通分治可以将问题拆成几个相互独立的子问题<br>CDQ分治将问题分成了两个部分：</p>
<ol>
<li>相互独立的两个子问题  </li>
<li>两个子问题之间的联系</li>
</ol>
<p>因此，CDQ分治的算法流程也分为以下几步：</p>
<blockquote>
<ol>
<li>算法开始</li>
<li>取一个中间点mid, 将问题分为[L, mid] 和 [mid + 1, R]两个部分。分别处理两个子问题</li>
<li>处理[L, mid] 和 [mid + 1, R]之间的联系</li>
</ol>
</blockquote>
<a id="more"></a>
<p>举个例子：在二维坐标系中，有n个点，m个询问。对于每个询问(x, y)，求点(x1, x2) ，x1&lt;= x &amp;&amp; y1 &lt;= y 有多少个。</p>
<p>当然，这题用树状数组就直接能写了。但是我们在这里用CDQ分治来解决一下这个问题。</p>
<p>我们将n个点看做是n个更新，并和m个询问放在一起。定义一个结构体用vector存起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sovle1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;Struct&gt;vec1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在这里将vec1[l, r]按x从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    solve1(l, mid);</span><br><span class="line">    solve1(mid + <span class="number">1</span>, r);<span class="comment">//划分成相互独立的子问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将vec1[l, mid]中的更新操作 和 vec1[mid + 1, r]中的询问操作,存到一个vec2中 </span></span><br><span class="line">    solve2(l, r, vec2);<span class="comment">//左半边的更新操作和右半边的询问操作之间有联系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;Struct&gt;vec2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//此时在solve2中已经不需要管x了。在vec2中所有的更新操作的x必然小于等于询问操作的x。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在这里将vec2[l, r]按y从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    sovle2(l, mid);</span><br><span class="line">    solve2(mid + <span class="number">1</span>, r);<span class="comment">//独立子问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将vec2[l, mid]中的更新操作和vec2[mid + 1, r]中得询问操作存到一个vec3中</span></span><br><span class="line">    solve3(l, r, vec3);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> solve3（<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;Struct&gt;vec3） &#123;</span><br><span class="line"><span class="comment">//此时在solve3中，x和y都是已经排好序的。从前到后遍历该更新更新该询问询问就好。</span></span><br><span class="line">    <span class="keyword">int</span> cal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Struct tmp: vec3) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.type == Update)  ++cal;</span><br><span class="line">        <span class="keyword">else</span> tmp.query_anser += cal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码其中有许多可以优化的地方，但是不要在意细节，主要是为了更加方便地理解算法</span></span><br></pre></td></tr></table></figure>
<p>虽然解法不如树状数组，但是我们得看到题目扩展后的好处。<br>我们看到，当到solve2时，函数中的参数<code>vec2</code>已经不用再管他的x了（<code>请务必深刻理解为什么不用再管了</code>）。<br>这样的好处在哪里？没错，<strong>降维！</strong><br>假如我们要处理的不是二维，而是三维四维依旧可以这么处理，每一个维度只不过加了O(log)的复杂度而已。<br><strong>如果是随时可以更新查询的操作，只不过也只是把时间当成一个维度而已。</strong>（光是这一点就已经牛逼哄哄够解决大部分题目了。）</p>
<p>然后就是下面这道题，三维且可随时更新查询：<br>HDU 5126 starts: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5126" target="_blank" rel="external">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> que[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> z_num;</span><br><span class="line"><span class="keyword">int</span> node[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> Query &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z, kind, id;</span><br><span class="line">    Query() &#123;&#125;</span><br><span class="line">    Query(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _z, <span class="keyword">int</span> _kind, <span class="keyword">int</span> _id) : x(_x), y(_y), z(_z), kind(_kind), id(_id) &#123;&#125;</span><br><span class="line">&#125;queries[N &lt;&lt; <span class="number">3</span>], queries_x[N&lt;&lt;<span class="number">3</span>], queries_y[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.kind &lt; b.kind);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y || (a.y == b.y &amp;&amp; a.kind &lt; b.kind);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span>    </span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pos &lt;= z_num) &#123;</span><br><span class="line">        node[pos] += value;</span><br><span class="line">        pos += lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos) &#123;</span><br><span class="line">        ret += node[pos];</span><br><span class="line">        pos -= lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve3</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//只剩下二维y和z，直接就是二维的更新查询题目，树状数组解决就好了</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    FOR(i, l, r)</span><br><span class="line">        <span class="keyword">if</span>(queries_y[i].kind == <span class="number">0</span>)  update(queries_y[i].z, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(queries_y[i].kind == <span class="number">1</span>)  ans[ queries_y[i].id ] -= query(queries_y[i].z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(queries_y[i].kind == <span class="number">2</span>) ans[ queries_y[i].id ] += query(queries_y[i].z);</span><br><span class="line">    FOR(i, l, r)</span><br><span class="line">        <span class="keyword">if</span>(queries_y[i].kind == <span class="number">0</span>)  update(queries_y[i].z, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//把x这一维度消除</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve2(l, mid);</span><br><span class="line">    solve2(mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    FOR(i, l, mid)  <span class="keyword">if</span>(queries_x[i].kind == <span class="number">0</span>)  queries_y[num++] = queries_x[i];</span><br><span class="line">    FOR(i, mid+<span class="number">1</span>, r)    <span class="keyword">if</span>(queries_x[i].kind)  queries_y[num++] = queries_x[i];</span><br><span class="line">    sort(queries_y, queries_y + num, cmpy);</span><br><span class="line">    solve3(<span class="number">0</span>, num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//已经默认时间从小到大排序了，把时间这一维度消除</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve1(l, mid);</span><br><span class="line">    solve1(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    FOR(i, l, mid)  <span class="keyword">if</span>(queries[i].kind == <span class="number">0</span>)    queries_x[num++] = queries[i];</span><br><span class="line">    FOR(i, mid + <span class="number">1</span>, r)  <span class="keyword">if</span>(queries[i].kind)     queries_x[num++] = queries[i];</span><br><span class="line">    sort(queries_x, queries_x + num, cmpx);<span class="comment">//对x从小到大排序</span></span><br><span class="line">    solve2(<span class="number">0</span>, num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n;</span><br><span class="line">    <span class="keyword">int</span> x1, x2, y1, y2, z1, z2, kind;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, -<span class="number">1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        z_num = <span class="number">0</span>;</span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;kind);</span><br><span class="line">            <span class="keyword">if</span>(kind == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x1, &amp;y1, &amp;z1);</span><br><span class="line">                queries[id++] = Query(x1, y1, z1, <span class="number">0</span>, i);</span><br><span class="line">                que[z_num++] = z1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;z1, &amp;x2, &amp;y2, &amp;z2);</span><br><span class="line">                queries[id++] = Query(x2    , y2    , z2    , <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x2    , y2    , z1 - <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">                queries[id++] = Query(x2    , y1 - <span class="number">1</span>, z2    , <span class="number">1</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y2    , z2    , <span class="number">1</span>, i);</span><br><span class="line">                queries[id++] = Query(x2    , y1 - <span class="number">1</span>, z1 - <span class="number">1</span>, <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y2    , z1 - <span class="number">1</span>, <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>, z2    , <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>, z1 - <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">                que[z_num++] = z2;</span><br><span class="line">                que[z_num++] = z1 - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            sort(que, que + z_num);</span><br><span class="line">            z_num = unique(que, que + z_num) - que;</span><br><span class="line">            REP(i, id)  queries[i].z = lower_bound(que, que + z_num, queries[i].z) - que + <span class="number">1</span>;</span><br><span class="line">            solve1(<span class="number">0</span>, id - <span class="number">1</span>);</span><br><span class="line">            REP(i, n)</span><br><span class="line">                <span class="keyword">if</span>(ans[i] != -<span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>参考文献：<a href="http://wenku.baidu.com/view/52f9c11cff00bed5b9f31d2d.html">从《Cash》谈一类分治算法的应用</a> — 陈丹琦</p>
<p>也因此简称CDQ分治。</p>
<p>个人理解CDQ分治和普通分治最大的区别为：<br>普通分治可以将问题拆成几个相互独立的子问题<br>CDQ分治将问题分成了两个部分：</p>
<ol>
<li>相互独立的两个子问题  </li>
<li>两个子问题之间的联系</li>
</ol>
<p>因此，CDQ分治的算法流程也分为以下几步：</p>
<blockquote>
<ol>
<li>算法开始</li>
<li>取一个中间点mid, 将问题分为[L, mid] 和 [mid + 1, R]两个部分。分别处理两个子问题</li>
<li>处理[L, mid] 和 [mid + 1, R]之间的联系</li>
</ol>
</blockquote>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5208 Where is Bob && Bestcoder Round38 C题]]></title>
    <link href="http://teveillan.com/2015/04/21/HDU-5208-Where-is-Bob-Bestcoder-Round38-C%E9%A2%98/"/>
    <id>http://teveillan.com/2015/04/21/HDU-5208-Where-is-Bob-Bestcoder-Round38-C题/</id>
    <published>2015-04-21T09:57:45.000Z</published>
    <updated>2015-05-07T11:53:49.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5208" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5208</a></p>
<p>近似于数位DP的思路。<br>用数位DP求区间中符号条件的数有多少的时候，有时会用一个符号位来记录当前的取值是否达到区间的上界。这里同样用这个办法。（官方题解我有点没看懂，我的解法有可能和官方题解不一样）</p>
<p>看到题第一眼，觉得应该优先从高位到低位处理，在以下两种情况中，决策应该是确定的：</p>
<ul>
<li>第一个人只能取0或1中的一个。这时候第二个人一定是尽量取和第一个人一样的值。</li>
<li>第二个人只能取0或1中得一个，而第一个人两个都可以选。第一个人自然取第二个人取不到的值。</li>
</ul>
<p>但是，当在这两种情况之外，决策就不唯一了。这时，先把低位的决策解决了就很有必要。<br><a id="more"></a><br>我们用dp[i][l1][r1][l2][r2]来表示。 </p>
<blockquote>
<p><code>l1</code> 为1时，表示 <strong>假设第一个人从最高位到第i+1位的取值都是取区间范围允许的最小值。</strong> 此时，第一个人在第i位的取值要小心不要小于区间允许的最小值。<br>反之<code>l1</code>为0时，表示<strong>假设第一个人从最高位到第i+1位的取值有一个不是区间范围的最小值</strong>，这时候，从第i位到第0位取任何值都不会小于区间允许的最小值了。</p>
</blockquote>
<p>请仔细理解上面这段话。</p>
<p>同理，<code>r1</code>代表之前取的是不是区间范围允许的最大值。然后能类推倒l2, r2。</p>
<p>对于每一位, 我们枚举l1, r1, l2, r2。<strong>（再次阐明一下，l1, r1, l2, r2不是表示第i位两个人的取值范围，是表示高位的取值是不是都是边界值。）</strong> 当l1, r1, l2, r2确定以后，第i位两个人的取值范围也就确定了，枚举两个人的取值，用第i-1位递推到第i位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">40</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        REP(i, <span class="number">31</span>)</span><br><span class="line">            REP(a, <span class="number">2</span>)</span><br><span class="line">                REP(b, <span class="number">2</span>)</span><br><span class="line">                    REP(c, <span class="number">2</span>)</span><br><span class="line">                        REP(d, <span class="number">2</span>)</span><br><span class="line">                            dp[i][a][b][c][d] = <span class="number">1e15</span>;</span><br><span class="line">        <span class="keyword">int</span> l[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        REP(i, <span class="number">2</span>)</span><br><span class="line">            REP(j, <span class="number">2</span>)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; l[i][j];</span><br><span class="line"></span><br><span class="line">        FOR(i, <span class="number">0</span>, <span class="number">31</span>) &#123;</span><br><span class="line">            REP(a, <span class="number">2</span>)</span><br><span class="line">                REP(b, <span class="number">2</span>)</span><br><span class="line">                    REP(c, <span class="number">2</span>)</span><br><span class="line">                        REP(d, <span class="number">2</span>) &#123; <span class="comment">//枚举高位的取值是不是都是边界值</span></span><br><span class="line">                            <span class="keyword">bool</span> tmp_l[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#125;; </span><br><span class="line">                            <span class="comment">// 确定此时两个人的取值范围</span></span><br><span class="line">                            <span class="keyword">if</span>(a)   tmp_l[<span class="number">0</span>][<span class="number">0</span>] = l[<span class="number">0</span>][<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                            <span class="comment">//当第一个人高位的取值都是下界值，而且第i位的下界值为1时</span></span><br><span class="line">                            <span class="comment">//第i位的取值范围的下界为1。否则第i位的取值范围的下界为0。</span></span><br><span class="line">                            <span class="keyword">if</span>(b)   tmp_l[<span class="number">0</span>][<span class="number">1</span>] = l[<span class="number">0</span>][<span class="number">1</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                            <span class="comment">//都类比第一个</span></span><br><span class="line">                            <span class="keyword">if</span>(c)   tmp_l[<span class="number">1</span>][<span class="number">0</span>] = l[<span class="number">1</span>][<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                            <span class="keyword">if</span>(d)   tmp_l[<span class="number">1</span>][<span class="number">1</span>] = l[<span class="number">1</span>][<span class="number">1</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line"></span><br><span class="line">                            ll tmp1 = <span class="number">0</span>;</span><br><span class="line">                            FOR(j, tmp_l[<span class="number">0</span>][<span class="number">0</span>], tmp_l[<span class="number">0</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                            <span class="comment">//取值范围确定了，现在我们来枚举值。j是第一个人的取值</span></span><br><span class="line">                                ll tmp2 = <span class="number">1e15</span>;</span><br><span class="line">                                FOR(k, tmp_l[<span class="number">1</span>][<span class="number">0</span>], tmp_l[<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                                    <span class="comment">//第i位的异或值加上i-1位的dp值就是第i位的dp值。</span></span><br><span class="line">                                    <span class="comment">//但是我们得先算出两个人分别取j和k的情况下</span></span><br><span class="line">                                    <span class="comment">//高位的取值加上第i位的取值是否依然达到上下界</span></span><br><span class="line">                                    <span class="keyword">bool</span> tmp[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">                                    <span class="keyword">if</span>(a &amp;&amp; (j == tmp_l[<span class="number">0</span>][<span class="number">0</span>])) tmp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="comment">//当且仅当高位取值到达下界,第i位又取到下界值得时候,</span></span><br><span class="line">                                    <span class="comment">//对i-1位来说高位的取值达到下界</span></span><br><span class="line">                                    <span class="keyword">if</span>(b &amp;&amp; (j == tmp_l[<span class="number">0</span>][<span class="number">1</span>])) tmp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span>(c &amp;&amp; (k == tmp_l[<span class="number">1</span>][<span class="number">0</span>])) tmp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span>(d &amp;&amp; (k == tmp_l[<span class="number">1</span>][<span class="number">1</span>])) tmp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span>(i)</span><br><span class="line">                                        tmp2 = min(tmp2, ((ll)(j^k) &lt;&lt; i) + dp[i-<span class="number">1</span>][tmp[<span class="number">0</span>][<span class="number">0</span>]][tmp[<span class="number">0</span>][<span class="number">1</span>]][tmp[<span class="number">1</span>][<span class="number">0</span>]][tmp[<span class="number">1</span>][<span class="number">1</span>]]);</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        tmp2 = min(tmp2, ((ll)(j^k) &lt;&lt; i));</span><br><span class="line">                                &#125;</span><br><span class="line">                                tmp1 = max(tmp1, tmp2);</span><br><span class="line">                            &#125;</span><br><span class="line">                            dp[i][a][b][c][d] = tmp1;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = dp[<span class="number">31</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %I64d\n"</span>, ++casid, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5208">http://acm.hdu.edu.cn/showproblem.php?pid=5208</a></p>
<p>近似于数位DP的思路。<br>用数位DP求区间中符号条件的数有多少的时候，有时会用一个符号位来记录当前的取值是否达到区间的上界。这里同样用这个办法。（官方题解我有点没看懂，我的解法有可能和官方题解不一样）</p>
<p>看到题第一眼，觉得应该优先从高位到低位处理，在以下两种情况中，决策应该是确定的：</p>
<ul>
<li>第一个人只能取0或1中的一个。这时候第二个人一定是尽量取和第一个人一样的值。</li>
<li>第二个人只能取0或1中得一个，而第一个人两个都可以选。第一个人自然取第二个人取不到的值。</li>
</ul>
<p>但是，当在这两种情况之外，决策就不唯一了。这时，先把低位的决策解决了就很有必要。<br>]]>
    
    </summary>
    
      <category term="BestCoder" scheme="http://teveillan.com/tags/BestCoder/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BestCoder Round #25]]></title>
    <link href="http://teveillan.com/2015/01/09/BestCoder-Round-25/"/>
    <id>http://teveillan.com/2015/01/09/BestCoder-Round-25/</id>
    <published>2015-01-09T05:57:46.000Z</published>
    <updated>2015-05-07T11:53:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1001_Harry_and_Magical_Computer">1001 Harry and Magical Computer</h2><p>就是判断有没有环存在。<br>点比较少，Floyd一遍O(n^3)就行。</p>
<h2 id="1002_Harry_And_Magic_Box">1002 Harry And Magic Box</h2><p>官方题解是O(n^4)的，其实中间有一维可以省略。（小地方而已。。不管也罢。。）<br><a id="more"></a><br>dp[i][j]表示第i行已经有j列被选过（这j个不一定全都是在第i行选的，有可能包括之前选的）。<br>则dp公式为： <code>(1 &lt;= k &lt;= j)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k == j)</span><br><span class="line">    dp[i][j] += dp[i-<span class="number">1</span>][k] * ((<span class="number">1</span>&lt;&lt;k) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] += dp[i-<span class="number">1</span>][k] * (<span class="number">1</span>&lt;&lt;k) * c[m-k][j-k];</span><br></pre></td></tr></table></figure>
<p>表示假如<code>k==j</code>，前k个中至少选一个，种类数为<code>((1&lt;&lt;k) - 1)</code>。<br>否则， 前k个随便选， 其余从<code>m-k</code>中选<code>j-k</code>个。<br>注意数据溢出。</p>
<h2 id="1003_Harry_and_Christmas_tree">1003 Harry and Christmas tree</h2><p>我是按照官方题解的思路。<br>对每种颜色单独考虑。对第i-1个有这种颜色点a, 第i个有这种颜色的点b， 以及a和b的lca点c。 在递归过程中，c之前的点都可以被贡献1中颜色，直到c以及c往上，贡献度为a和b各一个，然后减去a和b的重复一个，总共为1。</p>
<p>中间要用到lca算法，因为这道题就是按照递归的顺序进行遍历，用离线的lca就行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;head[N], gift[N];</span><br><span class="line"><span class="keyword">int</span> fa[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> pre_color[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])    <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    REP(i, head[now].size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head[now][i] != pre) &#123;</span><br><span class="line">            dfs(head[now][i], now); </span><br><span class="line">            fa[ head[now][i] ] = now; <span class="comment">//离线lca中得一部分</span></span><br><span class="line">            ans[now] += ans[ head[now][i] ]; <span class="comment">//将子节点的贡献度加上来。（这时候子节点的贡献度已经是 总贡献度 - 重复次数 了）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    REP(i, gift[now].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> color = gift[now][i];</span><br><span class="line">        <span class="keyword">if</span>(!pre_color[color])  &#123; <span class="comment">//第一个出现这种颜色，跳过不处理</span></span><br><span class="line">            pre_color[color] = now;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lca = find(pre_color[color]); <span class="comment">// 找lca</span></span><br><span class="line">        --ans[lca]; <span class="comment">// 在lca上加上一个重复度, ans--</span></span><br><span class="line"></span><br><span class="line">        pre_color[color] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[now] += gift[now].size(); <span class="comment">//加上本节点的贡献</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(pre_color, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre_color));</span><br><span class="line">        FOR(i, <span class="number">1</span>, n)    fa[i] = i, head[i].clear(), gift[i].clear();</span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x, &amp;y);</span><br><span class="line">            head[x].pb(y);</span><br><span class="line">            head[y].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            gift[x].pb(y);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        FOR(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)    <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Harry_and_magic_string">Harry and magic string</h2><p>DP + Manacher算法</p>
<p>DP思路很简单。<br>sum[i] 表示以i结尾和i之前结尾的回文串总数。<br>dp[i] 表示以i开头的回文串数。</p>
<blockquote>
<p>ans = $$\sum_{i=1}^{len-1} {sum[i-1] * dp[i]}$$</p>
</blockquote>
<p>难点就是<code>sum[i]</code> 和 <code>dp[i]</code> 怎么求的问题了。<br>新学习了个算法， Manacher算法，在我转载的上篇文章中有讲解。<a href="http://teveillan.com/2015/01/09/-%E8%BD%AC-Manacher%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E4%B8%B2%E5%A4%84%E7%90%86/" target="_blank" rel="external">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[MAX_LEN];</span><br><span class="line"><span class="keyword">int</span> Len[MAX_LEN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> Manacher &#123; <span class="comment">// Manacher算法, 讲解看上篇文章</span></span><br><span class="line">    <span class="keyword">char</span> tmp_str[MAX_LEN&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            tmp_str[id++] = s[i];</span><br><span class="line">            tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_str[id] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = init(s);</span><br><span class="line">        <span class="keyword">int</span> max_r = -<span class="number">1</span>, max_id = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max_r &gt; i)   Len[i] = min(max_r - i, Len[<span class="number">2</span> * max_id - i]);</span><br><span class="line">            <span class="keyword">else</span> Len[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i - Len[i] &gt;= <span class="number">0</span> &amp;&amp; i + Len[i] &lt; len &amp;&amp; tmp_str[i - Len[i]] == tmp_str[i + Len[i]])</span><br><span class="line">                ++Len[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i + Len[i] &gt; max_r) &#123;</span><br><span class="line">                max_r = i + Len[i];</span><br><span class="line">                max_id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAX_LEN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> flag[MAX_LEN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span> ,<span class="keyword">sizeof</span>(flag));</span><br><span class="line">        Manacher manacher;</span><br><span class="line">        manacher.solve(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (len&lt;&lt;<span class="number">1</span>); ++i) &#123; <span class="comment">//求sum</span></span><br><span class="line">            sum[i] += sum[i-<span class="number">1</span>];</span><br><span class="line">            ++tmp;</span><br><span class="line"></span><br><span class="line">            tmp -= flag[i];</span><br><span class="line">            ++flag[i + Len[i]];</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) sum[i] += tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">        tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (len&lt;&lt;<span class="number">1</span>); i &gt;= <span class="number">1</span>; --i) &#123; <span class="comment">//求ans</span></span><br><span class="line">            ++tmp;</span><br><span class="line">            tmp -= flag[i];</span><br><span class="line">            ++flag[i - Len[i]];</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ans += sum[i-<span class="number">1</span>] * tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1001_Harry_and_Magical_Computer">1001 Harry and Magical Computer</h2><p>就是判断有没有环存在。<br>点比较少，Floyd一遍O(n^3)就行。</p>
<h2 id="1002_Harry_And_Magic_Box">1002 Harry And Magic Box</h2><p>官方题解是O(n^4)的，其实中间有一维可以省略。（小地方而已。。不管也罢。。）<br>]]>
    
    </summary>
    
      <category term="BestCoder" scheme="http://teveillan.com/tags/BestCoder/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Manacher算法-回文串处理]]></title>
    <link href="http://teveillan.com/2015/01/09/-%E8%BD%AC-Manacher%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://teveillan.com/2015/01/09/-转-Manacher算法-回文串处理/</id>
    <published>2015-01-09T03:45:39.000Z</published>
    <updated>2015-05-11T06:53:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Manacher</strong>算法是查找一个字符串的最长回文子串的线性算法。<br>在介绍算法之前，首先介绍一下什么是回文串，所谓回文串，简单来说就是正着读和反着读都是一样的字符串，比如abba，noon等等，一个字符串的最长回文子串即为这个字符串的子串中，是回文串的最长的那个。<br>计算字符串的最长回文字串最简单的算法就是枚举该字符串的每一个子串，并且判断这个子串是否为回文串，这个算法的时间复杂度为O(n^3)的，显然无法令人满意，稍微优化的一个算法是枚举回文串的中点，这里要分为两种情况，一种是回文串长度是奇数的情况，另一种是回文串长度是偶数的情况，枚举中点再判断是否是回文串，这样能把算法的时间复杂度降为O(n^2)，但是当n比较大的时候仍然无法令人满意，Manacher算法可以在线性时间复杂度内求出一个字符串的最长回文字串，达到了理论上的下界。</p>
<a id="more"></a>
<h1 id="Manacher算法原理与实现">Manacher算法原理与实现</h1><p>下面介绍Manacher算法的原理与步骤。<br>首先，Manacher算法提供了一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑，具体做法是，在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现，一般情况下可以用#号。下面举一个例子：<br><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-1.png" alt=""></p>
<h2 id="Len数组简介与性质">Len数组简介与性质</h2><p>Manacher算法用一个辅助数组Len[i]表示以字符T[i]为中心的最长回文字串的最右字符到T[i]的长度，比如以T[i]为中心的最长回文字串是T[l,r],那么Len[i]=r-i+1。<br>对于上面的例子，可以得出Len[i]数组为:</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-2.png" alt=""></p>
<p>Len数组有一个性质，那就是Len[i]-1就是该回文子串在原字符串S中的长度，至于证明，首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1。<br>有了这个性质，那么原问题就转化为求所有的Len[i]。下面介绍如何在线性时间复杂度内求出所有的Len。</p>
<h2 id="Len数组的计算">Len数组的计算</h2><p>首先从左往右依次计算Len[i]，当计算Len[i]时，Len<a href="0&lt;=j&lt;i">j</a>已经计算完毕。设P为之前计算中最长回文子串的右端点的最大值，并且设取得这个最大值的位置为po，分两种情况：<br>第一种情况：i&lt;=P<br>那么找到i相对于po的对称位置，设为j，那么如果Len[j]&lt;P-i，如下图：</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-3.png" alt=""></p>
<p>那么说明以j为中心的回文串一定在以po为中心的回文串的内部，且j和i关于位置po对称，由回文串的定义可知，一个回文串反过来还是一个回文串，所以以i为中心的回文串的长度至少和以j为中心的回文串一样，即Len[i]&gt;=Len[j]。因为Len[j]<p-i,所以说i+len[j]<p。由对称性可知len[i]=len[j]。 如果len[j]="">=P-i,由对称性，说明以i为中心的回文串可能会延伸到P之外，而大于P的部分我们还没有进行匹配，所以要从P+1位置开始一个一个进行匹配，直到发生失配，从而更新P和对应的po以及Len[i]。</p-i,所以说i+len[j]<p。由对称性可知len[i]=len[j]。></p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-4.png" alt=""></p>
<p>第二种情况: i&gt;P<br>如果i比P还要大，说明对于中点为i的回文串还一点都没有匹配，这个时候，就只能老老实实地一个一个匹配了，匹配完成后要更新P的位置和对应的po以及Len[i]。</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-5.png" alt=""></p>
<h1 id="时间复杂度分析">时间复杂度分析</h1><p>Manacher算法的时间复杂度分析和Z算法类似，因为算法只有遇到还没有匹配的位置时才进行匹配，已经匹配过的位置不再进行匹配，所以对于T字符串中的每一个位置，只进行一次匹配，所以Manacher算法的总体时间复杂度为O(n)，其中n为T字符串的长度，由于T的长度事实上是S的两倍，所以时间复杂度依然是线性的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Len[MAX_LEN&lt;&lt;<span class="number">1</span>]; <span class="comment">//记录算法完成后以i点为中心最长回文串向左向右延伸的半径</span></span><br><span class="line"><span class="keyword">struct</span> Manacher &#123;</span><br><span class="line">    <span class="keyword">char</span> tmp_str[MAX_LEN&lt;&lt;<span class="number">1</span>]; <span class="comment">//记录预处理过后的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123; <span class="comment">//在solve中就直接调用了。对原串进行预处理。</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            tmp_str[id++] = s[i];</span><br><span class="line">            tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_str[id] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> id; <span class="comment">//此时的id即为处理过后的字符串长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123; <span class="comment">//从这开始处理</span></span><br><span class="line">        <span class="keyword">int</span> len = init(s);</span><br><span class="line">        <span class="keyword">int</span> max_r = -<span class="number">1</span>, max_id = -<span class="number">1</span>; <span class="comment">// 最右能到得地方，以及最右时的中心点id</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max_r &gt; i)   Len[i] = min(max_r - i, Len[<span class="number">2</span> * max_id - i]);</span><br><span class="line">            <span class="keyword">else</span> Len[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i - Len[i] &gt;= <span class="number">0</span> &amp;&amp; i + Len[i] &lt; len &amp;&amp; tmp_str[i - Len[i]] == tmp_str[i + Len[i]])</span><br><span class="line">                ++Len[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i + Len[i] &gt; max_r) &#123;</span><br><span class="line">                max_r = i + Len[i];</span><br><span class="line">                max_id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>转自：<a href="http://blog.csdn.net/dyx404514/article/details/42061017" target="_blank" rel="external">http://blog.csdn.net/dyx404514/article/details/42061017</a><br>作者：dyx心心</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Manacher</strong>算法是查找一个字符串的最长回文子串的线性算法。<br>在介绍算法之前，首先介绍一下什么是回文串，所谓回文串，简单来说就是正着读和反着读都是一样的字符串，比如abba，noon等等，一个字符串的最长回文子串即为这个字符串的子串中，是回文串的最长的那个。<br>计算字符串的最长回文字串最简单的算法就是枚举该字符串的每一个子串，并且判断这个子串是否为回文串，这个算法的时间复杂度为O(n^3)的，显然无法令人满意，稍微优化的一个算法是枚举回文串的中点，这里要分为两种情况，一种是回文串长度是奇数的情况，另一种是回文串长度是偶数的情况，枚举中点再判断是否是回文串，这样能把算法的时间复杂度降为O(n^2)，但是当n比较大的时候仍然无法令人满意，Manacher算法可以在线性时间复杂度内求出一个字符串的最长回文字串，达到了理论上的下界。</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(转) Mac中安装Vim7.4]]></title>
    <link href="http://teveillan.com/2015/01/07/Mac%E4%B8%AD%E5%AE%89%E8%A3%85Vim7-4/"/>
    <id>http://teveillan.com/2015/01/07/Mac中安装Vim7-4/</id>
    <published>2015-01-07T04:58:51.000Z</published>
    <updated>2015-05-06T13:24:03.000Z</updated>
    <content type="html"><![CDATA[<p>Mac本身其实是预装了Vim的，但是目前的系统中都是Vim7.3版本的，而最新的Vim已经是7.4版了，因此为了能够使用最新版的vim，必须要对Mac中的vim要么升级，要么重装。在折腾过程中，遇到了一些问题，这里记录，以鉴后人。</p>
<a id="more"></a>
<h1 id="可选方案"><strong>可选方案</strong></h1><p><strong>升级原生的Vim7.3</strong><br> 这种方法貌似是最”干净”的，不会引入其他任何多余的东西，对于有洁癖的人这应该是一种比较好的方案。但是，这个方案也有缺点，那就是它会覆盖原生的Vim，会改变系统的默认设置，并且一旦升级过程中出现了问题，那你就再也没有可用的vim了。另外一个问题是，以后当你系统升级的时候，很有可能你自己的vim又会被新系统的vim给覆盖，这样会比较麻烦。</p>
<p><strong>使用MacVim</strong><br>这是一种比较好的方案，Vim官网上也是推荐使用这种方案的，MacVim是针对Mac系统特别定制的Vim版本，安装过程也很简单，网上一搜一大把。它功能上和vim完全一致，不会有任何的问题。要说这种方案其实已经算是一个完美的解决方案了，但是它有一点不太方便的地方，那就是不能直接在终端中使用vim，每次使用MacVim的时候都会单独开启一个窗口，有点类似于windows中的gvim。而我个人是比较习惯在终端中写代码的，因此这个方案还是不能满足我的需求。</p>
<p><strong>自己编译</strong><br>这是一种终极的方案，但是自己编译的时候注意要手动更改默认的安装目录，不然它就会覆盖原生的vim7.3，这样就会变成第一种方案了。将vim7.4安装在其他目录，然后在.bash_profile中添加一个vim命令的别名，将其指向新安装的vim7.4的目录，而不是原生的vim7.3目录。这个方案就能在终端中直接使用vim7.4了，并且不会对原生的vim7.3又任何影响。这个方案唯一的缺点大概就是会在系统中产生两个不同版本的vim了，这也许对一些有洁癖的人是难以接受的。</p>
<p>我自己最终选择了第三套方案，也就是自己编译新版本的vim.</p>
<h1 id="重新编译"><strong>重新编译</strong></h1><p>好了，现在让我们开始折腾吧。</p>
<p>首先上vim的官网下载vim7.4的源文件。（<a href="http://www.vim.org/sources.ph" target="_blank" rel="external">下载链接</a>）</p>
<p>新建目录<code>/opt/local</code>，这个目录就是用来存放我们新安装的vim7.4的，你也可以建立其他的目录，这里只是一个示例。</p>
<p>进入vim的源文件目录中，在终端中运行命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-features=huge --enable-pythoninterp=yes  --enable-cscope --enable-fontset --enable-perlinterp --enable-rubyinterp --with-python-config-dir=/usr/lib/python2.<span class="number">6</span>/config --prefix=/opt/<span class="built_in">local</span></span><br></pre></td></tr></table></figure></p>
<p>这个命令是完成对vim的一些配置选项，启用了python和ruby的支持特性，这还是比较重要的，因为vim中有些插件会使用python和ruby的，如果没有开启这些特性，有些插件是无法运行的。在这些配置命令中，最后一个<code>--prefix=/opt/local</code>是用来指明安装目录的，你也可以修改成你自己的目录。</p>
<p>在写配置命令的时候，需要注意的是，不能写上<code>--enable-gui</code>，这是开启gui特性的，但是我们是在终端环境下安装的，因此不能开启这个特性，否则会出现编译错误。</p>
<p>在终端中执行<code>make</code>命令。在make过程中，会出现一个错误，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:info:build os_unix.c:<span class="number">830</span>:<span class="number">46</span>: warning: declaration of <span class="string">'struct sigaltstack'</span> will not be visible outside of this <span class="keyword">function</span> [-Wvisibility]</span><br><span class="line">:info:build         extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));</span><br><span class="line">:info:build                                                     ^</span><br><span class="line">:info:build ./os_unix.h:<span class="number">88</span>:<span class="number">21</span>: note: expanded from macro <span class="string">'__ARGS'</span></span><br><span class="line">:info:build <span class="comment">#  define __ARGS(x) x</span></span><br><span class="line">:info:build                     ^</span><br><span class="line">:info:build os_unix.c:<span class="number">830</span>:<span class="number">13</span>: error: conflicting types <span class="keyword">for</span> <span class="string">'sigaltstack'</span></span><br><span class="line">:info:build         extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));</span><br><span class="line">:info:build                    ^</span><br><span class="line">:info:build /usr/include/signal.h:<span class="number">89</span>:<span class="number">5</span>: note: previous declaration is here</span><br><span class="line">:info:build int     sigaltstack(const stack_t * __restrict, stack_t * __restrict)  __DARWIN_ALIAS(sigaltstack);</span><br><span class="line">:info:build         ^</span><br><span class="line">:info:build <span class="number">1</span> warning and <span class="number">1</span> error generated.</span><br><span class="line">:info:build make[<span class="number">1</span>]: *** [objects/os_unix.o] Error <span class="number">1</span></span><br><span class="line">:info:build make[<span class="number">1</span>]: *** Waiting <span class="keyword">for</span> unfinished <span class="built_in">jobs</span>….)</span><br></pre></td></tr></table></figure></p>
<p>解决方案也很简单，只需要在os_unix.h(src文件夹中)中加上<code>#include &lt;AvailabilityMacros.h&gt;</code>就可以了。</p>
<p>执行<code>make install</code>.执行完成之后，vim7.4就安装完成了。</p>
<p>添加vim命令的别名，在.bash_profile中添加一行<code>alias vim=&#39;/opt/local/bin/vim&#39;</code>，然后在终端中执行<code>source ~/.bash_profile</code></p>
<p>好了，现在你的Mac系统已经安装好了vim7.4了，现在可以开始愉快的工作了。</p>
<p>参考资料<br><a href="http://stackoverflow.com/questions/7211820/update-built-in-vim-on-mac-os-x" target="_blank" rel="external">http://stackoverflow.com/questions/7211820/update-built-in-vim-on-mac-os-x</a><br><a href="http://www.jokerlin.us/2014/04/13/Vim74.html" target="_blank" rel="external">http://www.jokerlin.us/2014/04/13/Vim74.html</a><br><a href="http://trac.macports.org/ticket/41774" target="_blank" rel="external">http://trac.macports.org/ticket/41774</a></p>
<p>声明:本文采用<code>BY-NC-SA</code>协议进行授权.转载请注明: <a href="http://zhouyichu.com/vim/Vim-in-Mac.html" target="_blank" rel="external">Mac中安装Vim7.4</a><br>转自:Flyaway<br>原文链接: <a href="http://zhouyichu.com/vim/Vim-in-Mac.html" target="_blank" rel="external">http://zhouyichu.com/vim/Vim-in-Mac.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Mac本身其实是预装了Vim的，但是目前的系统中都是Vim7.3版本的，而最新的Vim已经是7.4版了，因此为了能够使用最新版的vim，必须要对Mac中的vim要么升级，要么重装。在折腾过程中，遇到了一些问题，这里记录，以鉴后人。</p>]]>
    
    </summary>
    
      <category term="MacOS" scheme="http://teveillan.com/tags/MacOS/"/>
    
      <category term="VIM" scheme="http://teveillan.com/tags/VIM/"/>
    
      <category term="Tech" scheme="http://teveillan.com/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最短路 SPFA]]></title>
    <link href="http://teveillan.com/2015/01/04/%E6%9C%80%E7%9F%AD%E8%B7%AF-SPFA/"/>
    <id>http://teveillan.com/2015/01/04/最短路-SPFA/</id>
    <published>2015-01-04T07:32:34.000Z</published>
    <updated>2015-05-07T08:05:28.000Z</updated>
    <content type="html"><![CDATA[<p>首先，为了简化分析，我们假定图中是没有负环的。<br>如果有负环，则就没有最短路径。</p>
<blockquote>
<p>负环：一条从a到a的路径，路径上每条边的边权和为负。</p>
</blockquote>
<p>但是SPFA算法是可以判断是否有负环存在的，比较基本的做法是判断每个点进队出队的次数，这个复杂度比较高。其实有一种DFS版的SPFA，用这个来判断是否有负环的效率是非常高的，这个我们后续再讲。</p>
<p>最短路的算法中都用着一种通用的思路：</p>
<ul>
<li>初始化</li>
<li>松弛操作<a id="more"></a>
初始化自然不用说。<br>最开始还没有进行任何操作，每个点（除了起始点）距离起始点的距离为无穷大（记为dis[i]=INF），起始点到起始点的距离为0（记作dis[start]=0）。</li>
</ul>
<p>然后是松弛操作，也是本篇文章的主要部分。<br>松弛操作的要达到的目的是：</p>
<ul>
<li><strong> 对于任意点u, 将从起始点到u的最短距离记为dis[u]。 </strong></li>
<li><strong> 对于点u的任意相邻点v, 满足dis[v] &lt;= dis[u] + d[u,v] </strong></li>
</ul>
<blockquote>
<p>u与v相邻：存在一条边 u-&gt;v</p>
</blockquote>
<p>为什么要满足这样一个条件呢？</p>
<p>拿v点举例。<br>我们知道，一条从起始点s到v点的最短路径不可能是凭空产生的，从起始点到v点的最短路径在两种情况下可能产生：</p>
<ul>
<li><strong> s与v相邻，(s,v)这条边就可能（但不是一定）就直接是一条最短路径。</strong></li>
<li><strong> 有一个点u与v相邻，通过s到u的的最短路径，延伸出一条从s到v得最短路径。 </strong></li>
</ul>
<p>对于第一种情况，很明显一次就直接能找到最短路径。</p>
<p>对于第二种情况，假设到点v的最终最短路径是先从s到u, 再从u到v。<br>在算法执行的过程中，我们不知道此时的dis[u]是否是最短距离。这个都没关系，我们先满足在当前dis[u]的情况下,dis[v]是否小于等于dis[u] + d[u,v]。<br>如果此时的dis[u]是最优解，dis[v]自然也是最优解。<br>如果dis[u]不是最优解，那就往前推，先保证从s到u的最短路径中，u的前一个点x是最优解。如果x不是，再往前推，早晚会推到dis[s]=0，这个妥妥地是最优解了，然后就能保证后面的都是最优解。</p>
<p>所以，我们的算法流程是这样:</p>
<ol>
<li>初始化</li>
<li>将起始点加入一个队列中</li>
<li>从队列中取出来一个点u，并将这个点从队列中移除</li>
<li>对于u所有相邻的点v，看dis[v] 是否小于等于dis[u] + d[u,v]，如果不是（说明这个点还不是最优解，所以它之前更新过的点中仍然有些不是最优解），更新dis[v]=dis[u] + d[u,v]。再看v是否在队列中，如果不是，将v加入队列。</li>
<li>回到步骤3</li>
<li>直到队列为空，算法结束，此时的dis均为最优解。</li>
</ol>
<p>算法复杂度为O(k * e)，e为边数。k为可变常数，可证明一般情况下k &lt; 2。（我不知道怎么证明的…有兴趣的可以自己查查）</p>
<p>在这个模板中，为了省内存，我的队列采用的时循环队列的形式。因为每个点最多只能同时在队列里一次，所以这个队列大小为n就足够了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SPFA &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">struct</span> Edge &#123;</span><br><span class="line">        <span class="keyword">int</span> to, next;</span><br><span class="line">        type d;</span><br><span class="line">    &#125;edge[M];</span><br><span class="line"></span><br><span class="line">    type dis[N];</span><br><span class="line">    <span class="keyword">int</span> que[N], head[N], ip;</span><br><span class="line">    <span class="keyword">bool</span> visit[N];<span class="comment">//标记各点是否在队列中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SPFA() &#123; init(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="comment">//初始化，采用链式前向星建边</span></span><br><span class="line">            <span class="built_in">memset</span>(head, -<span class="number">1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">            ip = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">            edge[ip].to=v; edge[ip].d=d; edge[ip].next=head[u]; head[u]=ip++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));<span class="comment">//清空队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=num; ++i)   dis[i] = INF;<span class="comment">//步骤1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> front = -<span class="number">1</span>, tail = -<span class="number">1</span>;</span><br><span class="line">            dis[start] = <span class="number">0</span>; visit[start] = <span class="number">1</span>; que[++tail] = start;<span class="comment">//步骤2</span></span><br><span class="line">            <span class="keyword">while</span>(front != tail) &#123;</span><br><span class="line">                <span class="keyword">if</span>(++front &gt; num)   front -= num;</span><br><span class="line">                <span class="keyword">int</span> top = que[front];<span class="comment">//步骤3</span></span><br><span class="line">                visit[top] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p=head[top]; p!=-<span class="number">1</span>; p=edge[p].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[p].to, temp = dis[top] + edge[p].c;</span><br><span class="line">                    <span class="keyword">if</span>(dis[to] &gt; temp) &#123;<span class="comment">//步骤4</span></span><br><span class="line">                        dis[to] = temp;</span><br><span class="line">                        <span class="keyword">if</span>(!visit[to]) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(++tail &gt; num)    tail -= num;</span><br><span class="line">                            que[tail] = to;</span><br><span class="line">                            viist[to] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dis[end];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先，为了简化分析，我们假定图中是没有负环的。<br>如果有负环，则就没有最短路径。</p>
<blockquote>
<p>负环：一条从a到a的路径，路径上每条边的边权和为负。</p>
</blockquote>
<p>但是SPFA算法是可以判断是否有负环存在的，比较基本的做法是判断每个点进队出队的次数，这个复杂度比较高。其实有一种DFS版的SPFA，用这个来判断是否有负环的效率是非常高的，这个我们后续再讲。</p>
<p>最短路的算法中都用着一种通用的思路：</p>
<ul>
<li>初始化</li>
<li>松弛操作]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络流]]></title>
    <link href="http://teveillan.com/2015/01/04/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://teveillan.com/2015/01/04/网络流/</id>
    <published>2015-01-04T05:01:59.000Z</published>
    <updated>2015-05-06T13:24:03.000Z</updated>
    <content type="html"><![CDATA[<p>网络流，也被称为最大流。</p>
<p>模型也非常简单，就是一个管道系统，在有源点，汇点，和一堆有流速限制的管道连接的情况下，问能从源点到汇点传输流量的最大流速是多少。如下图所示。</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/网络流.png" alt="Alt text"><br><a id="more"></a><br>假定s为源点，t为汇点，中间各箭头为管道，各管道的流速限制均为1。<br>求最大流的话，很明显，最大流为2。有两条流量：</p>
<ul>
<li>s -&gt; 1 -&gt; 3 -&gt; t，流量为1</li>
<li>s -&gt; 2 -&gt; 4 -&gt; t，流量为1</li>
</ul>
<p>现在是因为图比较简单，我们能一眼看出来。我们自然喜欢程序跑出来的结果是这样。</p>
<p>在程序过程中，自然就是找到一条流量处理一条流量。<br>如果先找到 s -&gt; 1 -&gt; 3 -&gt; t，然后找到 s -&gt; 2 -&gt; 4 -&gt; t，自然皆大欢喜。<br>但是如果程序的第一条直接找到 s -&gt; 1 -&gt; 4 -&gt; t 了呢？这样的最终结果就只有一条流量。</p>
<p>为了解决这个问题，有人提出了一种叫回退边（后悔边）的概念。<strong> 这个也是本算法的精髓所在。 </strong></p>
<blockquote>
<p>后悔边：如果我们根据原图建了一条从u到v，流量为f的边 (u,v)=f。 同时，我们也需要建一条从v到u，流量为0的边 (v,u)=0，这条边我们就称为后悔边。(u,v) 和 (v,u)互为反向边。 </p>
</blockquote>
<p>同时，在程序进行过程中，如果我们如果从残余网络中找到一条从s到v的流量为f，在更新的过程中，我们首先要把最终答案加上c，然后我们不仅要把在该流量上的各边的剩余流量减去f，同时还要把流量上各条边的反向边的流量加上f。</p>
<p>这样做有什么好处呢?</p>
<p>还是以上图为例，如果我们先找到了 s -&gt; 1 -&gt; 3 -&gt; t，流量为1。我们首先在最终答案中加1，然后在更新的过程中不仅要把 (s,1)、(1,4)、(4,t) 这几条边的剩余流量减1， 还要把 (1,s)、(4,1)、(t,4) 的剩余流量加1。 </p>
<p>此时的残余网络为：</p>
<ul>
<li>(s,1) = 0, (1,s) = 1</li>
<li>(s,2) = 1, (2,s) = 0</li>
<li>(1,3) = 1, (3,1) = 0</li>
<li>(1,4) = 0, (4,1) = 1</li>
<li>(2,4) = 1, (4,2) = 0</li>
<li>(3,t ) = 1, (t,3 ) = 0</li>
<li>(4,t ) = 0, (t,4 ) = 1</li>
</ul>
<p>然后我们从残余网络中找流量，<strong>发现此时能找到一条 s -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 3 -&gt; t 的流量了！</strong>然后我们还按之前的方式更新。再找的时候找不到新的流量了，算法结束。此时的结果是和我们之前用肉眼观察的结果是一样的。</p>
<p>这就是后悔边的神奇之处。</p>
<p><strong>后悔边，顾名思义，就是给了一条边后悔的权利。在算法过程中，原图的边和后悔边是没有区别的，所以找流量的时候也没有任何区别。</strong></p>
<p>这条边存在的意义是，还拿刚刚那条 s -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 3这条流量来说。里面存在一条后悔边(4,1)，它的意义是：</p>
<ul>
<li><strong> 之前已经更新过的流量中，有一条从4到t的流量<code>4 -&gt; t</code>，这条流量我可以用到。</strong></li>
<li><strong> 目前的残余网络中，还存在一条从1到s得流量<code>1 -&gt; 3 -&gt; t</code>，这条流量可以替换你之前更新过的流量 <code>1 -&gt; 4 -&gt; t</code>。</strong></li>
<li><strong> 为什么不能你用<code>1 -&gt; 3 -&gt; t</code>，我用<code>4 -&gt; t</code>呢。这样的得到的总流量多一些，我们来交换吧。</strong></li>
<li><strong> 你把你的流量退回去，用我给你的。我用你之前的。 至于中间的(4,1)，退回去我也用不上，大不了都不用了吧。</strong></li>
</ul>
<p>这样下来，最佳方案就出现了。</p>
<p>可以发现，在有后悔边存在的情况下，先找哪条流量后找哪条流量就已经不重要了。反正都是可以做修改的。这样的话，只要考虑如何高效地找流量就好了。这个当然不能随便找，有环的话肯定要进入死循环。</p>
<p>在<strong>Dinic</strong>算法中，我们采用了分层图的形式。分层用BFS来实现。</p>
<ul>
<li>首先，将源点的level设为0，并将源点加入队列。</li>
<li>从队列中取出一个点u，遍历以它为起点还有流量的边，找到点v。如果点v还没被加入队列过，将v的level设为level[u]+1，并将v加入队列。</li>
<li>回到步骤2，直到队列为空。</li>
</ul>
<p>然后我们规定，level为<code>a</code>的点只能向level为<code>a+1</code>的点找流量,这样就能很有效地避免环的出现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e7</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">struct</span> Edge&#123;</span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="keyword">int</span> head[N], level[N], que[N], ip;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, -<span class="number">1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    ip = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">makelevel</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//将图分层</span></span><br><span class="line">    <span class="built_in">memset</span>(level,<span class="number">0</span>,<span class="keyword">sizeof</span>(level));</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    que[num++]=s;</span><br><span class="line">    level[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> top=que[i];</span><br><span class="line">        <span class="keyword">if</span>(top==t)  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//找到t了，后面再找level肯定比t大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=head[top];k!=-<span class="number">1</span>;k=edge[k].next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!level[edge[k].to]&amp;&amp;edge[k].c&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                que[num++]=edge[k].to;</span><br><span class="line">                level[edge[k].to]=level[top]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> maxf,<span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">//从残余网络中找流量</span></span><br><span class="line">    <span class="keyword">if</span>(now==t)  <span class="keyword">return</span> maxf;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=head[now];k!=-<span class="number">1</span>;k=edge[k].next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(edge[k].c&gt;<span class="number">0</span>&amp;&amp;level[edge[k].to]==(level[now]+<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> c=dfs(edge[k].to,min(maxf-ret,edge[k].c),t);</span><br><span class="line">            edge[k].c-=c;</span><br><span class="line">            edge[k^<span class="number">1</span>].c+=c;</span><br><span class="line">            ret+=c;</span><br><span class="line">            <span class="keyword">if</span>(ret==maxf)   <span class="keyword">return</span>  ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    --level[now]; <span class="comment">//一个优化，说明往level[now]+1找流量已经找不到了。自己就降一个level。</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(makelevel(s,t))   ans+=dfs(s,INF,t);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c,<span class="keyword">int</span> f)</span> </span>&#123;<span class="comment">//有向边f为0 ,否则为 c</span></span><br><span class="line">    edge[ip].to=v;edge[ip].c=c;edge[ip].next=head[u];head[u]=ip++;</span><br><span class="line">    edge[ip].to=u;edge[ip].c=f;edge[ip].next=head[v];head[v]=ip++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>网络流，也被称为最大流。</p>
<p>模型也非常简单，就是一个管道系统，在有源点，汇点，和一堆有流速限制的管道连接的情况下，问能从源点到汇点传输流量的最大流速是多少。如下图所示。</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/网络流.png" alt="Alt text"><br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
</feed>