<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Teveillan]]></title>
  <subtitle><![CDATA[不把CF TC刷红的人生是不完整的。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://teveillan.com/"/>
  <updated>2016-05-31T14:34:57.000Z</updated>
  <id>http://teveillan.com/</id>
  
  <author>
    <name><![CDATA[Teveillan]]></name>
    <email><![CDATA[teveillan@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[TopCoder SRM 691 Div1 ]]></title>
    <link href="http://teveillan.com/2016/05/31/TopCoder-SRM-691-DIV-1/"/>
    <id>http://teveillan.com/2016/05/31/TopCoder-SRM-691-DIV-1/</id>
    <published>2016-05-31T11:42:12.000Z</published>
    <updated>2016-05-31T14:34:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Easy:_Sunnygraphs">Easy: Sunnygraphs</h2><p>题意： 最初有n个点，每个点i与a[i]相连，另外又一个点P。<br>在原先的n个点中，选一个点的集合S，对于任意点 $~i \in S$，进行以下两种操作：</p>
<ul>
<li>删除i与a[i]的那条边</li>
<li>添加i与P的边</li>
</ul>
<a id="more"></a>
<p>问有多少种点的集合S，使得0与1最后相连。</p>
<p>当图为有向图时，我们设：</p>
<ul>
<li>0能到达的点集为A；</li>
<li>1能到达的点集为B；</li>
</ul>
<p>分一下两种情况：</p>
<ol>
<li>当0 1不连通（无向图）的时候， 自然从A至少选一个点，从B中至少选一个点。</li>
<li>当0 1连通（无向图）的时候。以下两种情况不符合要求：<ul>
<li>存在一个点$x \in S$，满足$x \in (A - B)  且 S \bigcap B = \emptyset $。也就是说有个0能到而1却不能到达的点x在集合S中 ，且B能到达的点不在S中。</li>
<li>存在一个点$x \in S$，满足$x \in (B - A)  且 S \bigcap A = \emptyset $。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">bool</span> g[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Sunnygraphs</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g)); <span class="comment">//有向图的连通性</span></span><br><span class="line">            <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)); <span class="comment">//无向图的连通性</span></span><br><span class="line">            <span class="keyword">int</span> n = a.size();</span><br><span class="line">            REP(i, n) g[i][i] = <span class="number">1</span>;</span><br><span class="line">            REP(i, n) g[i][a[i]] = <span class="number">1</span>, f[i][a[i]] = f[a[i]][i] = <span class="number">1</span>;</span><br><span class="line">            REP(k, n) REP(i, n) REP(j, n) g[i][j] |= (g[i][k] &amp; g[k][j]), f[i][j] |= (f[i][k] &amp; f[k][j]);</span><br><span class="line">            <span class="keyword">int</span> num0 = <span class="number">0</span>, num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">            REP(i, n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[<span class="number">0</span>][i] &amp;&amp; g[<span class="number">1</span>][i]) ++num2;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(g[<span class="number">0</span>][i]) ++num0;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(g[<span class="number">1</span>][i]) ++num1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!f[<span class="number">0</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = n - num0 - num1;</span><br><span class="line">                <span class="keyword">return</span> ((<span class="number">1l</span>l&lt;&lt;num0) - <span class="number">1</span>) * ((<span class="number">1l</span>l&lt;&lt;num1) - <span class="number">1</span>) * (<span class="number">1l</span>l &lt;&lt; tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = n - num0 - num1 - num2;</span><br><span class="line">            LL ret = <span class="number">1l</span>l &lt;&lt; n;</span><br><span class="line">            ret -= (((<span class="number">1l</span>l &lt;&lt; num0) - <span class="number">1</span> )* (<span class="number">1l</span>l &lt;&lt; tmp));</span><br><span class="line">            ret -= (((<span class="number">1l</span>l &lt;&lt; num1) - <span class="number">1</span>) * (<span class="number">1l</span>l &lt;&lt; tmp));</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Medium:_Money_Manager">Medium: Money Manager</h2><p>题意： 有n个项目，每做一个项目有经验值$a_i$以及基础奖金$b_i$。<br>每做完一个项目，设历史积攒的经验值总和为exp，则做完这个项目能得到的奖金为$b_i$ * exp。<br>另外，在第<code>n/2</code>个项目做完时，需要做一个项目，增加的经验值为X，但没有奖金。<br>问怎么安排项目顺序使得最后能获得的奖金总和最大。</p>
<p>我们先考虑在没有X的情况下的方案。<br>有一个性质： 当 $a_i <em> b_j &gt; a_j </em> b_i$时， 则i必定在j之前。且这个式子是有传递性的。</p>
<p>也就是说，当不考虑X的时候，用排序算法就能解决。如果我们选好了前n个需要做的项目有哪些，则相对顺序是确定了的。<br>当考虑X时，我们发现，影响因素仅仅是后n个项目的b之和。<br>因此，枚举后n个项目的b之和（假设为f）。<br>DP[l][r][sr], 表示前n个项目中以及选好了l个，后n个项目中已经选好了r个，且后n个项目的b之和为sr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pii &amp;a, <span class="keyword">const</span> pii &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first * b.second &lt; a.second * b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Moneymanager &#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">30</span>][<span class="number">30</span>][<span class="number">300</span>];</span><br><span class="line">    <span class="keyword">int</span> sum[<span class="number">55</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setmax</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;x = max(x, y);&#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getbest</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; b, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(), m = n / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; vec;</span><br><span class="line">        REP(i, n) vec.pb(pii(a[i], b[i]));</span><br><span class="line">        sort(vec.begin(), vec.end(), cmp);</span><br><span class="line"></span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            sum[i] = vec[i].second;</span><br><span class="line">            <span class="keyword">if</span>(i) sum[i] += sum[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        FOR(f, <span class="number">0</span>, m * <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp, -<span class="number">1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = f * X;</span><br><span class="line"></span><br><span class="line">            FOR(l, <span class="number">0</span>, m) FOR(r, <span class="number">0</span>, m) &#123;</span><br><span class="line">                <span class="keyword">if</span>(l == m &amp;&amp; r == m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> a = vec[l+r].first, b = vec[l+r].second;</span><br><span class="line"></span><br><span class="line">                FOR(sr, <span class="number">0</span>, r * <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sl = sum[l + r] - sr - b;</span><br><span class="line">                    <span class="keyword">if</span>(sl &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    setmax(dp[l+<span class="number">1</span>][r][sr], dp[l][r][sr] + a * (sl + b) + a * f);</span><br><span class="line">                    setmax(dp[l][r+<span class="number">1</span>][sr+b], dp[l][r][sr] + a * (sr + b));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setmax(ret, dp[m][m][f]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Easy:_Sunnygraphs">Easy: Sunnygraphs</h2><p>题意： 最初有n个点，每个点i与a[i]相连，另外又一个点P。<br>在原先的n个点中，选一个点的集合S，对于任意点 $~i \in S$，进行以下两种操作：</p>
<ul>
<li>删除i与a[i]的那条边</li>
<li>添加i与P的边</li>
</ul>]]>
    
    </summary>
    
      <category term="topcoder" scheme="http://teveillan.com/tags/topcoder/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Codeforces #352 Div.1 C. Ultimate Weirdness of an Array]]></title>
    <link href="http://teveillan.com/2016/05/18/Codeforces-352-Div-1-C-Ultimate-Weirdness-of-an-Array/"/>
    <id>http://teveillan.com/2016/05/18/Codeforces-352-Div-1-C-Ultimate-Weirdness-of-an-Array/</id>
    <published>2016-05-18T15:24:11.000Z</published>
    <updated>2016-05-18T15:37:10.000Z</updated>
    <content type="html"><![CDATA[<p>对数论不是很在行…每次碰到gcd相关的题都是一脸懵逼…以后遇到这种题还是多总结一下吧。</p>
<p>最初以为是要分解质因子，然后用容斥乱搞一番，结果发现完全搞不出来..</p>
<p>题意: $1 &lt;= n &lt;= 2 * 10^5$， 求<br> $$ \sum_{1 &lt;= l &lt;= r &lt;= n} max(gcd(a_i, a_j))  ~~~  {( i, j\notin [l, r])}$$</p>
<a id="more"></a>
<p>参考思路： <a href="http://async.icpc-camp.org/d/418-codeforces-round-352e-ultimate-weirdness-of-an-array/4" target="_blank" rel="external">http://async.icpc-camp.org/d/418-codeforces-round-352e-ultimate-weirdness-of-an-array/4</a></p>
<p>我们维护一个集合S，集合中记录的是一些区间[l, r]。对于集合中任一一个区间[l, r]，使得$max(gcd(a_i, a_j)) &lt; d~ (i, j, \notin [l, r])$时，我们记录此时的区间个数A[d] = S.size()。</p>
<p>可得：<br>$$ans = \sum d * num[d] ~~~(num[d] = A[d+1] - A[d])$$</p>
<p>然后需要注意的地方便是如何维护集合S:<br>最初S中有n * (n + 1) 个元素。<br>从大到小枚举d，此时我们想从集合S删掉的元素为：当删掉[l, r]后, max_gcd为d的倍数。</p>
<p>我们将所有d的倍数列出来，进行排序。此时需要删掉的区间有：</p>
<ol>
<li>删掉中间一部分，使得左右各至少有一个d的倍数。</li>
<li>删掉左边的一部分，最少保留最右边的两个d的倍数。</li>
<li>删掉右边的一部分，最少保留最左边的两个d的倍数。</li>
</ol>
<p>需要删的部分确定了，接下来就是确定怎么删的问题。暴力会TLE，直接减也会导致重复。</p>
<p>对于最初所有的二元数组[l, r] (l &lt;= r)， 我们可以看作为一个以 x=y 为底边，x轴为腰的一个等腰直角三角形。<br>每当删除一个区间[l, r]，对于任意区间[i, j] ($ l &lt;= i &lt;= j &lt;= r$) ，我们也应该删除。<br>在图形上表示出来的意义就是，对于任意的i (l &lt;= i &lt;= r)，删掉 j &lt;= r 的部分。（自己动手画一下）。于是便可以用数据结构进行维护了。</p>
<p>我用的线段树：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MEM(arr, v) memset(arr, v, sizeof(arr))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> L LL, l, MID</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> R RR, MID + 1, r</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LL mask &lt;&lt; 1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> RR mask &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MID ((l + r) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mn[N &lt;&lt; <span class="number">2</span>], lazy[N &lt;&lt; <span class="number">2</span>], mx[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> area[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> mask, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[mask] == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    mn[LL] = mn[RR] = mx[LL] = mx[RR] = lazy[mask];</span><br><span class="line">    area[LL] = (<span class="keyword">long</span> <span class="keyword">long</span>)(MID - l + <span class="number">1</span>) * mn[LL];</span><br><span class="line">    area[RR] = (<span class="keyword">long</span> <span class="keyword">long</span>)(r - MID) * mn[RR];</span><br><span class="line">    lazy[LL] = lazy[RR] = lazy[mask];</span><br><span class="line">    lazy[mask] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    mn[mask] = min(mn[LL], mn[RR]);</span><br><span class="line">    mx[mask] = max(mx[LL], mx[RR]);</span><br><span class="line">    area[mask] = area[LL] + area[RR];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> mask, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll &gt; r || rr &lt; l || h &lt;= mn[mask]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        mn[mask] = mx[mask] = area[mask] = max(mx[mask], h);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= l &amp;&amp; rr &gt;= r &amp;&amp; h &gt;= mx[mask]) &#123;</span><br><span class="line">        mn[mask] = lazy[mask] = mx[mask] = h;</span><br><span class="line">        area[mask] = (<span class="keyword">long</span> <span class="keyword">long</span>)(r - l + <span class="number">1</span>) * h;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        push_down(mask, l, r);</span><br><span class="line">        update(L, ll, rr, h);</span><br><span class="line">        update(R, ll, rr, h);</span><br><span class="line">        push_up(mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> l[N], r[N], l2[N], r2[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        MEM(mn, <span class="number">0</span>), MEM(mx, <span class="number">0</span>), MEM(area, <span class="number">0</span>), MEM(lazy, -<span class="number">1</span>), MEM(l, -<span class="number">1</span>), MEM(r, -<span class="number">1</span>), MEM(l2, -<span class="number">1</span>), MEM(r2, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        FOR(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            m = max(x, m);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= x; ++j) &#123; <span class="comment">//其实对于每个d，只用维护最左和最右两个数就够了</span></span><br><span class="line">                <span class="keyword">if</span>(x % j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(l[j] == -<span class="number">1</span>) l[j] = i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(l2[j] == -<span class="number">1</span>) l2[j] = i;</span><br><span class="line">                r2[j] = r[j], r[j] = i;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j * j == x) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(l[x / j] == -<span class="number">1</span>) l[x / j] = i;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(l2[x / j] == -<span class="number">1</span>) l2[x / j] = i;</span><br><span class="line">                r2[x / j] = r[x / j], r[x / j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FOR(i, <span class="number">1</span>, n) update(<span class="number">1</span>, <span class="number">1</span>, n, i, i, i-<span class="number">1</span>); <span class="comment">// 最开始都是矩形，剪掉一部分成三角形的形状</span></span><br><span class="line">        DWN(i, m + <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l[i] != r[i]) &#123;</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, n, l[i]+<span class="number">1</span> , r[i]-<span class="number">1</span>  , r[i] - <span class="number">1</span>); <span class="comment">//删掉中间</span></span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>      , r2[i]- <span class="number">1</span>, r2[i] - <span class="number">1</span>);<span class="comment">//删左边</span></span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, n, l2[i]+<span class="number">1</span>, n       , n);<span class="comment">//删右边</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = (<span class="keyword">long</span> <span class="keyword">long</span>)n * n - area[<span class="number">1</span>];<span class="comment">//前面加不加n*n不影响，但是加上以后实际意义为剩余三角形的面积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">        FOR(i, <span class="number">1</span>, m) ret += (ans[i+<span class="number">1</span>] - ans[i]) * i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>对数论不是很在行…每次碰到gcd相关的题都是一脸懵逼…以后遇到这种题还是多总结一下吧。</p>
<p>最初以为是要分解质因子，然后用容斥乱搞一番，结果发现完全搞不出来..</p>
<p>题意: $1 &lt;= n &lt;= 2 * 10^5$， 求<br> $$ \sum_{1 &lt;= l &lt;= r &lt;= n} max(gcd(a_i, a_j))  ~~~  {( i, j\notin [l, r])}$$</p>]]>
    
    </summary>
    
      <category term="Codeforces" scheme="http://teveillan.com/tags/Codeforces/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Topcoder SRM 677 Div1]]></title>
    <link href="http://teveillan.com/2016/04/06/SRM-677-DIV1/"/>
    <id>http://teveillan.com/2016/04/06/SRM-677-DIV1/</id>
    <published>2016-04-06T04:58:13.000Z</published>
    <updated>2016-05-31T14:35:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Easy:_DoubleOrOneEasy">Easy:  DoubleOrOneEasy</h2><p>给出a, b, A, B,有两种操作：</p>
<ul>
<li>a, b同时乘2</li>
<li>a, b同时加1</li>
</ul>
<p>问最少经过多少次操作使得 a == A &amp;&amp; b == b<br><a id="more"></a><br>首先明确一点，在什么情况下有解。</p>
<p>假如进行过x次乘法之后，a变为aa, b变为bb。<br>令$ aa = a * 2^x + y, bb = b * 2^x + z $，则y == z。</p>
<p>也就是说，如果有解，则存在一个x，使得<br> $A - a * 2^x == B - b * 2 ^ x$</p>
<p>一般来说这样的x是只有一个的(A == B &amp;&amp; a == b时特殊)。<br>贪心找到最大的x，就是最后进行过乘法的次数。<br>然后在此基础上找加法的个数。</p>
<p>还是令 $y = A - a * 2^x$<br>首先贪心，最开始先进行$y / (1&lt;&lt;x)$次加法操作, 还剩下$z = y \% (1&lt;&lt;x) $需要补，再加上bitcount(z)就好了（自己想为什么）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> aa, <span class="keyword">int</span> bb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -<span class="number">1</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a &lt;= aa &amp;&amp; b &lt;= bb) &#123;</span><br><span class="line">        <span class="keyword">if</span>(aa - a == bb - b) ret = max(ret, num);</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>, b &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        ++num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DoubleOrOneEasy</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">minimalSteps</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> aa, <span class="keyword">int</span> bb)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = solve(a, b, aa, bb);</span><br><span class="line">            <span class="keyword">if</span>(num == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = aa - (a &lt;&lt; num);</span><br><span class="line">            <span class="keyword">return</span> num + tmp / (<span class="number">1</span>&lt;&lt;num) + __builtin_popcount(tmp % (<span class="number">1</span>&lt;&lt;num));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Medium:_DiameterOfRandomTree">Medium: DiameterOfRandomTree</h2><p>给出一个棵树,每条边等概率长度为1或2，求树的直径。</p>
<p>用<code>dp[root][d1][l1]</code>表示根为root的子树，直径为d1，从根往下最长的链长度为l1的方案数。<br><code>dp[son][d2][l2]</code>表示子树的状态。<br>状态转移公式:</p>
<blockquote>
<p>$$ dp[root][max(max(d1, d2), l1 + l2 + 1)][max(l1, l2 + 1)] += dp[root][d1][l1] * dp[son][d2][l2] $$</p>
<p>$$ dp[root][max(max(d1, d2), l1 + l2 + 2)][max(l1, l2 + 2)] += dp[root][d1][l1] * dp[son][d2][l2] $$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">VI head[<span class="number">55</span>];</span><br><span class="line">LL dp[<span class="number">55</span>][<span class="number">2</span>][<span class="number">101</span>][<span class="number">101</span>], max_l[<span class="number">55</span>], dia[<span class="number">55</span>];<span class="comment">//dp中加了一维作滚动数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mem(dp), mem(max_l), mem(dia);</span><br><span class="line">    REP(i, <span class="number">50</span>) head[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sta = <span class="number">0</span>;</span><br><span class="line">    dp[cur][sta][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to: head[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(to == pre) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> to_sta = dfs(to, cur); sta ^= <span class="number">1</span>;</span><br><span class="line">        mem(dp[cur][sta]);</span><br><span class="line">        FOR(d1, <span class="number">0</span>, dia[cur])</span><br><span class="line">            FOR(l1, <span class="number">0</span>, max_l[cur])</span><br><span class="line">                FOR(d2, <span class="number">0</span>, dia[to])</span><br><span class="line">                    FOR(l2, <span class="number">0</span>, max_l[to]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> d = max(max(d1, d2), l1 + l2 + <span class="number">1</span>), l = max(l1, l2 + <span class="number">1</span>);</span><br><span class="line">                        dp[cur][sta][d][l] += dp[cur][sta^<span class="number">1</span>][d1][l1] * dp[to][to_sta][d2][l2];</span><br><span class="line"></span><br><span class="line">                        d = max(max(d1, d2), l1 + l2 + <span class="number">2</span>), l = max(l1, l2 + <span class="number">2</span>);</span><br><span class="line">                        dp[cur][sta][d][l] += dp[cur][sta^<span class="number">1</span>][d1][l1] * dp[to][to_sta][d2][l2];</span><br><span class="line">                    &#125;</span><br><span class="line">        dia[cur] = max(max(dia[cur], dia[to]), max_l[cur] + max_l[to] + <span class="number">2</span>);</span><br><span class="line">        max_l[cur] = max(max_l[cur], max_l[to] + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> DiameterOfRandomTree</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getExpectation</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">            init();</span><br><span class="line">            REP(i, a.size()) &#123;</span><br><span class="line">                head[a[i]].pb(b[i]);</span><br><span class="line">                head[b[i]].pb(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sta = dfs(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">double</span> ret = <span class="number">0</span>, div = (<span class="keyword">double</span>)(<span class="number">1l</span>l &lt;&lt; a.size());</span><br><span class="line">            FOR(i, <span class="number">0</span>, dia[<span class="number">0</span>])</span><br><span class="line">                FOR(j, <span class="number">0</span>, max_l[<span class="number">0</span>])</span><br><span class="line">                    ret += (<span class="keyword">double</span>) dp[<span class="number">0</span>][sta][i][j] / div * i;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Easy:_DoubleOrOneEasy">Easy:  DoubleOrOneEasy</h2><p>给出a, b, A, B,有两种操作：</p>
<ul>
<li>a, b同时乘2</li>
<li>a, b同时加1</li>
</ul>
<p>问最少经过多少次操作使得 a == A &amp;&amp; b == b<br>]]>
    
    </summary>
    
      <category term="topcoder" scheme="http://teveillan.com/tags/topcoder/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5657 CA Loves Math]]></title>
    <link href="http://teveillan.com/2016/04/03/HDU-5657-CA-Loves-Math/"/>
    <id>http://teveillan.com/2016/04/03/HDU-5657-CA-Loves-Math/</id>
    <published>2016-04-03T12:44:47.000Z</published>
    <updated>2016-04-04T08:54:40.000Z</updated>
    <content type="html"><![CDATA[<p>传送门: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5657" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5657</a><br>题意：求[1, $A^n_{(10)}$]中，长度小于等于n，且为k的倍数的数有多少。</p>
<p>此题…巨坑…</p>
<p>比赛时思路是对的，对k进行分类讨论..然并卵…</p>
<p>等A了才发现几个大坑:</p>
<ol>
<li>k的阀值在30000～60000之间才能A，高了低了都不行（想起了那些年计算几何中调精度的日子..）</li>
<li>queue真心慢…</li>
<li>n = 0 or n = 1时坑比较多，建议单独处理</li>
<li><strong>前导0是不算的!!!</strong>。但是题目给的数据比较坑，刚好两位，如果算了前导0，刚好也对。（包括第一题中MOD值为1e8+7…我充满了对这个世界的怨念…）</li>
</ol>
<p>所以说一直WA的可以按我上面的几点检查一下…我感觉我应该是把坑都踩完了…<br><a id="more"></a><br>—————————————正文———————————————</p>
<p>对k进行分类，假设阀值为N（参考上面第一点）。<br>当k &gt;= N时，枚举k的倍数，再判断数字是否重复。<br>当k &lt; N时：<br>记dp[pos][j]：当用的数字集合为pos(状态压缩), 且mod k = j时的数目</p>
<p>转移方程：<br>$$ dp[ pos| (1&lt;&lt;i) ] [ (j + A^x ) \% k] += dp[pos][j] $$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> A, LL x)</span> </span>&#123;<span class="comment">//判断数字是否重复</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = x % A;</span><br><span class="line">        <span class="keyword">if</span>(pos &amp; (<span class="number">1</span>&lt;&lt;tmp)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        pos |= (<span class="number">1</span>&lt;&lt;tmp);</span><br><span class="line">        x /= A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">11</span>][N], f[<span class="number">12</span>];</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> k == <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> A / k;</span><br><span class="line"></span><br><span class="line">    n = min(n, A);</span><br><span class="line">    LL NN = <span class="number">1</span>;</span><br><span class="line">    REP(i, n) NN *= A;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= N) &#123; <span class="comment">//k&gt;=N时枚举k的倍数</span></span><br><span class="line">        LL tmp = k;</span><br><span class="line">        <span class="keyword">while</span>(tmp &lt;= NN) &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(A, tmp)) ++ret;</span><br><span class="line">            tmp += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">1</span>, n) f[i] = (f[i-<span class="number">1</span>] * A) % k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    REP(pos, <span class="number">1</span>&lt;&lt;A) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = __builtin_popcount(pos);</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">        REP(i, A) <span class="keyword">if</span>((pos &amp; (<span class="number">1</span>&lt;&lt;i)) == <span class="number">0</span>)</span><br><span class="line">            REP(j, k) <span class="keyword">if</span>(dp[pos][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = pos | (<span class="number">1</span>&lt;&lt;i), y = (j + i * f[num]) % k;</span><br><span class="line">                dp[x][y] += dp[pos][j];</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) ret += dp[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(check(A, NN) &amp;&amp; (NN % k == <span class="number">0</span>)) ++ret; <span class="comment">//特判A^n</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, A, n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(A, n, k) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>传送门: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5657">http://acm.hdu.edu.cn/showproblem.php?pid=5657</a><br>题意：求[1, $A^n_{(10)}$]中，长度小于等于n，且为k的倍数的数有多少。</p>
<p>此题…巨坑…</p>
<p>比赛时思路是对的，对k进行分类讨论..然并卵…</p>
<p>等A了才发现几个大坑:</p>
<ol>
<li>k的阀值在30000～60000之间才能A，高了低了都不行（想起了那些年计算几何中调精度的日子..）</li>
<li>queue真心慢…</li>
<li>n = 0 or n = 1时坑比较多，建议单独处理</li>
<li><strong>前导0是不算的!!!</strong>。但是题目给的数据比较坑，刚好两位，如果算了前导0，刚好也对。（包括第一题中MOD值为1e8+7…我充满了对这个世界的怨念…）</li>
</ol>
<p>所以说一直WA的可以按我上面的几点检查一下…我感觉我应该是把坑都踩完了…<br>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Topcoder SRM 678 Div1]]></title>
    <link href="http://teveillan.com/2016/04/01/SRM-678-DIV1/"/>
    <id>http://teveillan.com/2016/04/01/SRM-678-DIV1/</id>
    <published>2016-04-01T13:53:40.000Z</published>
    <updated>2016-05-31T14:35:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Easy:_A_New_Hope">Easy: A New Hope</h2><p>题意：假设一个星期有n天，一个人有n件不同的衣服（标号1~n），每件衣服每周穿一件。由此有N！种穿的方式。<br>但是洗一件衣服需要D天（第x天洗了，x+D天才能穿）。<br>现已知第一周和最后一周穿衣服的顺序，问中间最少隔了几个星期。</p>
<a id="more"></a>
<p>用数学方法表示，每周穿衣服的顺序可标示为长度为n的排序。<br>如{1, 2, 3, 4}。假设D＝3，则4号衣服下周最早可以在周三穿，提前了一天(4 - 3 ＝ 1)。</p>
<p>由此便清楚了，本质上就是第一周的排序$P_1$，移动某些数字后，使其状态等于最后一周的状态$P_m$。而每个数字一周最多可以向前移动<code>n-D</code>位。</p>
<p>枚举每个数字，求移动周数的最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ANewHope</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; firstWeek, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; lastWeek, <span class="keyword">int</span> D)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = firstWeek.size();</span><br><span class="line">            D = n - D;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;first_p, last_p;</span><br><span class="line">            REP(i, n) first_p[ firstWeek[i] ] = i, last_p[ lastWeek[i] ] = i;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            FOR(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(last_p[i] &lt; first_p[i]) </span><br><span class="line">                    ret = max(ret, (first_p[i] - last_p[i] + D - <span class="number">1</span>) / D);<span class="comment">//上取整</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret + <span class="number">1</span>; <span class="comment">//加上第一周</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Medium:_The_Empire_Strikes_Back">Medium: The Empire Strikes Back</h2><p>题意：有n颗行星，坐标$(x_i, y_i)$。有m发子弹，当子弹威力为w时，对准一颗行星，可以消灭(0, 0)~$(x_i, y_i)$矩形内的行星。<br>问子弹威力最小应为多少。</p>
<p>这种题上来不用多说先二分枚举子弹威力mid…</p>
<p>行星坐标$(x_i, y_i)$以及矩形右上角的坐标$(x_i+mid, y_i+mid)$分开存。<br>都对y从大到小进行排序。<br>贪心。保存此时能毁灭的x的最大值max_x，随着行星坐标$y_i$的减小，求矩形坐标中$y_j+mid &gt; y_i$中最大的$x_j+mid$，并更新为max_x</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;pii&gt;&amp;vec, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt;f(vec);</span><br><span class="line">    <span class="keyword">for</span>(pii &amp;tmp: f) tmp.first += mid, tmp.second += mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_x = -<span class="number">1</span>, id = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    DWN(i, n-<span class="number">1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(max_x &lt; vec[i].second) &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">            <span class="keyword">while</span>(id &gt;= <span class="number">0</span> &amp;&amp; f[id].first &gt;= vec[i].first) &#123;</span><br><span class="line">                max_x = max(max_x, f[id].second);</span><br><span class="line">                id --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TheEmpireStrikesBack</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> AX, <span class="keyword">int</span> BX, <span class="keyword">int</span> CX, <span class="keyword">int</span> AY, <span class="keyword">int</span> BY, <span class="keyword">int</span> CY, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;pii&gt;vec;</span><br><span class="line">            LL x = AX, y = AY;</span><br><span class="line">            vec.pb(pii(y, x));</span><br><span class="line">            FOR(i, <span class="number">1</span>, n-<span class="number">1</span>) &#123;</span><br><span class="line">                x = (x * BX + CX) % MOD;</span><br><span class="line">                y = (y * BY + CY) % MOD;</span><br><span class="line">                vec.pb(pii(y, x));</span><br><span class="line">            &#125;</span><br><span class="line">            sort(vec.begin(), vec.end());</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = MOD, ans;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(solve(vec, n, m, mid)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Easy:_A_New_Hope">Easy: A New Hope</h2><p>题意：假设一个星期有n天，一个人有n件不同的衣服（标号1~n），每件衣服每周穿一件。由此有N！种穿的方式。<br>但是洗一件衣服需要D天（第x天洗了，x+D天才能穿）。<br>现已知第一周和最后一周穿衣服的顺序，问中间最少隔了几个星期。</p>]]>
    
    </summary>
    
      <category term="topcoder" scheme="http://teveillan.com/tags/topcoder/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac OS Sublime Text 3 C/C++ 配置]]></title>
    <link href="http://teveillan.com/2016/03/30/Mac-OS-Sublime-Text-3-C-C-%E9%85%8D%E7%BD%AE/"/>
    <id>http://teveillan.com/2016/03/30/Mac-OS-Sublime-Text-3-C-C-配置/</id>
    <published>2016-03-30T08:57:59.000Z</published>
    <updated>2016-03-30T09:22:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装sublime_text_3_插件"><strong>安装sublime text 3 插件</strong></h2><p><strong>1.安装 Package Control组件：</strong></p>
<ul>
<li>按 control+` (键盘上1左边的按钮)调出console控制台;</li>
<li>粘贴以下代码到底部命令行并回车:</li>
</ul>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), <span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</span><br></pre></td></tr></table></figure>
<p><strong>2.用Package Control安装插件的方法</strong></p>
<ul>
<li><code>Preference -&gt; Package Control</code>打开控制栏，输入<code>install Package</code>回车。</li>
</ul>
<p><strong>3.常用插件</strong></p>
<ol>
<li><code>SublimeCodeIntel</code>:  代码提示及自动补全</li>
<li><code>SideBar Enhancements</code>: 改进侧边栏</li>
<li><code>SideBar Folders</code>: 增加了侧边栏对于文件夹的支持</li>
</ol>
<p>暂时没用到这么多..以后慢慢补吧…</p>
<p><br> </p>
<h2 id="内置输入数据"><strong>内置输入数据</strong></h2><p>本以为上面的弄完就万事大吉，但在编译运行的时候发现一个问题：运行时无法在控制台输入数据。愁。</p>
<p>解决办法：<br><code>Tools -&gt; Build System -&gt; New Build System</code> 新建编译系统。在新打开的窗口中替换为以下代码</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">cmd</span>": <span class="value">[<span class="string">"bash"</span>, <span class="string">"-c"</span>, <span class="string">"g++ '$&#123;file&#125;' -o '$&#123;file_path&#125;/$&#123;file_base_name&#125;' &amp;&amp; osascript -e 'tell application \"Terminal\" to activate do script \"clear&amp;&amp;$&#123;file_path&#125;/$&#123;file_base_name&#125; &amp;&amp; read -p \\\"Press Enter to exit.\\\"&amp;&amp;exit\"'"</span>]</span>,</span><br><span class="line">    "<span class="attribute">file_regex</span>": <span class="value"><span class="string">"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$"</span></span>,</span><br><span class="line">    "<span class="attribute">working_dir</span>": <span class="value"><span class="string">"$&#123;file_path&#125;"</span></span>,</span><br><span class="line">    "<span class="attribute">selector</span>": <span class="value"><span class="string">"source.c, source.c++"</span></span>,</span><br><span class="line"></span><br><span class="line">    "<span class="attribute">variants</span>":</span><br><span class="line">    <span class="value">[</span><br><span class="line">        &#123;</span><br><span class="line">            "<span class="attribute">name</span>": <span class="value"><span class="string">"Run"</span></span>,</span><br><span class="line">            "<span class="attribute">cmd</span>": <span class="value">[<span class="string">"bash"</span>, <span class="string">"-c"</span>, <span class="string">"g++ '$&#123;file&#125;' -o '$&#123;file_path&#125;/$&#123;file_base_name&#125;' &amp;&amp; '$&#123;file_path&#125;/$&#123;file_base_name&#125;'"</span>]</span><br><span class="line">        </span>&#125;</span><br><span class="line">    ]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>Command + s 保存，命名为MyC++。<br>在<code>Tools -&gt; Build System</code>选中<code>MyC++</code>。<br><code>Command + Shift + B</code>编译，选<code>MyC++</code>（不加Run的那个）。</p>
<p>搞定~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="安装sublime_text_3_插件"><strong>安装sublime text 3 插件</strong></h2><p><strong>1.安装 Package Control组件：</strong></p>
<ul>
<li>按 control+` (键盘上1左边的按钮)调出console控制台;</li>
<li>粘贴以下代码到底部命令行并回车:</li>
</ul>]]>
    
    </summary>
    
      <category term="MacOS" scheme="http://teveillan.com/tags/MacOS/"/>
    
      <category term="SublimeText" scheme="http://teveillan.com/tags/SublimeText/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5649 DZY Loves Sorting]]></title>
    <link href="http://teveillan.com/2016/03/26/HDU-5649-DZY-Loves-Sorting/"/>
    <id>http://teveillan.com/2016/03/26/HDU-5649-DZY-Loves-Sorting/</id>
    <published>2016-03-26T14:40:46.000Z</published>
    <updated>2016-03-26T14:42:01.000Z</updated>
    <content type="html"><![CDATA[<p>祭奠我因为一个坑被白白浪费的一天…</p>
<p>基础数据结构。线段树。区间更新，区间查询。</p>
<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5649" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5649</a></p>
<p>此题的难点在于，每次排序的时候，每个数在排序之后的位置不能一个一个来处理，这样复杂度肯定是不够的。</p>
<p>So, 我们枚举一个答案mid，这样对于所有的数，只用区分它是比mid大，还是比mid小，由此进行批量处理。</p>
<a id="more"></a>
<blockquote>
<ol>
<li>枚举mid。</li>
<li>每次操作开始，把初始位置上小于等于mid的位置标为1，剩下的标为0.</li>
<li>对于每次排序。（假如是升序）先进行区间查询[l, r]区间内1的个数num。 把[l, l+num-1]全更新为1，剩下的更新为0</li>
<li>查看第k位上是否为1。</li>
</ol>
</blockquote>
<p>可以肯定的一点是，经过m次排序之后，最后排序的结果不以我们枚举的mid而发生变化。</p>
<p>当我们第一次枚举mid = n的时候，在所有排序结束后，必然是所有位置上的数都为1.<br>当mid在逐渐变小的过程中，在排序结束后，某些位置上的数会由1变为0。<br>当第k位上恰好最后为1的时候，此时的mid值即为需要的答案。</p>
<p>当然，直接枚举也是会超时的，加个二分就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> L pos&lt;&lt;1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> R pos&lt;&lt;1|1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MID ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> LL L, l, MID</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> RR R, MID+1, r</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> node[N&lt;&lt;<span class="number">2</span>], lazy[N&lt;&lt;<span class="number">2</span>], v[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;pii, <span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    lazy[pos] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) node[pos] = (v[l] &lt;= value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        build(LL, value);</span><br><span class="line">        build(RR, value);</span><br><span class="line">        node[pos] = node[L] + node[R];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r || lazy[pos] == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    lazy[L] = lazy[R] = lazy[pos];</span><br><span class="line">    node[L] = lazy[pos] * (MID - l + <span class="number">1</span>);</span><br><span class="line">    node[R] = lazy[pos] * (r - MID);</span><br><span class="line">    lazy[pos] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;node[pos] = node[L] + node[R];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> node[pos];</span><br><span class="line">    push_down(pos, l, r);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= MID) ret += query(LL, ll, rr);</span><br><span class="line">    <span class="keyword">if</span>(rr &gt;  MID) ret += query(RR, ll, rr);</span><br><span class="line">    push_up(pos, l, r);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll &lt;= l &amp;&amp; r &lt;= rr) node[pos] = (r - l + <span class="number">1</span>) * value, lazy[pos] = value;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        push_down(pos, l, r);</span><br><span class="line">        <span class="keyword">if</span>(ll &lt;= MID) update(LL, ll, rr, value);</span><br><span class="line">        <span class="keyword">if</span>(rr &gt;  MID) update(RR, ll, rr, value);</span><br><span class="line">        push_up(pos, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> mid, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n, mid);</span><br><span class="line"></span><br><span class="line">    REP(i, vec.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = vec[i].first.first, r = vec[i].first.second, flag = vec[i].second;</span><br><span class="line">        <span class="keyword">int</span> num = query(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span> || num == r - l + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, l+num-<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l+num, r, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, r-num+<span class="number">1</span>, r, <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, r-num, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">1</span>, <span class="number">1</span>, n, k, k) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n, m, k, x, y, z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        FOR(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">        REP(i, m) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;z, &amp;x, &amp;y);</span><br><span class="line">            vec.pb(make_pair(pii(x, y), z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n, ans;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(solve(MID, n, m, k)) ans = MID, r = MID - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = MID + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>祭奠我因为一个坑被白白浪费的一天…</p>
<p>基础数据结构。线段树。区间更新，区间查询。</p>
<p>传送门：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5649">http://acm.hdu.edu.cn/showproblem.php?pid=5649</a></p>
<p>此题的难点在于，每次排序的时候，每个数在排序之后的位置不能一个一个来处理，这样复杂度肯定是不够的。</p>
<p>So, 我们枚举一个答案mid，这样对于所有的数，只用区分它是比mid大，还是比mid小，由此进行批量处理。</p>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5648 DZY Loves Math]]></title>
    <link href="http://teveillan.com/2016/03/25/HDU-5648-DZY-Loves-Math/"/>
    <id>http://teveillan.com/2016/03/25/HDU-5648-DZY-Loves-Math/</id>
    <published>2016-03-25T04:37:42.000Z</published>
    <updated>2016-03-25T04:43:20.000Z</updated>
    <content type="html"><![CDATA[<p>DZY Loves 系列…DZY大神你怎么什么都喜欢…</p>
<p>传送门: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5648" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5648</a></p>
<p>题意: 求$\sum_{i=1} ^ n \sum_{j=1} ^m gcd(i ~ AND ~j, i~ OR~ j) $, 1 &lt;= n, m &lt;= 15000</p>
<p>用三进制表示状态值, 每一位上的值:</p>
<ul>
<li>0: 表示均为0</li>
<li>1: 表示一个为0, 一个为1</li>
<li>2: 表示两个都为1 </li>
</ul>
<a id="more"></a>
<p>记 $ l = \log_2 {max(n, m)} $，则枚举量为$3^l$</p>
<p>每枚举一个状态值, 接下来便是求此状态的方案数目num, ans += num * gcd 。</p>
<p>记AND值为x,OR 值为 y,令z = x ^ y .</p>
<p>假设在每种方案下，i = a | x, j = b | x，很容易看出 a | b = a + b = z。<br>代入以下不等式：</p>
<blockquote>
<p>$ a + x &lt;= n $<br>$ b + x &lt;= m $</p>
</blockquote>
<p>化简以后得到</p>
<blockquote>
<p>$ z-m+x &lt;=  a &lt;= n-x $</p>
</blockquote>
<p>就是求 <strong>取z中二进制位为1的某些位组成a，且使a满足上面的不等式</strong> 的a的取值范围。</p>
<p>熟悉数位DP的朋友很容易就看出来接下的步骤了。运用数位DP求num值就好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> l, <span class="keyword">int</span> cur_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= cur_value) <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; __builtin_popcount(pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;l) &amp; pos) &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;l) &lt;= cur_value) ret += dfs(pos^(<span class="number">1</span>&lt;&lt;l), l-<span class="number">1</span>, cur_value - (<span class="number">1</span>&lt;&lt;l));</span><br><span class="line">        ret += dfs(pos^(<span class="number">1</span>&lt;&lt;l), l-<span class="number">1</span>, cur_value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret += dfs(pos, l-<span class="number">1</span>, cur_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> max_value)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//数位DP,求在pos中选部分二进制为1的位组成a,且a&lt;=max_value的方案数</span></span><br><span class="line">    <span class="keyword">if</span>(max_value &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;len) &lt;= max_value) len++;</span><br><span class="line"></span><br><span class="line">    pos = pos &amp; ((<span class="number">1</span>&lt;&lt;len) - <span class="number">1</span>);<span class="comment">//把高位舍掉,反正也没用</span></span><br><span class="line">    <span class="keyword">int</span> ret = dfs(pos, len-<span class="number">1</span>, max_value);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;len) &lt;= n || (<span class="number">1</span>&lt;&lt;len) &lt;= m) len++;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        REP(i, len) s *= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        REP(i, s) &#123; <span class="comment">// 三进制枚举状态值</span></span><br><span class="line">            <span class="keyword">int</span> tmp = i, x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="comment">// x为and值, y为or值</span></span><br><span class="line">            REP(j, len) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp % <span class="number">3</span> == <span class="number">1</span>) y |= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tmp % <span class="number">3</span> == <span class="number">2</span>) x |= (<span class="number">1</span>&lt;&lt;j), y |= (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                tmp /= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; n || x &gt; m) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> z = x ^ y;</span><br><span class="line">            <span class="keyword">int</span> value = get(z, n-x) - get(z, z-m+x-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span>) &#123; <span class="comment">//这里要注意.当x==0时, a 和 b 都不能为0</span></span><br><span class="line">                <span class="keyword">if</span>(z &lt;= n) --value;</span><br><span class="line">                <span class="keyword">if</span>(z &lt;= m) --value;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += __gcd(x, y) * max(value, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>DZY Loves 系列…DZY大神你怎么什么都喜欢…</p>
<p>传送门: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5648">http://acm.hdu.edu.cn/showproblem.php?pid=5648</a></p>
<p>题意: 求$\sum_{i=1} ^ n \sum_{j=1} ^m gcd(i ~ AND ~j, i~ OR~ j) $, 1 &lt;= n, m &lt;= 15000</p>
<p>用三进制表示状态值, 每一位上的值:</p>
<ul>
<li>0: 表示均为0</li>
<li>1: 表示一个为0, 一个为1</li>
<li>2: 表示两个都为1 </li>
</ul>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5296 Annoying problem]]></title>
    <link href="http://teveillan.com/2015/12/16/HDU-5296-Annoying-problem/"/>
    <id>http://teveillan.com/2015/12/16/HDU-5296-Annoying-problem/</id>
    <published>2015-12-16T14:39:30.000Z</published>
    <updated>2015-12-16T14:40:15.000Z</updated>
    <content type="html"><![CDATA[<p>最初以为是DP，结果发现并不是。= =</p>
<p>题意：在一棵树上，边有权重。有两种操作：</p>
<ol>
<li>如果v不在集合中，那么将点v放入到集合</li>
<li>如果v在集合中，那么将v移出集合<br>求每次操作后，选择一些边将集合中的点连在一起，问边权和为多少。</li>
</ol>
<p>先初始化dfs序，以及跟节点到点x的距离dis。每当我们要插入一个点x，找到在集合中且dfs序比x第一个大的点u，以及第一个小的点v。则新增的边的边权为<br>$$dis[x]−dis[lca(x,u)]−dis[lca(x,v)]+dis[lca(u,v)]$$</p>
<a id="more"></a>
<p>如果没有dfs序比v大或者比v小的点，则u v分别取集合中dfs序最大和最小的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; head[N];</span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line"><span class="keyword">int</span> dfn[N], deep[N], dis[N], fa[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pre, <span class="keyword">int</span> &amp;t)</span> </span>&#123; <span class="comment">//初始化dfs序，以及fa(在线求lca)</span></span><br><span class="line">    dfn[cur] = ++t;</span><br><span class="line">    deep[cur] = deep[pre] + <span class="number">1</span>;</span><br><span class="line">    fa[cur][<span class="number">0</span>] = pre;</span><br><span class="line">    FOR(i, <span class="number">1</span>, <span class="number">19</span>) fa[cur][i] = fa[ fa[cur][i-<span class="number">1</span>] ][i-<span class="number">1</span>];</span><br><span class="line">    REP(i, head[cur].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = head[cur][i].first, c = head[cur][i].second;</span><br><span class="line">        <span class="keyword">if</span>(to != pre) &#123;</span><br><span class="line">            dis[to] = dis[cur] + c;</span><br><span class="line">            dfs(to, cur, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deep[u] &lt; deep[v]) swap(u, v);</span><br><span class="line">    <span class="keyword">int</span> tmp = deep[u] - deep[v];</span><br><span class="line">    REP(i, <span class="number">20</span>) <span class="keyword">if</span>(tmp &amp; (<span class="number">1</span> &lt;&lt; i)) u = fa[u][i];</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u;</span><br><span class="line">    DWN(i, <span class="number">19</span>, <span class="number">0</span>) <span class="keyword">if</span>(fa[u][i] != fa[v][i])</span><br><span class="line">        u = fa[u][i], v = fa[v][i];</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;M;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">    visit[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(M.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        M[dfn[x]] = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it1, it2;</span><br><span class="line">    it1 = M.lower_bound(dfn[x]), it2 = it1;</span><br><span class="line">    <span class="keyword">if</span>(it1 == M.begin() || it1 == M.end()) it1 = M.begin(), it2 = M.end();</span><br><span class="line">    it2--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u = it1-&gt;second, v = it2-&gt;second;</span><br><span class="line">    ans += dis[x] - dis[lca(u, x)] - dis[lca(v, x)] + dis[lca(u, v)];</span><br><span class="line">    M[dfn[x]] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;ans)</span> </span>&#123;</span><br><span class="line">    visit[x] = <span class="number">0</span>;</span><br><span class="line">    M.erase(dfn[x]);</span><br><span class="line">    <span class="keyword">if</span>(M.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it1, it2;</span><br><span class="line">    it1 = M.lower_bound(dfn[x]), it2 = it1;</span><br><span class="line">    <span class="keyword">if</span>(it1 == M.begin() || it1 == M.end()) it1 = M.begin(), it2 = M.end();</span><br><span class="line">    it2--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u = it1-&gt;second, v = it2-&gt;second;</span><br><span class="line">    ans -= dis[x] - dis[lca(u, x)] - dis[lca(v, x)] + dis[lca(u, v)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, casnum, u, v, c, t, casid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        FOR(i, <span class="number">1</span>, n) head[i].clear();</span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">            head[u].pb(pii(v, c));</span><br><span class="line">            head[v].pb(pii(u, c));</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>, t);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++casid);</span><br><span class="line">        M.clear();</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="keyword">if</span>(u == <span class="number">1</span> &amp;&amp; !visit[v]) add(v, ans);</span><br><span class="line">            <span class="keyword">if</span>(u == <span class="number">2</span> &amp;&amp; visit[v]) del(v, ans);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>最初以为是DP，结果发现并不是。= =</p>
<p>题意：在一棵树上，边有权重。有两种操作：</p>
<ol>
<li>如果v不在集合中，那么将点v放入到集合</li>
<li>如果v在集合中，那么将v移出集合<br>求每次操作后，选择一些边将集合中的点连在一起，问边权和为多少。</li>
</ol>
<p>先初始化dfs序，以及跟节点到点x的距离dis。每当我们要插入一个点x，找到在集合中且dfs序比x第一个大的点u，以及第一个小的点v。则新增的边的边权为<br>$$dis[x]−dis[lca(x,u)]−dis[lca(x,v)]+dis[lca(u,v)]$$</p>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5293 Tree chain problem]]></title>
    <link href="http://teveillan.com/2015/11/23/HDU-5293-Tree-chain-problem/"/>
    <id>http://teveillan.com/2015/11/23/HDU-5293-Tree-chain-problem/</id>
    <published>2015-11-23T15:39:29.000Z</published>
    <updated>2015-11-23T15:40:15.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5293" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5293</a></p>
<p>题目大意：有个N的点的树。其中树上有M条已知的链，每条链有一个权值。从中选出任意个不相交的链使得链的权值和最大。</p>
<p>树形DP。<br>我们用dp[i]表示以i点为根的子树的最优解。<br>用sum[i]表示以i点为根的子树中不选i点的最优解，即$sum[i]=\sum dp[k] $  (k为i的儿子节点)</p>
<a id="more"></a>
<p>其中dp[i]不一定是一定要选取i点,因此，dp[i]也有可能等于sum[i]。</p>
<p>我们假设出一种情况，一颗以root为根的树，有一条链link: root -&gt; a -&gt; b ， 权值为x。<br>在知道除了root之外其他所有点的dp值及sum值已知的情况下，求出选取这条链情况下的root的dp值。</p>
<p>首先，sum[root]是可以求的。那么</p>
<blockquote>
<p>$$ dp[root] = sum[root] - dp[a] + sum[a] - dp[b]+ sum[b] + x $$</p>
</blockquote>
<p>(联系sum的定义理解这个式子)</p>
<p>理解以后这道题就迎刃而解了，无非就是求一次lca，然后对于如何快速在树上求一条链的sum和以及dp和做一次优化而已，用时间戳或者树链剖分的方法都好。</p>
<p>我这里用的时间戳加树状数组来进行优化的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CLR(arr) memset(arr, 0, sizeof(arr))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> node[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> value, <span class="keyword">int</span> n, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= n) &#123;</span><br><span class="line">        node[flag][x] += value;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        ret += node[flag][x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VI head[N], vec[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; lca[N], qhead[N];</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visit[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    visit[cur] = <span class="number">1</span>;</span><br><span class="line">    REP(i, head[cur].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = head[cur][i];</span><br><span class="line">        <span class="keyword">if</span>(visit[to]) <span class="keyword">continue</span>;</span><br><span class="line">        LCA(to, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    REP(i, qhead[cur].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = qhead[cur][i].first, x = qhead[cur][i].second;</span><br><span class="line">        <span class="keyword">if</span>(visit[to]) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = find(to);</span><br><span class="line">            lca[tmp].pb(pii(cur, to));</span><br><span class="line">            vec[tmp].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[cur] = pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l[N], r[N];</span><br><span class="line"><span class="keyword">int</span> dp[N], sum[N];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    visit[cur] = <span class="number">1</span>;</span><br><span class="line">    l[cur] = ++t;</span><br><span class="line">    REP(i, head[cur].size()) &#123;</span><br><span class="line">         <span class="keyword">int</span> to = head[cur][i];</span><br><span class="line">         <span class="keyword">if</span>(visit[to]) <span class="keyword">continue</span>;</span><br><span class="line">         dfs(to, n);</span><br><span class="line">         sum[cur] += dp[to];</span><br><span class="line">    &#125;</span><br><span class="line">    REP(i, lca[cur].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = lca[cur][i].first, v = lca[cur][i].second, x = vec[cur][i];</span><br><span class="line">        <span class="keyword">int</span> tmp = sum[cur] + query(l[u], <span class="number">0</span>) + query(l[v], <span class="number">0</span>) - query(l[u], <span class="number">1</span>) - query(l[v], <span class="number">1</span>) + x;</span><br><span class="line">        dp[cur] = max(tmp, dp[cur]);</span><br><span class="line">    &#125;</span><br><span class="line">    r[cur] = ++t;</span><br><span class="line">    dp[cur] = max(dp[cur], sum[cur]);</span><br><span class="line">    update(l[cur], sum[cur], n*<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    update(r[cur], -sum[cur], n*<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    update(l[cur], dp[cur], n*<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    update(r[cur], -dp[cur], n*<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n, m, u, v, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">         CLR(node);</span><br><span class="line">         FOR(i, <span class="number">1</span>, n) head[i].clear(), qhead[i].clear(), lca[i].clear(), vec[i].clear();</span><br><span class="line">         FOR(i, <span class="number">1</span>, n) fa[i] = i;</span><br><span class="line">         REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">            head[u].pb(v);</span><br><span class="line">            head[v].pb(u);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         REP(i, m) &#123;</span><br><span class="line">             <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;x);</span><br><span class="line">             qhead[u].pb(pii(v, x));</span><br><span class="line">             qhead[v].pb(pii(u, x));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">         <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">         t = <span class="number">0</span>;</span><br><span class="line">         CLR(visit);</span><br><span class="line">         LCA(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">         CLR(visit);</span><br><span class="line">         dfs(<span class="number">1</span>, n);</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5293">http://acm.hdu.edu.cn/showproblem.php?pid=5293</a></p>
<p>题目大意：有个N的点的树。其中树上有M条已知的链，每条链有一个权值。从中选出任意个不相交的链使得链的权值和最大。</p>
<p>树形DP。<br>我们用dp[i]表示以i点为根的子树的最优解。<br>用sum[i]表示以i点为根的子树中不选i点的最优解，即$sum[i]=\sum dp[k] $  (k为i的儿子节点)</p>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5291 Candy Distribution]]></title>
    <link href="http://teveillan.com/2015/11/22/HDU-5291-Candy-Distribution/"/>
    <id>http://teveillan.com/2015/11/22/HDU-5291-Candy-Distribution/</id>
    <published>2015-11-22T11:11:35.000Z</published>
    <updated>2015-11-22T11:15:22.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5291" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5291</a></p>
<p>题目大概意思就是有K种物品，第i种物品有ai个，要把全部的物品分成两堆，每个物品可以用也可以不用， 问最后两边物品数量一样多的方案数。</p>
<p>最直接的思路，定义dp[i][j]表示第i堆分完后第一个人比第二个人多j个糖果的方案数。枚举分第i堆糖果时第一个人比第二个人多分x个，则</p>
<blockquote>
<p>$$dp[i][j+x] += dp[i-1][j] * ( (a[i] - x) / 2 + 1 ) $$</p>
</blockquote>
<a id="more"></a>
<p>直接这么做的复杂度为$O(n^4)$，会超时。我们进行一次优化。</p>
<p>随着x的变化，$(a[i] - x) / 2 + 1$这个值根据奇偶性划分可分成两个等差数列。根据这个来进行处理，最后复杂度为O(n^3)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; VS;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; VD;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">40010</span>;</span><br><span class="line">LL dp[<span class="number">2</span>][N];</span><br><span class="line">LL sum[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> flag, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sum[min(id, mid&lt;&lt;<span class="number">1</span>)][flag];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> mid = n * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">        dp[cur][mid] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            LL x;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            cur ^= <span class="number">1</span>, pre ^= <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memset</span>(dp[cur], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[cur]));</span><br><span class="line"></span><br><span class="line">            sum[<span class="number">0</span>][<span class="number">0</span>] = dp[pre][<span class="number">0</span>];</span><br><span class="line">            sum[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            FOR(i, <span class="number">1</span>, mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = i &amp; <span class="number">1</span>;</span><br><span class="line">                sum[i][flag] = (sum[i-<span class="number">1</span>][flag] + dp[pre][i]) % MOD;</span><br><span class="line">                sum[i][flag^<span class="number">1</span>] = sum[i-<span class="number">1</span>][flag^<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LL res = <span class="number">0</span>;</span><br><span class="line">            FOR(i, <span class="number">0</span>, x) res = (res + (x - i + <span class="number">2</span>) / <span class="number">2</span> * dp[pre][i]) % MOD;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                FOR(i, <span class="number">0</span>, mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> flag = i &amp; <span class="number">1</span>;</span><br><span class="line">                    dp[cur][i] = res;</span><br><span class="line">                    res = (res + get(i + x + <span class="number">1</span>, flag, mid) - get(i, flag, mid)) % MOD;</span><br><span class="line">                    res = (res - (get(i, flag^<span class="number">1</span>, mid) - get(i - x - <span class="number">1</span>, flag^<span class="number">1</span>, mid))) % MOD;</span><br><span class="line">                    res = (res + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                FOR(i, <span class="number">0</span> , mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> flag = i &amp; <span class="number">1</span>;</span><br><span class="line">                    dp[cur][i] = res;</span><br><span class="line">                    res = (res + get(i + x + <span class="number">1</span>, flag^<span class="number">1</span>, mid) - get(i, flag^<span class="number">1</span>, mid)) % MOD;</span><br><span class="line">                    res = (res - (get(i, flag, mid) - get(i - x - <span class="number">1</span>, flag, mid))) % MOD;</span><br><span class="line">                    res = (res + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[cur][mid] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5291">http://acm.hdu.edu.cn/showproblem.php?pid=5291</a></p>
<p>题目大概意思就是有K种物品，第i种物品有ai个，要把全部的物品分成两堆，每个物品可以用也可以不用， 问最后两边物品数量一样多的方案数。</p>
<p>最直接的思路，定义dp[i][j]表示第i堆分完后第一个人比第二个人多j个糖果的方案数。枚举分第i堆糖果时第一个人比第二个人多分x个，则</p>
<blockquote>
<p>$$dp[i][j+x] += dp[i-1][j] * ( (a[i] - x) / 2 + 1 ) $$</p>
</blockquote>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5290 Bombing plan]]></title>
    <link href="http://teveillan.com/2015/11/19/HDU-5290-Bombing-plan/"/>
    <id>http://teveillan.com/2015/11/19/HDU-5290-Bombing-plan/</id>
    <published>2015-11-19T08:07:43.000Z</published>
    <updated>2015-11-22T11:13:51.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5290" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5290</a></p>
<p>官方题解已经说的很详细了。我也引用一下官方题解吧（有修改，加重部分）。</p>
<blockquote>
<p> DP,定义两个数组$F[I][J]$,$G[I][J]$。<br> $F[I][J]$表示以第i个点为根的子树上的点被全部破坏掉，并且还能向上破坏掉<strong>不少于</strong>j个距离，满足这样条件需要选取的最小点数；<br> $G[I][J]$表示以第i个点为根的子树上的点被未被全部破坏，且未被破坏的点中距离i最远的点距离为<strong>不超过</strong>j，满足这样条件需要选取的最小点数。<br><a id="more"></a></p>
</blockquote>
<p>那么可以写出dp方程:<br>$$G[I][J]=min(G[L][0],G[L][1],…,G[L][J-1]) $$<br>L 代表所有儿子。</p>
<p>$$F[I][J] = F[K][J+1]+G[L][J]$$<br>$$F[I][J] = min(F[I][j], F[I][J+1])$$<br>式子中加号左边的意思是i节点必须存在一个儿子K，选取F[K][J+1]这个值。加号右边的式子表示除K以外其他儿子L的取值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,n) for(int i=0;i&lt;(n);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,h) for(int i=(l);i&lt;=(h);++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,h,l) for(int i=(h);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">111</span>], f[N][<span class="number">111</span>];</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line">VI head[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    FOR(i, <span class="number">0</span>, <span class="number">101</span>) dp[cur][i] = <span class="number">0</span>, f[cur][i] = (i&lt;=w[cur]?<span class="number">1</span>:<span class="number">1e6</span>); </span><br><span class="line">    <span class="comment">//分别初始化取和不取时候的初始值。后面就没必要分步讨论了。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to: head[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(to == pre) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to, cur);</span><br><span class="line"></span><br><span class="line">        DWN(i, <span class="number">100</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            f[cur][i] = min(f[cur][i] + dp[to][i-<span class="number">1</span>], dp[cur][i] + f[to][i+<span class="number">1</span>]);</span><br><span class="line">            f[cur][i] = min(f[cur][i], f[cur][i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[cur][<span class="number">0</span>] = min(f[cur][<span class="number">0</span>] + f[to][<span class="number">0</span>], dp[cur][<span class="number">0</span>] + f[to][<span class="number">1</span>]);</span><br><span class="line">        f[cur][<span class="number">0</span>] = min(f[cur][<span class="number">0</span>], f[cur][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        dp[cur][<span class="number">0</span>] = min(f[cur][<span class="number">0</span>], dp[cur][<span class="number">0</span>] + f[to][<span class="number">0</span>]);</span><br><span class="line">        FOR(i, <span class="number">1</span>, <span class="number">100</span>) &#123;</span><br><span class="line">            dp[cur][i] = min(dp[cur][i-<span class="number">1</span>], dp[cur][i] + dp[to][i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        FOR(i, <span class="number">1</span>, n) head[i].clear();</span><br><span class="line">        FOR(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> x, y;</span><br><span class="line">             <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">             head[x].pb(y);</span><br><span class="line">             head[y].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5290">http://acm.hdu.edu.cn/showproblem.php?pid=5290</a></p>
<p>官方题解已经说的很详细了。我也引用一下官方题解吧（有修改，加重部分）。</p>
<blockquote>
<p> DP,定义两个数组$F[I][J]$,$G[I][J]$。<br> $F[I][J]$表示以第i个点为根的子树上的点被全部破坏掉，并且还能向上破坏掉<strong>不少于</strong>j个距离，满足这样条件需要选取的最小点数；<br> $G[I][J]$表示以第i个点为根的子树上的点被未被全部破坏，且未被破坏的点中距离i最远的点距离为<strong>不超过</strong>j，满足这样条件需要选取的最小点数。<br>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习笔记---线性回归(Linear Regression)]]></title>
    <link href="http://teveillan.com/2015/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-Linear-Regression/"/>
    <id>http://teveillan.com/2015/07/28/机器学习笔记-线性回归-Linear-Regression/</id>
    <published>2015-07-28T12:36:26.000Z</published>
    <updated>2015-11-18T14:19:04.000Z</updated>
    <content type="html"><![CDATA[<p>作为机器学习的第一课，深刻理解线性回归将<strong>非常</strong>有助于我们学习后面的课程。</p>
<p>在上篇文章中我们将机器学习分为监督学习和非监督学习，线性回归就属于监督学习算法的一种。</p>
<p>依然拿上一章讲的房价预测作为我们学习线性回归的例子。<br>我们说过，影响房价的因素可能有很多种，如：房屋大小、周围均价、使用年限等等。<br>我们将这么一种因素称之为<strong>特征（Feature）</strong>。<br>对于每一组数据的每个特征值我们分别记为$x_1,x_2,x_3$…$x_n$，n为特征数。</p>
<a id="more"></a>
<p>则我们建立一个数学模型，也就是假说（Hypothesis）为：</p>
<blockquote>
<p>$$h(x) = \sum_{i=0}^n \theta_ix_i = \theta^Tx$$</p>
</blockquote>
<p>这里的$\theta$即为假说的参数，我们赋予它一个初始值，然后再在机器学习的过程中不断调整。（所以说机器学习的过程其实也就是个调参的过程）</p>
<p>至于有n个特征，i为什么从0开始，我们后面再讲。</p>
<h2 id="1-1_单变量线性回归(Linear_Regression_with_One_Variable)">1.1 单变量线性回归(Linear Regression with One Variable)</h2><p>最开始，我们假设影响房价的因素就一个：房屋面积。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Size in feet$^2$(x)</th>
<th style="text-align:center">Price in 1000’s(y)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">852</td>
<td style="text-align:center">178</td>
</tr>
<tr>
<td style="text-align:center">1534</td>
<td style="text-align:center">315</td>
</tr>
<tr>
<td style="text-align:center">1416</td>
<td style="text-align:center">232</td>
</tr>
<tr>
<td style="text-align:center">2104</td>
<td style="text-align:center">460</td>
</tr>
</tbody>
</table>
<p>则对于一组参数$\theta$,我们Hypothesis定义为：</p>
<blockquote>
<p>$$h_\theta(x) = \theta_0 + \theta_1x_1$$</p>
</blockquote>
<p>$\theta_0$是我们加的一个辅助变量，没有实际意义。为了规范，我们令$x_0 = 1$，则：</p>
<blockquote>
<p>$$ h_\theta(x) = \theta_0x_0 + \theta_1x_1  = \sum_{i=0}^n\theta_ix_i = \theta^Tx $$</p>
</blockquote>
<h2 id="1-2_成本函数(CostFunction)">1.2 成本函数(CostFunction)</h2><p>如何衡量这一组参数的好坏呢？计算它预测结果的误差大小就好了。<br>在课程中，我们用$J(\theta)$来表示一组$\theta$的Cost。</p>
<blockquote>
<p>$$ J(\theta) = \frac{1}{2m} \sum_{i=0}^{m} Cost(x^{(i)}, y^{(i)}) = \frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)})    - y^{(i)})^2   $$ </p>
</blockquote>
<p>有了成本函数，也就知道如何衡量$(\theta_0,\theta_1)$的好坏。剩下的只用调整$\theta$使得$J(\theta)$最小就好了。</p>
<h2 id="1-3_梯度下降(Gradient_descent)">1.3 梯度下降(Gradient descent)</h2><p>如何最小化 $J(\theta)$？</p>
<p>我们首先来直观地感受一下对于不同的$(\theta_0,\theta_1)$，$J(\theta)$的大小是怎么变化的。</p>
<img title="machine-learning" alt="machine-learning" src="http://7tszmu.com1.z0.glb.clouddn.com/images/teveillan/images/machine-learning2-1.png?imageView2/2/w/600">
<p>如果我们最初设定的$\theta$使得$J(\theta)$恰好在山谷的位置，则皆大欢喜，此时的$J(\theta)$就是最小值，是最优解。</p>
<p>如果不幸选在山峰的位置，那么我们就要对$\theta$一点一点进行修改，使得$J(\theta)$一步一步走向山谷。这种一步一步修改$\theta$使得$J(\theta)$逐步走下山的过程我们称之为<strong>梯度下降</strong>，下降$J(\theta)$的值。</p>
<p>就像下图：</p>
<img title="machine-learning" alt="machine-learning" src="http://7tszmu.com1.z0.glb.clouddn.com/images/teveillan/images/machine-learning2-1.png?imageView2/2/w/600">
<p>怎么下降？</p>
<p>想要下降，首先得确定下降的方向。然后确定下降的幅度。</p>
<p>从数学上讲，假如我们确定了下降的幅度$\lambda$，则对于每个$\theta$，最佳的下降值为：</p>
<blockquote>
<p>$$ \theta_j :=  \theta_j - \lambda \frac{\delta J(\theta)}{\delta \theta_j} $$</p>
<p>$$ \frac{\delta J(\theta)} {\delta \theta_j} =  \frac{1}{m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} $$</p>
</blockquote>
<p>所以展开就是：</p>
<blockquote>
<p>$$ \theta_j :=  \theta_j - \lambda  \frac{1}{m} \sum_{i=1}^m( h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)}    $$</p>
</blockquote>
<p>就这样，一步一步更新$\theta$，使得$J(\theta)$一步一步变小。<br>到什么时候停止?</p>
<p>我们比较更新前后的$J(\theta)$, 当更新后的$J(\theta)$比较小时，肯定是可以更新的。<br>但是当更新后的$J(\theta)$比较大的时候，也不代表不能更新。<br>我们知道，在我们更新$\theta$的时候，有两个因素，一个是幅度（$\lambda$），一个是方向。<br>如果更新后的$J(\theta)$比较大，也有可能是更新的幅度比较大，一步迈过了谷底。这时候，我们需要减小$\lambda$来试试。</p>
<h3 id="NOTICE">NOTICE</h3><p>1.更新$\theta$的时候是所有$\theta$一起更新的。<br>虽然对于每个$\theta$的导数值是一个一个计算的，但是更新的时候是最后一起更新。<br>如果是计算一个导数值更新一个$\theta$，我们会发现，由于我们先更新了$\theta_1$，再计算$\frac{\delta J(\theta)} {\theta_2}$的值就和预期的不符了。</p>
<p>2.对于不同的初始$\theta$，我们最终走到的谷底的位置也可能不同。<br>也就是说，我们最终计算的最小值可能只是局部最小值，而不是全局最小值。</p>
<h2 id="1-4学习算法">1.4学习算法</h2><p>当我们有了任意一个初始的$\theta$，有了梯度下降算法。<br>接下来就是用梯度下降算法不断递归更新$\theta$就好了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作为机器学习的第一课，深刻理解线性回归将<strong>非常</strong>有助于我们学习后面的课程。</p>
<p>在上篇文章中我们将机器学习分为监督学习和非监督学习，线性回归就属于监督学习算法的一种。</p>
<p>依然拿上一章讲的房价预测作为我们学习线性回归的例子。<br>我们说过，影响房价的因素可能有很多种，如：房屋大小、周围均价、使用年限等等。<br>我们将这么一种因素称之为<strong>特征（Feature）</strong>。<br>对于每一组数据的每个特征值我们分别记为$x_1,x_2,x_3$…$x_n$，n为特征数。</p>]]>
    
    </summary>
    
      <category term="Tech" scheme="http://teveillan.com/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习笔记—机器学习简介]]></title>
    <link href="http://teveillan.com/2015/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/"/>
    <id>http://teveillan.com/2015/07/01/机器学习笔记—机器学习简介/</id>
    <published>2015-07-01T12:14:03.000Z</published>
    <updated>2015-11-18T14:18:41.000Z</updated>
    <content type="html"><![CDATA[<p>一直以来都想学习机器学习，但是苦于找不到好的入门书籍或者教学视频（Andrew NG的斯坦福公开课没有练习），直到发现了这个:</p>
<blockquote>
<p><a href="https://www.coursera.org/learn/machine-learning/home/welcome" target="_blank" rel="external">https://www.coursera.org/learn/machine-learning/home/welcome</a></p>
</blockquote>
<p>虽然也是Andrew NG老师的，不过是在Coursera上的，相对于课堂上的录制视频，这个用PPT来讲更直观，视频中间会有问答检测关键知识点是否理解正确，强制性要求的课后作业虽然不难，但确实能加深理解。比起只看书或者只看公开课，优点不用多说。</p>
<p>由于本人也是初学者，所以各位客官在看得时候务必以教学视频和自己的理解为主，若发现有问题的地方欢迎指正共同学习。<br><a id="more"></a></p>
<p>=========================分隔符=============================</p>
<p>Machine Learning Week1</p>
<p>首先，从什么是机器学习开始说起。<br>这里我们要引用一下台大林轩田老师《机器学习基石》的一幅图：</p>
<img title="machine-learning1-1" alt="图片说明" ‘class="class1" src="http://7tszmu.com1.z0.glb.clouddn.com/images/teveillan/images/machine-learning1-1.png?imageView2/2/w/600">
<ul>
<li>$X$：训练数据的输入部分</li>
<li>$y$：训练数据的输出部分</li>
<li>$D$：训练数据集，表现为$（X_i, Y_i）$的形式</li>
<li>$H$：假说Hypothesis，表示对问题分析后得到的数学模型</li>
<li>$A$：学习方法</li>
</ul>
<blockquote>
<p>在机器学习中，对于一类问题，我们先加以分析，得到对于一组输入应该怎样处理的数学模型$H$，数学模型中有各种各样的参数$\theta$。<br>此时，我们知道应该有哪些参数，但是不知道参数具体值为多少，于是借助学习方法$A$以及训练数据$D$，我们不断修改参数，使得对于以后的预测数据，能得到一个相对符合实际的结果。<br>因此，机器学习就是一个提出假说$H$，并用学习方法$A$不断优化$\theta$的过程。</p>
</blockquote>
<p>在课程中，Andrew NG将机器学习分为两种：</p>
<ol>
<li>监督性学习(Supervised Learning)</li>
<li>非监督性学习(Unsupervised Learning)，也称聚类算法</li>
</ol>
<p>而这两种分类的主要依据是，当我们在训练学习机器的时候，每组数据是否有标准答案。<br>这样说可能不严谨，我还是拿例子来说。</p>
<p>在常规的训练一个机器学习的算法过程中，我们大多有一些训练数据，在不断喂(feed)学习机器的过程中，学习机器不断调整自己内部的各项参数，使得当机器学习训练完毕，我们拿实际需要预测的数据喂给机器学习算法，能得到一个比较符合实际情况的值。</p>
<p>然而，这种预期的值确是有区别的。</p>
<ol>
<li><p>监督性学习：我们想预测房价，我们需要把房屋的大小、地理位置、规格等数据喂给学习机器，我们能得到一个预测的价格的值。在训练这种学习机器的过程中，我们在喂这组数据之前就已经知道了这组数据的标准答案，假如得到的答案和标准答案不符，我们希望修改参数来使得得到的答案尽可能像标准答案靠拢，这叫做监督。</p>
</li>
<li><p>非监督性学习：也称它聚类算法。如给邮件分类，在我们训练学习机器给喂数据的过程中，我们根本不知道这组数据应该准确地分为哪一类，甚至不知道应该有哪些类别有多少类别，我们仅能依靠训练数据之间的相关性将他们分为几类。 既然没有标准答案，监督自然也无从说起。</p>
</li>
</ol>
<p>简介就到这，线性回归我们拿到下一章统一讲。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一直以来都想学习机器学习，但是苦于找不到好的入门书籍或者教学视频（Andrew NG的斯坦福公开课没有练习），直到发现了这个:</p>
<blockquote>
<p><a href="https://www.coursera.org/learn/machine-learning/home/welcome">https://www.coursera.org/learn/machine-learning/home/welcome</a></p>
</blockquote>
<p>虽然也是Andrew NG老师的，不过是在Coursera上的，相对于课堂上的录制视频，这个用PPT来讲更直观，视频中间会有问答检测关键知识点是否理解正确，强制性要求的课后作业虽然不难，但确实能加深理解。比起只看书或者只看公开课，优点不用多说。</p>
<p>由于本人也是初学者，所以各位客官在看得时候务必以教学视频和自己的理解为主，若发现有问题的地方欢迎指正共同学习。<br>]]>
    
    </summary>
    
      <category term="Tech" scheme="http://teveillan.com/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]部署MAC上的Sublime Text+LaTeX中文环境]]></title>
    <link href="http://teveillan.com/2015/05/11/%E8%BD%AC-%E9%83%A8%E7%BD%B2MAC%E4%B8%8A%E7%9A%84Sublime-Text-LaTex%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/"/>
    <id>http://teveillan.com/2015/05/11/转-部署MAC上的Sublime-Text-LaTex中文环境/</id>
    <published>2015-05-11T06:35:22.000Z</published>
    <updated>2015-05-11T06:39:19.000Z</updated>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.readern.com/sublime-text-latex-chinese-under-mac.html" target="_blank" rel="external">http://www.readern.com/sublime-text-latex-chinese-under-mac.html</a><br>作者：Read ERN</p>
<p>LaTex就不多做介绍了，其实一般人用到的机会也不多（包括我）。只是这段时间在Coursera上新课程的时候，偶尔需要，所以从零开始摸索了一下，也顺便进一步发现了Sublime Text的强大。</p>
<p>MAC上的LaTex部署，一般是两条思路，一个是直接安装MacTex，自带编写环境什么的；另一个是Sublime Text（或者Textmate等其他编辑器）+LaTexTools插件。方式二其实也是需要依赖MacTex的，但相对来说体量小、不需要经常切换编辑器，所以果断的介绍方式二。</p>
<p>亲测：MacOS 10.10, Sublime Text 3可用。（2015年5月）</p>
<a id="more"></a>
<h3 id="安装步骤">安装步骤</h3><ol>
<li>首先需要安装Sublime Text 3和<a href="https://packagecontrol.io/installation" target="_blank" rel="external">Package Control</a>，这个有大把的帖子。</li>
<li>MacTex现在是一个2G+的大包子，其实里面很多东西我们不需要，所以本着节约精神，我们安装<a href="http://mirror.ctan.org/systems/mac/mactex/mactex-basic.pkg" target="_blank" rel="external">MacTex_Basic</a>包就行了，现在的版本大概是100M以内。这个安装也是傻瓜的。</li>
<li>在Sublime Text里<code>Command+Shift+P</code>调出命令窗口，输入<code>Install</code>，之后选择LaTexTools，网络OK的话，很快就完成了插件安装。</li>
<li>LaTexTools插件会在编译你的Tex文件后，调用Skim这个PDF阅读器打开编译出的PDF文件，因此你还需要安装<a href="http://skim-app.sourceforge.net/" target="_blank" rel="external">Skim</a>.</li>
<li>运行一下Skim，进入<code>偏好设置——同步</code>，在<code>PDF-Tex同步支持</code>那里选择<code>Sublime Text</code>。这样，当你在Sublime Text里修改tex文件时，Skim预览也会相应变更。</li>
<li>完成上面所有步骤，其实就已经搭建完成基本环境。创建一个test.tex文档，贴上我后面附的测试代码，保存一下。(原Po说这里可以开始编译了，亲测是不行的，等完成第七步再编译。)</li>
<li>让我们最后来修改编译和中文环境:<br>打开编辑<code>~/Library/Application\ Support/Sublime\ Text/Packages/Users/LaTeXTools.sublime-settings</code>，将其中”builder”条目改为：<br><code>&quot;builder&quot;: &quot;simple&quot;</code><br>接着打开编辑<code>~/Library/Application\ Support/Sublime\ Text\ 3/Packages/LaTeXTools/builders/simpleBuilder.py</code><br>找到其中大概第41行<br><code>pdflatex = [&quot;dflatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-synctex=1&quot;]</code><br>修改为<br><code>pdflatex = [&quot;xelatex&quot;, &quot;-interaction=nonstopmode&quot;, &quot;-synctex=1&quot;]</code><br>保存后关闭，<code>Command + B</code>编译一下，一切OK！</li>
</ol>
<p><strong>补充</strong>:<br>配置好后，如果编译的时候提示:</p>
<blockquote>
<p>LaTeXTools: you need to migrate your preferences. See the README file for instructions.</p>
</blockquote>
<p>调出命令窗口(<code>Command+Shift+P</code>), 输入如下命令: <code>LaTeXTools: Reconfigure and migrate setting</code>.</p>
<p>最后再给一个个性化设置。上面写了，LaTeXTools默认调用Skim，这一方面是因为LaTeXTools是跨平台的插件，Skim也同样跨平台开源，另一方面Skim确实对LaTeX的PDF支持很好。但是用OS X的网友们其实还有个选择，就是调用系统默认的PDF程序来打开编译后的成果，特别是“预览”还是很好用的。目前LaTeXTools的开发者还没有给出设置方法，所以，仍然要靠改代码：<br>修改<code>~/Library/Application\ Support/Sublime\ Text\ 3/Packages/LaTeXTools/jumpToPDF.py</code>, 将其中<code>if plat == &#39;darwin&#39;:</code> 之后开始的两段直接注释掉，替换为：<br><code>subprocess.Popen([‘open’] + [pdffile])</code><br>同样保存后就生效啦。目前用起来，系统自带的预览还是能满足我的需求滴。</p>
<p>测试代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;article&#125;&#10;\usepackage&#123;fontspec, xunicode, xltxtra&#125;  &#10;\setmainfont&#123;Hiragino Sans GB&#125;  &#10;&#10;\title&#123;Title&#125;&#10;\author&#123;&#125;&#10;&#10;\begin&#123;document&#125;&#10;&#10;\maketitle&#123;&#125;&#10;&#10;\section&#123;Introduction&#125;&#10;&#10;This is where you will write your content. &#22312;&#36825;&#37324;&#20889;&#19978;&#20869;&#23481;&#12290;&#10;&#10;\end&#123;document&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LaTex的其他选择">LaTex的其他选择</h3><p>如果只是偶尔需要输入公式，这里介绍一个在线的LaTex公式编辑器<a href="http://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="external">http://www.codecogs.com/latex/eqneditor.php</a></p>
<p>有iPad的，你们有福了，还有个手写公式后自动识别、生成LaTex公式的App：<a href="https://itunes.apple.com/us/app/myscript-mathpad-handwriting/id674996719?mt=8" target="_blank" rel="external">Script MathPad</a>。简单的使用已经足够了，如果需要经常使用，导出功能需要内购（4.99刀）。顺便说一句，这家公司的手写App都很强大，手写计算器、手写Notes都挺好用，而且不贵。</p>
<h4 id="参考链接：">参考链接：</h4><p>MacTex页面：<a href="http://tug.org/mactex/morepackages.html" target="_blank" rel="external">http://tug.org/mactex/morepackages.html</a></p>
<p>Skim官网：<a href="http://skim-app.sourceforge.net" target="_blank" rel="external">http://skim-app.sourceforge.net</a></p>
<p>LaTexTools官网：<a href="https://github.com/SublimeText/LaTeXTools" target="_blank" rel="external">https://github.com/SublimeText/LaTeXTools</a></p>
<p>前六步骤的具体介绍：<a href="http://economistry.com/2013/01/installing-and-using-latex-for-mac/" target="_blank" rel="external">http://economistry.com/2013/01/installing-and-using-latex-for-mac/</a> 不过需要注意，这里是用了完整的MacTex</p>
<p>发现xelatex是受了这里的启发：<a href="http://www.teeboneding.com/blog/2013/06/01/write-ntu-master-thesis-with-xelatex-template-on-mac/" target="_blank" rel="external">http://www.teeboneding.com/blog/2013/06/01/write-ntu-master-thesis-with-xelatex-template-on-mac/</a> 但需要注意，这里的编译代码测试无效。</p>
<p>第七步受了这里的启发：<a href="https://github.com/SublimeText/LaTeXTools/issues/303" target="_blank" rel="external">https://github.com/SublimeText/LaTeXTools/issues/303</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接：<a href="http://www.readern.com/sublime-text-latex-chinese-under-mac.html">http://www.readern.com/sublime-text-latex-chinese-under-mac.html</a><br>作者：Read ERN</p>
<p>LaTex就不多做介绍了，其实一般人用到的机会也不多（包括我）。只是这段时间在Coursera上新课程的时候，偶尔需要，所以从零开始摸索了一下，也顺便进一步发现了Sublime Text的强大。</p>
<p>MAC上的LaTex部署，一般是两条思路，一个是直接安装MacTex，自带编写环境什么的；另一个是Sublime Text（或者Textmate等其他编辑器）+LaTexTools插件。方式二其实也是需要依赖MacTex的，但相对来说体量小、不需要经常切换编辑器，所以果断的介绍方式二。</p>
<p>亲测：MacOS 10.10, Sublime Text 3可用。（2015年5月）</p>]]>
    
    </summary>
    
      <category term="LaTeX" scheme="http://teveillan.com/tags/LaTeX/"/>
    
      <category term="MacOS" scheme="http://teveillan.com/tags/MacOS/"/>
    
      <category term="Tech" scheme="http://teveillan.com/categories/Tech/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编程之美2015初赛第一场]]></title>
    <link href="http://teveillan.com/2015/05/07/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E2015%E5%88%9D%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA/"/>
    <id>http://teveillan.com/2015/05/07/编程之美2015初赛第一场/</id>
    <published>2015-05-07T11:51:01.000Z</published>
    <updated>2015-05-07T14:39:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Hihocoder_1156_彩色的树">Hihocoder 1156 彩色的树</h2><p>题目链接: <a href="http://hihocoder.com/problemset/problem/1156" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1156</a></p>
<p>在每个更新操作的过程中，假设点P最初的颜色为color1，更新后的颜色为color2。<br>我们记与点P相邻，颜色为color1的点为num1, 颜色为color2的点为num2。<br>则 ans += num1 - 1, ans -= num2 - 1。</p>
<p>难点主要在于统计nun1, num2。直接暴力肯定是要TLE的，这里有个技巧。</p>
<p>既然是在树中，我们用map存点P的子节点各种颜色的点有多少个，将父节点单独考虑。<br>查询的过程中:</p>
<ul>
<li><code>num1 = map[P][color1] + (color[ fa[P] ] == color1)</code></li>
<li><code>num2 = map[P][color2] + (color[ fa[p] ] == color2)</code></li>
</ul>
<p>更新的时候只用将父节点的子节点的color1—, color2++。<br>在O(log)级的复杂度内就能完成更新查询操作。<br><a id="more"></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;head[N];</span><br><span class="line"><span class="keyword">int</span> color[N], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123; <span class="comment">//构建树形结构</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to: head[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(to == fa[cur])   <span class="keyword">continue</span>;</span><br><span class="line">        fa[to] = cur;</span><br><span class="line">        m[cur][<span class="number">0</span>] ++;</span><br><span class="line">        dfs(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> tmp_color, <span class="keyword">int</span> &amp;ans)</span> </span>&#123; <span class="comment">//更新点的同时同时更新ans</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    tmp += m[cur][ color[cur] ];</span><br><span class="line">    <span class="keyword">if</span>(color[ fa[cur] ] == color[cur]) ++tmp;</span><br><span class="line">    ans += tmp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">0</span>;</span><br><span class="line">    tmp += m[cur][tmp_color];</span><br><span class="line">    <span class="keyword">if</span>(color[ fa[cur] ] == tmp_color) ++tmp;</span><br><span class="line">    ans -= tmp - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    --m[ fa[cur] ][ color[cur] ];</span><br><span class="line">    ++m[ fa[cur] ][ tmp_color ];</span><br><span class="line">    color[cur] = tmp_color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>, n, q, x, y, z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="keyword">sizeof</span>(color));</span><br><span class="line">        FOR(i, <span class="number">1</span>, n)    head[i].clear(), m[i].clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            head[x].pb(y);</span><br><span class="line">            head[y].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">        fa[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, ++ casid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        color[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;y, &amp;z);</span><br><span class="line">                update(y, z, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hihocoder_1157_建造金字塔">Hihocoder 1157 建造金字塔</h2><p>题目链接： <a href="http://hihocoder.com/problemset/problem/1157" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1157</a></p>
<p>DP。<br>输入的时候时候一个三角形用顶点坐标<code>(x, y)</code>来表示，我们转化成左右端顶点的横坐标来表示一个三角形<code>(l,r) = (x-y,x+y)</code>。然后按<code>l</code>进行排序。<br>我们用<code>dp[i][j]</code>表示第i个点，且前从前i个三角形选择的三角形中最右端为j的最大获益。<br>假设第i个点的左右端点为<code>(l,r)</code>，利润为v1，成本为v2，分三种情况讨论：</p>
<ol>
<li><code>j &lt;= l：dp[i][r] = max(dp[i][r], dp[i-1][j] + v1 - v2)</code></li>
<li><code>j &gt;= r：dp[i][j] = max(dp[i][j], dp[i-1][j] + v1)</code></li>
<li><code>j &gt; l &amp;&amp; j &lt; r：dp[i][r] = max(dp[i][r], dp[i-1][j] + v1 - v2 + v3)</code>。v3为与之前的重叠面积</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">2</span>][<span class="number">3010</span>]; <span class="comment">//滚动数组，第一维只要2就够了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Trangle &#123;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">double</span> v1, v2;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Trangle &amp;other) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l != other.l)    <span class="keyword">return</span> l &lt; other.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; other.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>, n, x, y, z;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Trangle&gt;vec(n);</span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            vec[i].l = x - y + <span class="number">1000</span>;<span class="comment">//因为x-y有可能小于0,注意不要超出边界 </span></span><br><span class="line">            vec[i].r = x + y + <span class="number">1000</span>;</span><br><span class="line">            vec[i].v1 = z;</span><br><span class="line">            vec[i].v2 = y * y;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vec.begin(), vec.end()); <span class="comment">//按l排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">        REP(i, <span class="number">2</span>)</span><br><span class="line">            REP(j, <span class="number">3001</span>)</span><br><span class="line">                dp[i][j] = -<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">        dp[cur][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t: vec) &#123;</span><br><span class="line">            cur ^= <span class="number">1</span>, pre ^= <span class="number">1</span>;</span><br><span class="line">            REP(i, <span class="number">3001</span>)</span><br><span class="line">                dp[cur][i] = -<span class="number">1e18</span>;</span><br><span class="line">            <span class="keyword">int</span> l = t.l, r = t.r;</span><br><span class="line">            REP(i, <span class="number">3001</span>) &#123;<span class="comment">//分三种情况讨论</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= r)  dp[cur][i] = max(dp[cur][i], dp[pre][i] + t.v1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &lt;= l) dp[cur][r] = max(dp[cur][r], dp[pre][i] + t.v1 - t.v2);</span><br><span class="line">                <span class="keyword">else</span> dp[cur][r] = max(dp[cur][r], dp[pre][i] + t.v1 - <span class="built_in">pow</span>((t.r - t.l) / <span class="number">2.0</span>, <span class="number">2.0</span>) + <span class="built_in">pow</span>((i - t.l) / <span class="number">2.0</span>, <span class="number">2.0</span>));</span><br><span class="line"></span><br><span class="line">                dp[cur][i] = max(dp[cur][i], dp[pre][i]);</span><br><span class="line">                ans = max(ans, dp[cur][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %.2lf\n"</span>, ++casid, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hihocoder_1158_质数相关">Hihocoder 1158 质数相关</h2><p>题目链接：<a href="http://hihocoder.com/problemset/problem/1158" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1158</a></p>
<p>二分匹配求最大独立集。<br>可证：<code>如果(a,b)质数相关，(b,c)质数相关，则（a,c）质数无关</code></p>
<p>因此没有奇数环，可划分为二分图。<br>求出二分匹配，最大独立集 = n - 最大匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">bool</span> is_prime[<span class="number">510000</span>], flag[<span class="number">510000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="keyword">sizeof</span>(is_prime));</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;prime;</span><br><span class="line">    FOR(i, <span class="number">2</span>, N) &#123; <span class="comment">//素数筛</span></span><br><span class="line">        <span class="keyword">if</span>(!is_prime[i])    <span class="keyword">continue</span>;</span><br><span class="line">        prime.pb(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= N; j += i)  is_prime[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(i, <span class="number">1</span>, N) <span class="comment">//给每个点染色，因为没有奇数环，所以必然染成或黑或白的一种</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x: prime) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; N / x)  <span class="keyword">break</span>;</span><br><span class="line">            flag[i * x] = flag[i] ^ <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Max_Match &#123; <span class="comment">//匈牙利匹配</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;head[<span class="number">1100</span>];</span><br><span class="line">    <span class="keyword">int</span> match_x[<span class="number">1100</span>], match_y[<span class="number">1100</span>];</span><br><span class="line">    <span class="keyword">bool</span> visit[<span class="number">1100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span>&#123; head[x].pb(y); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find_path</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> to: head[cur])</span><br><span class="line">            <span class="keyword">if</span>(!visit[to]) &#123;</span><br><span class="line">                visit[to] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(match_y[to] == -<span class="number">1</span> || find_path( match_y[to] )) &#123;</span><br><span class="line">                    match_x[cur] = to;</span><br><span class="line">                    match_y[to] = cur;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(match_x, -<span class="number">1</span>, <span class="keyword">sizeof</span>(match_x));</span><br><span class="line">        <span class="built_in">memset</span>(match_y, -<span class="number">1</span>, <span class="keyword">sizeof</span>(match_y));</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[ vec[i] ] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">            ret += find_path(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum --) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec(n);</span><br><span class="line">        REP(i, n)   <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vec[i]);</span><br><span class="line"></span><br><span class="line">        sort(vec.begin(), vec.end());</span><br><span class="line">        Max_Match match;</span><br><span class="line">        REP(i, n) <span class="comment">//建立二分图</span></span><br><span class="line">            REP(j, i)</span><br><span class="line">                <span class="keyword">if</span>(vec[i] % vec[j] == <span class="number">0</span> &amp;&amp; is_prime[ vec[i] / vec[j] ]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag[ vec[i] ] &lt; flag[ vec[j] ])   match.add(i, j);</span><br><span class="line">                    <span class="keyword">else</span> match.add(j, i);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %d\n"</span>, ++casid, n - match.solve(n, vec));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Hihocoder_1156_彩色的树">Hihocoder 1156 彩色的树</h2><p>题目链接: <a href="http://hihocoder.com/problemset/problem/1156">http://hihocoder.com/problemset/problem/1156</a></p>
<p>在每个更新操作的过程中，假设点P最初的颜色为color1，更新后的颜色为color2。<br>我们记与点P相邻，颜色为color1的点为num1, 颜色为color2的点为num2。<br>则 ans += num1 - 1, ans -= num2 - 1。</p>
<p>难点主要在于统计nun1, num2。直接暴力肯定是要TLE的，这里有个技巧。</p>
<p>既然是在树中，我们用map存点P的子节点各种颜色的点有多少个，将父节点单独考虑。<br>查询的过程中:</p>
<ul>
<li><code>num1 = map[P][color1] + (color[ fa[P] ] == color1)</code></li>
<li><code>num2 = map[P][color2] + (color[ fa[p] ] == color2)</code></li>
</ul>
<p>更新的时候只用将父节点的子节点的color1—, color2++。<br>在O(log)级的复杂度内就能完成更新查询操作。<br>]]>
    
    </summary>
    
      <category term="编程之美" scheme="http://teveillan.com/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CDQ分治 && HDU 5126]]></title>
    <link href="http://teveillan.com/2015/05/02/CDQ%E5%88%86%E6%B2%BB/"/>
    <id>http://teveillan.com/2015/05/02/CDQ分治/</id>
    <published>2015-05-02T08:48:26.000Z</published>
    <updated>2015-05-06T13:24:03.000Z</updated>
    <content type="html"><![CDATA[<p>参考文献：<a href="http://wenku.baidu.com/view/52f9c11cff00bed5b9f31d2d.html" target="_blank" rel="external">从《Cash》谈一类分治算法的应用</a> — 陈丹琦</p>
<p>也因此简称CDQ分治。</p>
<p>个人理解CDQ分治和普通分治最大的区别为：<br>普通分治可以将问题拆成几个相互独立的子问题<br>CDQ分治将问题分成了两个部分：</p>
<ol>
<li>相互独立的两个子问题  </li>
<li>两个子问题之间的联系</li>
</ol>
<p>因此，CDQ分治的算法流程也分为以下几步：</p>
<blockquote>
<ol>
<li>算法开始</li>
<li>取一个中间点mid, 将问题分为[L, mid] 和 [mid + 1, R]两个部分。分别处理两个子问题</li>
<li>处理[L, mid] 和 [mid + 1, R]之间的联系</li>
</ol>
</blockquote>
<a id="more"></a>
<p>举个例子：在二维坐标系中，有n个点，m个询问。对于每个询问(x, y)，求点(x1, x2) ，x1&lt;= x &amp;&amp; y1 &lt;= y 有多少个。</p>
<p>当然，这题用树状数组就直接能写了。但是我们在这里用CDQ分治来解决一下这个问题。</p>
<p>我们将n个点看做是n个更新，并和m个询问放在一起。定义一个结构体用vector存起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sovle1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;Struct&gt;vec1)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在这里将vec1[l, r]按x从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    solve1(l, mid);</span><br><span class="line">    solve1(mid + <span class="number">1</span>, r);<span class="comment">//划分成相互独立的子问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将vec1[l, mid]中的更新操作 和 vec1[mid + 1, r]中的询问操作,存到一个vec2中 </span></span><br><span class="line">    solve2(l, r, vec2);<span class="comment">//左半边的更新操作和右半边的询问操作之间有联系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;Struct&gt;vec2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//此时在solve2中已经不需要管x了。在vec2中所有的更新操作的x必然小于等于询问操作的x。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在这里将vec2[l, r]按y从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    sovle2(l, mid);</span><br><span class="line">    solve2(mid + <span class="number">1</span>, r);<span class="comment">//独立子问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将vec2[l, mid]中的更新操作和vec2[mid + 1, r]中得询问操作存到一个vec3中</span></span><br><span class="line">    solve3(l, r, vec3);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> solve3（<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;Struct&gt;vec3） &#123;</span><br><span class="line"><span class="comment">//此时在solve3中，x和y都是已经排好序的。从前到后遍历该更新更新该询问询问就好。</span></span><br><span class="line">    <span class="keyword">int</span> cal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Struct tmp: vec3) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.type == Update)  ++cal;</span><br><span class="line">        <span class="keyword">else</span> tmp.query_anser += cal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码其中有许多可以优化的地方，但是不要在意细节，主要是为了更加方便地理解算法</span></span><br></pre></td></tr></table></figure>
<p>虽然解法不如树状数组，但是我们得看到题目扩展后的好处。<br>我们看到，当到solve2时，函数中的参数<code>vec2</code>已经不用再管他的x了（<code>请务必深刻理解为什么不用再管了</code>）。<br>这样的好处在哪里？没错，<strong>降维！</strong><br>假如我们要处理的不是二维，而是三维四维依旧可以这么处理，每一个维度只不过加了O(log)的复杂度而已。<br><strong>如果是随时可以更新查询的操作，只不过也只是把时间当成一个维度而已。</strong>（光是这一点就已经牛逼哄哄够解决大部分题目了。）</p>
<p>然后就是下面这道题，三维且可随时更新查询：<br>HDU 5126 starts: <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5126" target="_blank" rel="external">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> que[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> z_num;</span><br><span class="line"><span class="keyword">int</span> node[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> Query &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z, kind, id;</span><br><span class="line">    Query() &#123;&#125;</span><br><span class="line">    Query(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y, <span class="keyword">int</span> _z, <span class="keyword">int</span> _kind, <span class="keyword">int</span> _id) : x(_x), y(_y), z(_z), kind(_kind), id(_id) &#123;&#125;</span><br><span class="line">&#125;queries[N &lt;&lt; <span class="number">3</span>], queries_x[N&lt;&lt;<span class="number">3</span>], queries_y[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.kind &lt; b.kind);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y || (a.y == b.y &amp;&amp; a.kind &lt; b.kind);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span>    </span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pos &lt;= z_num) &#123;</span><br><span class="line">        node[pos] += value;</span><br><span class="line">        pos += lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos) &#123;</span><br><span class="line">        ret += node[pos];</span><br><span class="line">        pos -= lowbit(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve3</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//只剩下二维y和z，直接就是二维的更新查询题目，树状数组解决就好了</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    FOR(i, l, r)</span><br><span class="line">        <span class="keyword">if</span>(queries_y[i].kind == <span class="number">0</span>)  update(queries_y[i].z, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(queries_y[i].kind == <span class="number">1</span>)  ans[ queries_y[i].id ] -= query(queries_y[i].z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(queries_y[i].kind == <span class="number">2</span>) ans[ queries_y[i].id ] += query(queries_y[i].z);</span><br><span class="line">    FOR(i, l, r)</span><br><span class="line">        <span class="keyword">if</span>(queries_y[i].kind == <span class="number">0</span>)  update(queries_y[i].z, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//把x这一维度消除</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve2(l, mid);</span><br><span class="line">    solve2(mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    FOR(i, l, mid)  <span class="keyword">if</span>(queries_x[i].kind == <span class="number">0</span>)  queries_y[num++] = queries_x[i];</span><br><span class="line">    FOR(i, mid+<span class="number">1</span>, r)    <span class="keyword">if</span>(queries_x[i].kind)  queries_y[num++] = queries_x[i];</span><br><span class="line">    sort(queries_y, queries_y + num, cmpy);</span><br><span class="line">    solve3(<span class="number">0</span>, num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">//已经默认时间从小到大排序了，把时间这一维度消除</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    solve1(l, mid);</span><br><span class="line">    solve1(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    FOR(i, l, mid)  <span class="keyword">if</span>(queries[i].kind == <span class="number">0</span>)    queries_x[num++] = queries[i];</span><br><span class="line">    FOR(i, mid + <span class="number">1</span>, r)  <span class="keyword">if</span>(queries[i].kind)     queries_x[num++] = queries[i];</span><br><span class="line">    sort(queries_x, queries_x + num, cmpx);<span class="comment">//对x从小到大排序</span></span><br><span class="line">    solve2(<span class="number">0</span>, num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, n;</span><br><span class="line">    <span class="keyword">int</span> x1, x2, y1, y2, z1, z2, kind;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, -<span class="number">1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        z_num = <span class="number">0</span>;</span><br><span class="line">        REP(i, n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;kind);</span><br><span class="line">            <span class="keyword">if</span>(kind == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x1, &amp;y1, &amp;z1);</span><br><span class="line">                queries[id++] = Query(x1, y1, z1, <span class="number">0</span>, i);</span><br><span class="line">                que[z_num++] = z1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;z1, &amp;x2, &amp;y2, &amp;z2);</span><br><span class="line">                queries[id++] = Query(x2    , y2    , z2    , <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x2    , y2    , z1 - <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">                queries[id++] = Query(x2    , y1 - <span class="number">1</span>, z2    , <span class="number">1</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y2    , z2    , <span class="number">1</span>, i);</span><br><span class="line">                queries[id++] = Query(x2    , y1 - <span class="number">1</span>, z1 - <span class="number">1</span>, <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y2    , z1 - <span class="number">1</span>, <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>, z2    , <span class="number">2</span>, i);</span><br><span class="line">                queries[id++] = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>, z1 - <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">                que[z_num++] = z2;</span><br><span class="line">                que[z_num++] = z1 - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            sort(que, que + z_num);</span><br><span class="line">            z_num = unique(que, que + z_num) - que;</span><br><span class="line">            REP(i, id)  queries[i].z = lower_bound(que, que + z_num, queries[i].z) - que + <span class="number">1</span>;</span><br><span class="line">            solve1(<span class="number">0</span>, id - <span class="number">1</span>);</span><br><span class="line">            REP(i, n)</span><br><span class="line">                <span class="keyword">if</span>(ans[i] != -<span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>参考文献：<a href="http://wenku.baidu.com/view/52f9c11cff00bed5b9f31d2d.html">从《Cash》谈一类分治算法的应用</a> — 陈丹琦</p>
<p>也因此简称CDQ分治。</p>
<p>个人理解CDQ分治和普通分治最大的区别为：<br>普通分治可以将问题拆成几个相互独立的子问题<br>CDQ分治将问题分成了两个部分：</p>
<ol>
<li>相互独立的两个子问题  </li>
<li>两个子问题之间的联系</li>
</ol>
<p>因此，CDQ分治的算法流程也分为以下几步：</p>
<blockquote>
<ol>
<li>算法开始</li>
<li>取一个中间点mid, 将问题分为[L, mid] 和 [mid + 1, R]两个部分。分别处理两个子问题</li>
<li>处理[L, mid] 和 [mid + 1, R]之间的联系</li>
</ol>
</blockquote>]]>
    
    </summary>
    
      <category term="HDU" scheme="http://teveillan.com/tags/HDU/"/>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HDU 5208 Where is Bob && Bestcoder Round38 C题]]></title>
    <link href="http://teveillan.com/2015/04/21/HDU-5208-Where-is-Bob-Bestcoder-Round38-C%E9%A2%98/"/>
    <id>http://teveillan.com/2015/04/21/HDU-5208-Where-is-Bob-Bestcoder-Round38-C题/</id>
    <published>2015-04-21T09:57:45.000Z</published>
    <updated>2015-05-07T11:53:49.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5208" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5208</a></p>
<p>近似于数位DP的思路。<br>用数位DP求区间中符号条件的数有多少的时候，有时会用一个符号位来记录当前的取值是否达到区间的上界。这里同样用这个办法。（官方题解我有点没看懂，我的解法有可能和官方题解不一样）</p>
<p>看到题第一眼，觉得应该优先从高位到低位处理，在以下两种情况中，决策应该是确定的：</p>
<ul>
<li>第一个人只能取0或1中的一个。这时候第二个人一定是尽量取和第一个人一样的值。</li>
<li>第二个人只能取0或1中得一个，而第一个人两个都可以选。第一个人自然取第二个人取不到的值。</li>
</ul>
<p>但是，当在这两种情况之外，决策就不唯一了。这时，先把低位的决策解决了就很有必要。<br><a id="more"></a><br>我们用dp[i][l1][r1][l2][r2]来表示。 </p>
<blockquote>
<p><code>l1</code> 为1时，表示 <strong>假设第一个人从最高位到第i+1位的取值都是取区间范围允许的最小值。</strong> 此时，第一个人在第i位的取值要小心不要小于区间允许的最小值。<br>反之<code>l1</code>为0时，表示<strong>假设第一个人从最高位到第i+1位的取值有一个不是区间范围的最小值</strong>，这时候，从第i位到第0位取任何值都不会小于区间允许的最小值了。</p>
</blockquote>
<p>请仔细理解上面这段话。</p>
<p>同理，<code>r1</code>代表之前取的是不是区间范围允许的最大值。然后能类推倒l2, r2。</p>
<p>对于每一位, 我们枚举l1, r1, l2, r2。<strong>（再次阐明一下，l1, r1, l2, r2不是表示第i位两个人的取值范围，是表示高位的取值是不是都是边界值。）</strong> 当l1, r1, l2, r2确定以后，第i位两个人的取值范围也就确定了，枚举两个人的取值，用第i-1位递推到第i位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">40</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> casnum, casid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; casnum;</span><br><span class="line">    <span class="keyword">while</span>(casnum--) &#123;</span><br><span class="line">        REP(i, <span class="number">31</span>)</span><br><span class="line">            REP(a, <span class="number">2</span>)</span><br><span class="line">                REP(b, <span class="number">2</span>)</span><br><span class="line">                    REP(c, <span class="number">2</span>)</span><br><span class="line">                        REP(d, <span class="number">2</span>)</span><br><span class="line">                            dp[i][a][b][c][d] = <span class="number">1e15</span>;</span><br><span class="line">        <span class="keyword">int</span> l[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        REP(i, <span class="number">2</span>)</span><br><span class="line">            REP(j, <span class="number">2</span>)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; l[i][j];</span><br><span class="line"></span><br><span class="line">        FOR(i, <span class="number">0</span>, <span class="number">31</span>) &#123;</span><br><span class="line">            REP(a, <span class="number">2</span>)</span><br><span class="line">                REP(b, <span class="number">2</span>)</span><br><span class="line">                    REP(c, <span class="number">2</span>)</span><br><span class="line">                        REP(d, <span class="number">2</span>) &#123; <span class="comment">//枚举高位的取值是不是都是边界值</span></span><br><span class="line">                            <span class="keyword">bool</span> tmp_l[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#125;; </span><br><span class="line">                            <span class="comment">// 确定此时两个人的取值范围</span></span><br><span class="line">                            <span class="keyword">if</span>(a)   tmp_l[<span class="number">0</span>][<span class="number">0</span>] = l[<span class="number">0</span>][<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                            <span class="comment">//当第一个人高位的取值都是下界值，而且第i位的下界值为1时</span></span><br><span class="line">                            <span class="comment">//第i位的取值范围的下界为1。否则第i位的取值范围的下界为0。</span></span><br><span class="line">                            <span class="keyword">if</span>(b)   tmp_l[<span class="number">0</span>][<span class="number">1</span>] = l[<span class="number">0</span>][<span class="number">1</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                            <span class="comment">//都类比第一个</span></span><br><span class="line">                            <span class="keyword">if</span>(c)   tmp_l[<span class="number">1</span>][<span class="number">0</span>] = l[<span class="number">1</span>][<span class="number">0</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                            <span class="keyword">if</span>(d)   tmp_l[<span class="number">1</span>][<span class="number">1</span>] = l[<span class="number">1</span>][<span class="number">1</span>] &amp; (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line"></span><br><span class="line">                            ll tmp1 = <span class="number">0</span>;</span><br><span class="line">                            FOR(j, tmp_l[<span class="number">0</span>][<span class="number">0</span>], tmp_l[<span class="number">0</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                            <span class="comment">//取值范围确定了，现在我们来枚举值。j是第一个人的取值</span></span><br><span class="line">                                ll tmp2 = <span class="number">1e15</span>;</span><br><span class="line">                                FOR(k, tmp_l[<span class="number">1</span>][<span class="number">0</span>], tmp_l[<span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                                    <span class="comment">//第i位的异或值加上i-1位的dp值就是第i位的dp值。</span></span><br><span class="line">                                    <span class="comment">//但是我们得先算出两个人分别取j和k的情况下</span></span><br><span class="line">                                    <span class="comment">//高位的取值加上第i位的取值是否依然达到上下界</span></span><br><span class="line">                                    <span class="keyword">bool</span> tmp[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125; &#125;;</span><br><span class="line">                                    <span class="keyword">if</span>(a &amp;&amp; (j == tmp_l[<span class="number">0</span>][<span class="number">0</span>])) tmp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="comment">//当且仅当高位取值到达下界,第i位又取到下界值得时候,</span></span><br><span class="line">                                    <span class="comment">//对i-1位来说高位的取值达到下界</span></span><br><span class="line">                                    <span class="keyword">if</span>(b &amp;&amp; (j == tmp_l[<span class="number">0</span>][<span class="number">1</span>])) tmp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span>(c &amp;&amp; (k == tmp_l[<span class="number">1</span>][<span class="number">0</span>])) tmp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span>(d &amp;&amp; (k == tmp_l[<span class="number">1</span>][<span class="number">1</span>])) tmp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span>(i)</span><br><span class="line">                                        tmp2 = min(tmp2, ((ll)(j^k) &lt;&lt; i) + dp[i-<span class="number">1</span>][tmp[<span class="number">0</span>][<span class="number">0</span>]][tmp[<span class="number">0</span>][<span class="number">1</span>]][tmp[<span class="number">1</span>][<span class="number">0</span>]][tmp[<span class="number">1</span>][<span class="number">1</span>]]);</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        tmp2 = min(tmp2, ((ll)(j^k) &lt;&lt; i));</span><br><span class="line">                                &#125;</span><br><span class="line">                                tmp1 = max(tmp1, tmp2);</span><br><span class="line">                            &#125;</span><br><span class="line">                            dp[i][a][b][c][d] = tmp1;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = dp[<span class="number">31</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %I64d\n"</span>, ++casid, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=5208">http://acm.hdu.edu.cn/showproblem.php?pid=5208</a></p>
<p>近似于数位DP的思路。<br>用数位DP求区间中符号条件的数有多少的时候，有时会用一个符号位来记录当前的取值是否达到区间的上界。这里同样用这个办法。（官方题解我有点没看懂，我的解法有可能和官方题解不一样）</p>
<p>看到题第一眼，觉得应该优先从高位到低位处理，在以下两种情况中，决策应该是确定的：</p>
<ul>
<li>第一个人只能取0或1中的一个。这时候第二个人一定是尽量取和第一个人一样的值。</li>
<li>第二个人只能取0或1中得一个，而第一个人两个都可以选。第一个人自然取第二个人取不到的值。</li>
</ul>
<p>但是，当在这两种情况之外，决策就不唯一了。这时，先把低位的决策解决了就很有必要。<br>]]>
    
    </summary>
    
      <category term="BestCoder" scheme="http://teveillan.com/tags/BestCoder/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BestCoder Round #25]]></title>
    <link href="http://teveillan.com/2015/01/09/BestCoder-Round-25/"/>
    <id>http://teveillan.com/2015/01/09/BestCoder-Round-25/</id>
    <published>2015-01-09T05:57:46.000Z</published>
    <updated>2015-05-07T11:53:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1001_Harry_and_Magical_Computer">1001 Harry and Magical Computer</h2><p>就是判断有没有环存在。<br>点比较少，Floyd一遍O(n^3)就行。</p>
<h2 id="1002_Harry_And_Magic_Box">1002 Harry And Magic Box</h2><p>官方题解是O(n^4)的，其实中间有一维可以省略。（小地方而已。。不管也罢。。）<br><a id="more"></a><br>dp[i][j]表示第i行已经有j列被选过（这j个不一定全都是在第i行选的，有可能包括之前选的）。<br>则dp公式为： <code>(1 &lt;= k &lt;= j)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k == j)</span><br><span class="line">    dp[i][j] += dp[i-<span class="number">1</span>][k] * ((<span class="number">1</span>&lt;&lt;k) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dp[i][j] += dp[i-<span class="number">1</span>][k] * (<span class="number">1</span>&lt;&lt;k) * c[m-k][j-k];</span><br></pre></td></tr></table></figure>
<p>表示假如<code>k==j</code>，前k个中至少选一个，种类数为<code>((1&lt;&lt;k) - 1)</code>。<br>否则， 前k个随便选， 其余从<code>m-k</code>中选<code>j-k</code>个。<br>注意数据溢出。</p>
<h2 id="1003_Harry_and_Christmas_tree">1003 Harry and Christmas tree</h2><p>我是按照官方题解的思路。<br>对每种颜色单独考虑。对第i-1个有这种颜色点a, 第i个有这种颜色的点b， 以及a和b的lca点c。 在递归过程中，c之前的点都可以被贡献1中颜色，直到c以及c往上，贡献度为a和b各一个，然后减去a和b的重复一个，总共为1。</p>
<p>中间要用到lca算法，因为这道题就是按照递归的顺序进行遍历，用离线的lca就行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;head[N], gift[N];</span><br><span class="line"><span class="keyword">int</span> fa[N], ans[N];</span><br><span class="line"><span class="keyword">int</span> pre_color[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])    <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    REP(i, head[now].size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head[now][i] != pre) &#123;</span><br><span class="line">            dfs(head[now][i], now); </span><br><span class="line">            fa[ head[now][i] ] = now; <span class="comment">//离线lca中得一部分</span></span><br><span class="line">            ans[now] += ans[ head[now][i] ]; <span class="comment">//将子节点的贡献度加上来。（这时候子节点的贡献度已经是 总贡献度 - 重复次数 了）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    REP(i, gift[now].size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> color = gift[now][i];</span><br><span class="line">        <span class="keyword">if</span>(!pre_color[color])  &#123; <span class="comment">//第一个出现这种颜色，跳过不处理</span></span><br><span class="line">            pre_color[color] = now;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lca = find(pre_color[color]); <span class="comment">// 找lca</span></span><br><span class="line">        --ans[lca]; <span class="comment">// 在lca上加上一个重复度, ans--</span></span><br><span class="line"></span><br><span class="line">        pre_color[color] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[now] += gift[now].size(); <span class="comment">//加上本节点的贡献</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(pre_color, <span class="number">0</span>, <span class="keyword">sizeof</span>(pre_color));</span><br><span class="line">        FOR(i, <span class="number">1</span>, n)    fa[i] = i, head[i].clear(), gift[i].clear();</span><br><span class="line">        REP(i, n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x, &amp;y);</span><br><span class="line">            head[x].pb(y);</span><br><span class="line">            head[y].pb(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">            gift[x].pb(y);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        FOR(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)    <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Harry_and_magic_string">Harry and magic string</h2><p>DP + Manacher算法</p>
<p>DP思路很简单。<br>sum[i] 表示以i结尾和i之前结尾的回文串总数。<br>dp[i] 表示以i开头的回文串数。</p>
<blockquote>
<p>ans = $$\sum_{i=1}^{len-1} {sum[i-1] * dp[i]}$$</p>
</blockquote>
<p>难点就是<code>sum[i]</code> 和 <code>dp[i]</code> 怎么求的问题了。<br>新学习了个算法， Manacher算法，在我转载的上篇文章中有讲解。<a href="http://teveillan.com/2015/01/09/-%E8%BD%AC-Manacher%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E4%B8%B2%E5%A4%84%E7%90%86/" target="_blank" rel="external">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stack&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cmath&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdlib&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOR(i,l,r)  for(int i=(l); i&lt;=(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> REP(i,r)    for(int i=0; i&lt;(r); ++i)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DWN(i,r,l)  for(int i=(r);i&gt;=(l);--i)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[MAX_LEN];</span><br><span class="line"><span class="keyword">int</span> Len[MAX_LEN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> Manacher &#123; <span class="comment">// Manacher算法, 讲解看上篇文章</span></span><br><span class="line">    <span class="keyword">char</span> tmp_str[MAX_LEN&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            tmp_str[id++] = s[i];</span><br><span class="line">            tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_str[id] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = init(s);</span><br><span class="line">        <span class="keyword">int</span> max_r = -<span class="number">1</span>, max_id = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max_r &gt; i)   Len[i] = min(max_r - i, Len[<span class="number">2</span> * max_id - i]);</span><br><span class="line">            <span class="keyword">else</span> Len[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i - Len[i] &gt;= <span class="number">0</span> &amp;&amp; i + Len[i] &lt; len &amp;&amp; tmp_str[i - Len[i]] == tmp_str[i + Len[i]])</span><br><span class="line">                ++Len[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i + Len[i] &gt; max_r) &#123;</span><br><span class="line">                max_r = i + Len[i];</span><br><span class="line">                max_id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[MAX_LEN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> flag[MAX_LEN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span> ,<span class="keyword">sizeof</span>(flag));</span><br><span class="line">        Manacher manacher;</span><br><span class="line">        manacher.solve(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (len&lt;&lt;<span class="number">1</span>); ++i) &#123; <span class="comment">//求sum</span></span><br><span class="line">            sum[i] += sum[i-<span class="number">1</span>];</span><br><span class="line">            ++tmp;</span><br><span class="line"></span><br><span class="line">            tmp -= flag[i];</span><br><span class="line">            ++flag[i + Len[i]];</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) sum[i] += tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">        tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (len&lt;&lt;<span class="number">1</span>); i &gt;= <span class="number">1</span>; --i) &#123; <span class="comment">//求ans</span></span><br><span class="line">            ++tmp;</span><br><span class="line">            tmp -= flag[i];</span><br><span class="line">            ++flag[i - Len[i]];</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ans += sum[i-<span class="number">1</span>] * tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1001_Harry_and_Magical_Computer">1001 Harry and Magical Computer</h2><p>就是判断有没有环存在。<br>点比较少，Floyd一遍O(n^3)就行。</p>
<h2 id="1002_Harry_And_Magic_Box">1002 Harry And Magic Box</h2><p>官方题解是O(n^4)的，其实中间有一维可以省略。（小地方而已。。不管也罢。。）<br>]]>
    
    </summary>
    
      <category term="BestCoder" scheme="http://teveillan.com/tags/BestCoder/"/>
    
      <category term="红名之路" scheme="http://teveillan.com/categories/%E7%BA%A2%E5%90%8D%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[转]Manacher算法-回文串处理]]></title>
    <link href="http://teveillan.com/2015/01/09/-%E8%BD%AC-Manacher%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%96%87%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://teveillan.com/2015/01/09/-转-Manacher算法-回文串处理/</id>
    <published>2015-01-09T03:45:39.000Z</published>
    <updated>2015-05-11T06:53:09.000Z</updated>
    <content type="html"><![CDATA[<p><strong>Manacher</strong>算法是查找一个字符串的最长回文子串的线性算法。<br>在介绍算法之前，首先介绍一下什么是回文串，所谓回文串，简单来说就是正着读和反着读都是一样的字符串，比如abba，noon等等，一个字符串的最长回文子串即为这个字符串的子串中，是回文串的最长的那个。<br>计算字符串的最长回文字串最简单的算法就是枚举该字符串的每一个子串，并且判断这个子串是否为回文串，这个算法的时间复杂度为O(n^3)的，显然无法令人满意，稍微优化的一个算法是枚举回文串的中点，这里要分为两种情况，一种是回文串长度是奇数的情况，另一种是回文串长度是偶数的情况，枚举中点再判断是否是回文串，这样能把算法的时间复杂度降为O(n^2)，但是当n比较大的时候仍然无法令人满意，Manacher算法可以在线性时间复杂度内求出一个字符串的最长回文字串，达到了理论上的下界。</p>
<a id="more"></a>
<h1 id="Manacher算法原理与实现">Manacher算法原理与实现</h1><p>下面介绍Manacher算法的原理与步骤。<br>首先，Manacher算法提供了一种巧妙地办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑，具体做法是，在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现，一般情况下可以用#号。下面举一个例子：<br><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-1.png" alt=""></p>
<h2 id="Len数组简介与性质">Len数组简介与性质</h2><p>Manacher算法用一个辅助数组Len[i]表示以字符T[i]为中心的最长回文字串的最右字符到T[i]的长度，比如以T[i]为中心的最长回文字串是T[l,r],那么Len[i]=r-i+1。<br>对于上面的例子，可以得出Len[i]数组为:</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-2.png" alt=""></p>
<p>Len数组有一个性质，那就是Len[i]-1就是该回文子串在原字符串S中的长度，至于证明，首先在转换得到的字符串T中，所有的回文字串的长度都为奇数，那么对于以T[i]为中心的最长回文字串，其长度就为2*Len[i]-1,经过观察可知，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是有Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1。<br>有了这个性质，那么原问题就转化为求所有的Len[i]。下面介绍如何在线性时间复杂度内求出所有的Len。</p>
<h2 id="Len数组的计算">Len数组的计算</h2><p>首先从左往右依次计算Len[i]，当计算Len[i]时，Len<a href="0&lt;=j&lt;i">j</a>已经计算完毕。设P为之前计算中最长回文子串的右端点的最大值，并且设取得这个最大值的位置为po，分两种情况：<br>第一种情况：i&lt;=P<br>那么找到i相对于po的对称位置，设为j，那么如果Len[j]&lt;P-i，如下图：</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-3.png" alt=""></p>
<p>那么说明以j为中心的回文串一定在以po为中心的回文串的内部，且j和i关于位置po对称，由回文串的定义可知，一个回文串反过来还是一个回文串，所以以i为中心的回文串的长度至少和以j为中心的回文串一样，即Len[i]&gt;=Len[j]。因为Len[j]<p-i,所以说i+len[j]<p。由对称性可知len[i]=len[j]。 如果len[j]="">=P-i,由对称性，说明以i为中心的回文串可能会延伸到P之外，而大于P的部分我们还没有进行匹配，所以要从P+1位置开始一个一个进行匹配，直到发生失配，从而更新P和对应的po以及Len[i]。</p-i,所以说i+len[j]<p。由对称性可知len[i]=len[j]。></p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-4.png" alt=""></p>
<p>第二种情况: i&gt;P<br>如果i比P还要大，说明对于中点为i的回文串还一点都没有匹配，这个时候，就只能老老实实地一个一个匹配了，匹配完成后要更新P的位置和对应的po以及Len[i]。</p>
<p><img src="http://7tszmu.com1.z0.glb.clouddn.com/Manacher-5.png" alt=""></p>
<h1 id="时间复杂度分析">时间复杂度分析</h1><p>Manacher算法的时间复杂度分析和Z算法类似，因为算法只有遇到还没有匹配的位置时才进行匹配，已经匹配过的位置不再进行匹配，所以对于T字符串中的每一个位置，只进行一次匹配，所以Manacher算法的总体时间复杂度为O(n)，其中n为T字符串的长度，由于T的长度事实上是S的两倍，所以时间复杂度依然是线性的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Len[MAX_LEN&lt;&lt;<span class="number">1</span>]; <span class="comment">//记录算法完成后以i点为中心最长回文串向左向右延伸的半径</span></span><br><span class="line"><span class="keyword">struct</span> Manacher &#123;</span><br><span class="line">    <span class="keyword">char</span> tmp_str[MAX_LEN&lt;&lt;<span class="number">1</span>]; <span class="comment">//记录预处理过后的字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123; <span class="comment">//在solve中就直接调用了。对原串进行预处理。</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            tmp_str[id++] = s[i];</span><br><span class="line">            tmp_str[id++] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_str[id] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">return</span> id; <span class="comment">//此时的id即为处理过后的字符串长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123; <span class="comment">//从这开始处理</span></span><br><span class="line">        <span class="keyword">int</span> len = init(s);</span><br><span class="line">        <span class="keyword">int</span> max_r = -<span class="number">1</span>, max_id = -<span class="number">1</span>; <span class="comment">// 最右能到得地方，以及最右时的中心点id</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max_r &gt; i)   Len[i] = min(max_r - i, Len[<span class="number">2</span> * max_id - i]);</span><br><span class="line">            <span class="keyword">else</span> Len[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(i - Len[i] &gt;= <span class="number">0</span> &amp;&amp; i + Len[i] &lt; len &amp;&amp; tmp_str[i - Len[i]] == tmp_str[i + Len[i]])</span><br><span class="line">                ++Len[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i + Len[i] &gt; max_r) &#123;</span><br><span class="line">                max_r = i + Len[i];</span><br><span class="line">                max_id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>转自：<a href="http://blog.csdn.net/dyx404514/article/details/42061017" target="_blank" rel="external">http://blog.csdn.net/dyx404514/article/details/42061017</a><br>作者：dyx心心</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Manacher</strong>算法是查找一个字符串的最长回文子串的线性算法。<br>在介绍算法之前，首先介绍一下什么是回文串，所谓回文串，简单来说就是正着读和反着读都是一样的字符串，比如abba，noon等等，一个字符串的最长回文子串即为这个字符串的子串中，是回文串的最长的那个。<br>计算字符串的最长回文字串最简单的算法就是枚举该字符串的每一个子串，并且判断这个子串是否为回文串，这个算法的时间复杂度为O(n^3)的，显然无法令人满意，稍微优化的一个算法是枚举回文串的中点，这里要分为两种情况，一种是回文串长度是奇数的情况，另一种是回文串长度是偶数的情况，枚举中点再判断是否是回文串，这样能把算法的时间复杂度降为O(n^2)，但是当n比较大的时候仍然无法令人满意，Manacher算法可以在线性时间复杂度内求出一个字符串的最长回文字串，达到了理论上的下界。</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://teveillan.com/categories/Algorithm/"/>
    
  </entry>
  
</feed>